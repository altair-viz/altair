# -*- coding: utf-8 -*-
# Auto-generated by schemapi: do not modify file directly
# - schemapi version: 0.3.0.dev0+791c7f6
# - date:    2017-08-17 14:33:46



import traitlets as T
from . import jstraitlets as jst


def _localname(name):
    """Construct an object name relative to the local module"""
    return "{0}.{1}".format(__name__, name)



class AggregateOp(jst.JSONEnum):
    """
    One of ['argmax', 'argmin', 'average', 'count', 'distinct', 'max', 'mean', 'median', 'min', 'missing', 'modeskew', 'q1', 'q3', 'ci0', 'ci1', 'stdev', 'stdevp', 'sum', 'valid', 'values', 'variance', 'variancep']
    """
    values = ['argmax', 'argmin', 'average', 'count', 'distinct', 'max', 'mean', 'median', 'min', 'missing', 'modeskew', 'q1', 'q3', 'ci0', 'ci1', 'stdev', 'stdevp', 'sum', 'valid', 'values', 'variance', 'variancep']
    def __init__(self, **kwargs):
        super(AggregateOp, self).__init__(self.values, **kwargs)


class AxisOrient(jst.JSONEnum):
    """
    One of ['top', 'right', 'left', 'bottom']
    """
    values = ['top', 'right', 'left', 'bottom']
    def __init__(self, **kwargs):
        super(AxisOrient, self).__init__(self.values, **kwargs)


class BOXPLOT(jst.JSONEnum):
    """
    One of ['box-plot']
    """
    values = ['box-plot']
    def __init__(self, **kwargs):
        super(BOXPLOT, self).__init__(self.values, **kwargs)


class DataFormatType(jst.JSONEnum):
    """
    One of ['json', 'csv', 'tsv', 'topojson']
    """
    values = ['json', 'csv', 'tsv', 'topojson']
    def __init__(self, **kwargs):
        super(DataFormatType, self).__init__(self.values, **kwargs)


class ERRORBAR(jst.JSONEnum):
    """
    One of ['error-bar']
    """
    values = ['error-bar']
    def __init__(self, **kwargs):
        super(ERRORBAR, self).__init__(self.values, **kwargs)


class FontStyle(jst.JSONEnum):
    """
    One of ['normal', 'italic']
    """
    values = ['normal', 'italic']
    def __init__(self, **kwargs):
        super(FontStyle, self).__init__(self.values, **kwargs)


class FontWeight(jst.JSONEnum):
    """
    One of ['normal', 'bold']
    """
    values = ['normal', 'bold']
    def __init__(self, **kwargs):
        super(FontWeight, self).__init__(self.values, **kwargs)


class HorizontalAlign(jst.JSONEnum):
    """
    One of ['left', 'right', 'center']
    """
    values = ['left', 'right', 'center']
    def __init__(self, **kwargs):
        super(HorizontalAlign, self).__init__(self.values, **kwargs)


class Interpolate(jst.JSONEnum):
    """
    One of ['linear', 'linear-closed', 'step', 'step-before', 'step-after', 'basis', 'basis-open', 'basis-closed', 'cardinal', 'cardinal-open', 'cardinal-closed', 'bundle', 'monotone']
    """
    values = ['linear', 'linear-closed', 'step', 'step-before', 'step-after', 'basis', 'basis-open', 'basis-closed', 'cardinal', 'cardinal-open', 'cardinal-closed', 'bundle', 'monotone']
    def __init__(self, **kwargs):
        super(Interpolate, self).__init__(self.values, **kwargs)


class LegendOrient(jst.JSONEnum):
    """
    One of ['left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right', 'none']
    """
    values = ['left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right', 'none']
    def __init__(self, **kwargs):
        super(LegendOrient, self).__init__(self.values, **kwargs)


class Mark(jst.JSONEnum):
    """
    One of ['area', 'bar', 'line', 'point', 'text', 'tick', 'rect', 'rule', 'circle', 'square']
    """
    values = ['area', 'bar', 'line', 'point', 'text', 'tick', 'rect', 'rule', 'circle', 'square']
    def __init__(self, **kwargs):
        super(Mark, self).__init__(self.values, **kwargs)


class Orient(jst.JSONEnum):
    """
    One of ['horizontal', 'vertical']
    """
    values = ['horizontal', 'vertical']
    def __init__(self, **kwargs):
        super(Orient, self).__init__(self.values, **kwargs)


class ResolveMode(jst.JSONEnum):
    """
    One of ['independent', 'shared']
    """
    values = ['independent', 'shared']
    def __init__(self, **kwargs):
        super(ResolveMode, self).__init__(self.values, **kwargs)


class ScaleType(jst.JSONEnum):
    """
    One of ['linear', 'bin-linear', 'log', 'pow', 'sqrt', 'time', 'utc', 'sequential', 'ordinal', 'bin-ordinal', 'point', 'band']
    """
    values = ['linear', 'bin-linear', 'log', 'pow', 'sqrt', 'time', 'utc', 'sequential', 'ordinal', 'bin-ordinal', 'point', 'band']
    def __init__(self, **kwargs):
        super(ScaleType, self).__init__(self.values, **kwargs)


class SelectionResolution(jst.JSONEnum):
    """
    One of ['global', 'union', 'intersect']
    """
    values = ['global', 'union', 'intersect']
    def __init__(self, **kwargs):
        super(SelectionResolution, self).__init__(self.values, **kwargs)


class SingleDefChannel(jst.JSONEnum):
    """
    One of ['x', 'y', 'x2', 'y2', 'row', 'column', 'size', 'shape', 'color', 'opacity', 'text', 'tooltip']
    """
    values = ['x', 'y', 'x2', 'y2', 'row', 'column', 'size', 'shape', 'color', 'opacity', 'text', 'tooltip']
    def __init__(self, **kwargs):
        super(SingleDefChannel, self).__init__(self.values, **kwargs)


class StackOffset(jst.JSONEnum):
    """
    One of ['zero', 'center', 'normalize', 'none']
    """
    values = ['zero', 'center', 'normalize', 'none']
    def __init__(self, **kwargs):
        super(StackOffset, self).__init__(self.values, **kwargs)


class TimeUnit(jst.JSONEnum):
    """
    One of ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds', 'milliseconds', 'yearmonth', 'yearmonthdate', 'yearmonthdatehours', 'yearmonthdatehoursminutes', 'yearmonthdatehoursminutesseconds', 'monthdate', 'hoursminutes', 'hoursminutesseconds', 'minutesseconds', 'secondsmilliseconds', 'quarter', 'yearquarter', 'quartermonth', 'yearquartermonth', 'utcyear', 'utcmonth', 'utcday', 'utcdate', 'utchours', 'utcminutes', 'utcseconds', 'utcmilliseconds', 'utcyearmonth', 'utcyearmonthdate', 'utcyearmonthdatehours', 'utcyearmonthdatehoursminutes', 'utcyearmonthdatehoursminutesseconds', 'utcmonthdate', 'utchoursminutes', 'utchoursminutesseconds', 'utcminutesseconds', 'utcsecondsmilliseconds', 'utcquarter', 'utcyearquarter', 'utcquartermonth', 'utcyearquartermonth']
    """
    values = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds', 'milliseconds', 'yearmonth', 'yearmonthdate', 'yearmonthdatehours', 'yearmonthdatehoursminutes', 'yearmonthdatehoursminutesseconds', 'monthdate', 'hoursminutes', 'hoursminutesseconds', 'minutesseconds', 'secondsmilliseconds', 'quarter', 'yearquarter', 'quartermonth', 'yearquartermonth', 'utcyear', 'utcmonth', 'utcday', 'utcdate', 'utchours', 'utcminutes', 'utcseconds', 'utcmilliseconds', 'utcyearmonth', 'utcyearmonthdate', 'utcyearmonthdatehours', 'utcyearmonthdatehoursminutes', 'utcyearmonthdatehoursminutesseconds', 'utcmonthdate', 'utchoursminutes', 'utchoursminutesseconds', 'utcminutesseconds', 'utcsecondsmilliseconds', 'utcquarter', 'utcyearquarter', 'utcquartermonth', 'utcyearquartermonth']
    def __init__(self, **kwargs):
        super(TimeUnit, self).__init__(self.values, **kwargs)


class Type(jst.JSONEnum):
    """
    One of ['quantitative', 'ordinal', 'temporal', 'nominal']
    """
    values = ['quantitative', 'ordinal', 'temporal', 'nominal']
    def __init__(self, **kwargs):
        super(Type, self).__init__(self.values, **kwargs)


class VerticalAlign(jst.JSONEnum):
    """
    One of ['top', 'middle', 'bottom']
    """
    values = ['top', 'middle', 'bottom']
    def __init__(self, **kwargs):
        super(VerticalAlign, self).__init__(self.values, **kwargs)


class CompositeMarkConfigMixins(jst.AnyOfObject):
    _classes = (jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'boxWhisker': jst.JSONInstance(_localname('MarkConfig')), 'boxMid': jst.JSONInstance(_localname('MarkConfig')), 'box': jst.JSONInstance(_localname('BoxPlotConfig'), help='Box Config'), '_additional_traits': False, '_required_traits': []})),)


class CompositeMarkDef(jst.AnyOfObject):
    _classes = (jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'extent': jst.JSONAnyOf([jst.JSONEnum(['min-max']), jst.JSONNumber()]), 'orient': Orient(), '_required_traits': ['type'], '_additional_traits': False, 'type': BOXPLOT()})),)


class CompositeUnitSpec(jst.AnyOfObject):
    _classes = (jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': False, 'transform': jst.JSONArray(jst.JSONInstance(_localname('Transform')), help='An array of data transformations such as filter and new field [...]'), '_required_traits': ['mark', 'encoding'], 'width': jst.JSONNumber(help='The width of a visualization. __Default value:__ This will be [...]'), 'selection': jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': [jst.JSONInstance(_localname('SelectionDef'))], '_required_traits': []}), help='A key-value mapping between selection names and definitions.'), 'height': jst.JSONNumber(help='The height of a visualization. __Default value:__ - For y-axis [...]'), 'encoding': jst.JSONInstance(_localname('Encoding'), help='A key-value mapping between encoding channels and definition of [...]'), 'name': jst.JSONString(help='Name of the visualization for later reference.'), 'description': jst.JSONString(help='An optional description of this mark for commenting purpose.'), 'mark': jst.JSONAnyOf([jst.JSONAnyOf([BOXPLOT(), ERRORBAR()]), jst.JSONInstance(_localname('CompositeMarkDef')), Mark(help='All types of primitive marks.'), jst.JSONInstance(_localname('MarkDef'))]), 'data': jst.JSONInstance(_localname('Data'), help='An object describing the data source')})),)


class FacetedUnitSpec(jst.AnyOfObject):
    _classes = (jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': False, 'transform': jst.JSONArray(jst.JSONInstance(_localname('Transform')), help='An array of data transformations such as filter and new field [...]'), '_required_traits': ['mark', 'encoding'], 'width': jst.JSONNumber(help='The width of a visualization. __Default value:__ This will be [...]'), 'selection': jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': [jst.JSONInstance(_localname('SelectionDef'))], '_required_traits': []}), help='A key-value mapping between selection names and definitions.'), 'height': jst.JSONNumber(help='The height of a visualization. __Default value:__ - For y-axis [...]'), 'encoding': jst.JSONInstance(_localname('EncodingWithFacet'), help='A key-value mapping between encoding channels and definition of [...]'), 'name': jst.JSONString(help='Name of the visualization for later reference.'), 'description': jst.JSONString(help='An optional description of this mark for commenting purpose.'), 'mark': jst.JSONAnyOf([jst.JSONAnyOf([BOXPLOT(), ERRORBAR()]), jst.JSONInstance(_localname('CompositeMarkDef')), Mark(help='All types of primitive marks.'), jst.JSONInstance(_localname('MarkDef'))]), 'data': jst.JSONInstance(_localname('Data'), help='An object describing the data source')})),)


class Root(jst.AnyOfObject):
    _classes = (jst.JSONInstance(_localname('TopLevelExtendedSpec')),)


class ConditionalNumberLegendDef(jst.AnyOfObject):
    _classes = (jst.JSONInstance(_localname('ConditionalNumberLegendFieldDef')),jst.JSONInstance(_localname('ConditionalNumberLegendValueDef')),jst.JSONInstance(_localname('ConditionOnlyNumberLegendDef')),)


class ConditionalStringLegendDef(jst.AnyOfObject):
    _classes = (jst.JSONInstance(_localname('ConditionalStringLegendFieldDef')),jst.JSONInstance(_localname('ConditionalStringLegendValueDef')),jst.JSONInstance(_localname('ConditionOnlyStringLegendDef')),)


class ConditionalTextDef(jst.AnyOfObject):
    _classes = (jst.JSONInstance(_localname('ConditionalTextFieldDef')),jst.JSONInstance(_localname('ConditionalTextValueDef')),jst.JSONInstance(_localname('ConditionOnlyTextDef')),)


class Data(jst.AnyOfObject):
    _classes = (jst.JSONInstance(_localname('UrlData')),jst.JSONInstance(_localname('InlineData')),jst.JSONInstance(_localname('NamedData')),)


class SelectionDef(jst.AnyOfObject):
    _classes = (jst.JSONInstance(_localname('SingleSelection')),jst.JSONInstance(_localname('MultiSelection')),jst.JSONInstance(_localname('IntervalSelection')),)


class SelectionDomain(jst.AnyOfObject):
    _classes = (jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'field': jst.JSONString(), '_required_traits': ['selection'], 'selection': jst.JSONString(), '_additional_traits': False})),jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'encoding': jst.JSONString(), '_required_traits': ['selection'], 'selection': jst.JSONString(), '_additional_traits': False})),)


class Spec(jst.AnyOfObject):
    _classes = (jst.JSONInstance(_localname('CompositeUnitSpec')),jst.JSONInstance(_localname('LayerSpec')),jst.JSONInstance(_localname('FacetedSpec')),jst.JSONInstance(_localname('RepeatSpec')),jst.JSONInstance(_localname('VConcatSpec')),jst.JSONInstance(_localname('HConcatSpec')),)


class TopLevelExtendedSpec(jst.AnyOfObject):
    _classes = (jst.JSONInstance(_localname('TopLevelFacetedUnitSpec')),jst.JSONInstance(_localname('TopLevelLayerSpec')),jst.JSONInstance(_localname('TopLevelFacetedSpec')),jst.JSONInstance(_localname('TopLevelRepeatSpec')),jst.JSONInstance(_localname('TopLevelVConcatSpec')),jst.JSONInstance(_localname('TopLevelHConcatSpec')),)


class Transform(jst.AnyOfObject):
    _classes = (jst.JSONInstance(_localname('FilterTransform')),jst.JSONInstance(_localname('CalculateTransform')),jst.JSONInstance(_localname('LookupTransform')),jst.JSONInstance(_localname('BinTransform')),jst.JSONInstance(_localname('TimeUnitTransform')),jst.JSONInstance(_localname('SummarizeTransform')),)


class VgBinding(jst.AnyOfObject):
    _classes = (jst.JSONInstance(_localname('VgCheckboxBinding')),jst.JSONInstance(_localname('VgRadioBinding')),jst.JSONInstance(_localname('VgSelectBinding')),jst.JSONInstance(_localname('VgRangeBinding')),jst.JSONInstance(_localname('VgGenericBinding')),)


class AndFilter(jst.JSONHasTraits):
    """AndFilter class

    

    Attributes
    ----------
    and_ : Array(AnyOf([NotFilter, AndFilter, OrFilter, AnyOf([EqualFilter, RangeFilter, OneOfFilter, SelectionFilter, string])]))
        
    """
    _additional_traits = False
    _required_traits = ['and']
    _trait_name_map = {'and_': 'and'}
    and_ = jst.JSONArray(jst.JSONAnyOf([jst.JSONInstance(_localname('NotFilter')), jst.JSONInstance(_localname('AndFilter')), jst.JSONInstance(_localname('OrFilter')), jst.JSONAnyOf([jst.JSONInstance(_localname('EqualFilter')), jst.JSONInstance(_localname('RangeFilter')), jst.JSONInstance(_localname('OneOfFilter')), jst.JSONInstance(_localname('SelectionFilter')), jst.JSONString()])]))

    def __init__(self, and_=jst.undefined, **kwargs):
        kwds = dict(and_=and_)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(AndFilter, self).__init__(**kwargs)


class Axis(jst.JSONHasTraits):
    """Axis class

    

    Attributes
    ----------
    domain : boolean
        A boolean flag indicating if the domain (the axis baseline)
        should be included as part of the axis (default true).
    encoding : AxisEncoding
        Optional mark definitions for custom axis encoding.
    format : string
        The formatting pattern for labels. This is D3's [number format
        pattern](https://github.com/mbostock/d3/wiki/Formatting) for
        quantitative fields and D3's [time format
        pattern](https://github.com/mbostock/d3/wiki/Time-Formatting)
        for time field.
        __Default value:__  derived from
        [numberFormat](config.html#format) config for quantitative
        fields and from [timeFormat](config.html#format) config for
        temporal fields.
    grid : boolean
        A boolean flag indicating if grid lines should be included as
        part of the axis
        __Default value:__ `true` for (1) quantitative fields that are
        not binned and (2) time fields;  otherwise, `"false"`.
    labelAngle : number
        The rotation angle of the axis labels.
        __Default value:__ `-45` for time or ordinal axis and `0`
        otherwise.
    labelOverlap : AnyOf([boolean, string, string])
        The strategy to use for resolving overlap of axis labels. If
        `false` (the default), no overlap reduction is attempted. If
        set to `true` or `"parity"`, a strategy of removing every
        other label is used (this works well for standard linear
        axes). If set to `"greedy"`, a linear scan of the labels is
        performed, removing any labels that overlaps with the last
        visible label (this often works better for log-scaled axes).
        __Default value:__ `true` for x-axes with horizontal labels,
        otherwise `false`.
    labelPadding : number
        The padding, in pixels, between axis and text labels.
    labels : boolean
        A boolean flag indicating if labels should be included as part
        of the axis (default true).
        __Default value:__  derived from [axis
        config](config.html#axis-config)'s `labels` (`true` by
        default).
    maxExtent : number
        The maximum extent in pixels that axis ticks and labels should
        use. This determines a maximum offset value for axis titles.
        __Default value:__ `undefined`.
    minExtent : number
        The minimum extent in pixels that axis ticks and labels should
        use. This determines a minimum offset value for axis titles.
        __Default value:__ `30`
    offset : number
        The offset, in pixels, by which to displace the axis from the
        edge of the enclosing group or data rectangle.
        __Default value:__ derived from  [axis
        config](config.html#facet-scale-config)'s `offset` (`0` by
        default)
    orient : string
        The orientation of the axis. One of `"top"`, `"bottom"`,
        `"left"` or `"right"`. The orientation can be used to further
        specialize the axis type (e.g., a y axis oriented for the
        right edge of the chart).
        __Default value:__ x-axis is placed on the bottom, y-axis is
        placed on the left, `column`'s x-axis is placed on the top,
        `row`'s y-axis is placed on the right.
    position : number
        The anchor position of the axis in pixels. For x-axis with top
        or bottom orientation, this sets the axis group x coordinate.
        For y-axis with left or right orientation, this sets the axis
        group y coordinate.
        __Default value__: `0`
    tickCount : number
        A desired number of ticks, for axes visualizing quantitative
        scales. The resulting number may be different so that values
        are "nice" (multiples of 2, 5, 10) and lie within the
        underlying scale's range.
    tickExtra : boolean
        Boolean flag indicating if an extra axis tick should be added
        for the initial position of the axis. This flag is useful for
        styling axes for `band` scales such that ticks are placed on
        band boundaries rather in the middle of a band. Use in
        conjunction with `"bandPostion": 1` and an axis `"padding"`
        value of `0`.
    tickSize : number
        The size, in pixels, of major, minor and end ticks.
        __Default value:__  derived from [axis
        config](config.html#axis-config)'s `tickSize` (`6` by
        default).
    ticks : boolean
        Boolean value that determines whether the axis should include
        ticks.
    title : string
        A title for the field.
        __Default value:__  derived from the field's name and
        transformation function applied e.g, "field_name",
        "SUM(field_name)", "BIN(field_name)", "YEAR(field_name)".
    titleAlign : string
        Horizontal text alignment of axis titles.
    titleAngle : number
        Angle in degrees of axis titles.
    titleMaxLength : number
        Max length for axis title if the title is automatically
        generated from the field's description. By default, this is
        automatically based on cell size and characterWidth property.
        __Default value:__  automatically determined based on the cell
        size (`config.cell.width`, `config.cell.height`)
    titlePadding : number
        The padding, in pixels, between title and axis.
    values : AnyOf([Array(number), Array(DateTime)])
        Explicitly set the visible axis tick values.
    zindex : number
        A non-positive integer indicating z-index of the axis.
        If zindex is 0, axes should be drawn behind all chart
        elements.
        To put them in front, use `"zindex = 1"`.
        __Default value:__ `0` (Behind the marks.)
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    domain = jst.JSONBoolean(help='A boolean flag indicating if the domain (the axis baseline) [...]')
    encoding = jst.JSONInstance(_localname('AxisEncoding'), help='Optional mark definitions for custom axis encoding.')
    format = jst.JSONString(help="The formatting pattern for labels. This is D3's [number format [...]")
    grid = jst.JSONBoolean(help='A boolean flag indicating if grid lines should be included as [...]')
    labelAngle = jst.JSONNumber(help='The rotation angle of the axis labels. __Default value:__ `-45` [...]', maximum=360, minimum=-360)
    labelOverlap = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONEnum(['parity']), jst.JSONEnum(['greedy'])], help='The strategy to use for resolving overlap of axis labels. If [...]')
    labelPadding = jst.JSONNumber(help='The padding, in pixels, between axis and text labels.')
    labels = jst.JSONBoolean(help='A boolean flag indicating if labels should be included as part [...]')
    maxExtent = jst.JSONNumber(help='The maximum extent in pixels that axis ticks and labels should [...]')
    minExtent = jst.JSONNumber(help='The minimum extent in pixels that axis ticks and labels should [...]')
    offset = jst.JSONNumber(help='The offset, in pixels, by which to displace the axis from the [...]')
    orient = AxisOrient()
    position = jst.JSONNumber(help='The anchor position of the axis in pixels. For x-axis with top [...]')
    tickCount = jst.JSONNumber(help='A desired number of ticks, for axes visualizing quantitative [...]', minimum=0)
    tickExtra = jst.JSONBoolean(help='Boolean flag indicating if an extra axis tick should be added [...]')
    tickSize = jst.JSONNumber(help='The size, in pixels, of major, minor and end ticks. __Default [...]', minimum=0)
    ticks = jst.JSONBoolean(help='Boolean value that determines whether the axis should include ticks.')
    title = jst.JSONString(help='A title for the field. __Default value:__ derived from the [...]')
    titleAlign = jst.JSONString(help='Horizontal text alignment of axis titles.')
    titleAngle = jst.JSONNumber(help='Angle in degrees of axis titles.')
    titleMaxLength = jst.JSONNumber(help='Max length for axis title if the title is automatically [...]', minimum=0)
    titlePadding = jst.JSONNumber(help='The padding, in pixels, between title and axis.')
    values = jst.JSONAnyOf([jst.JSONArray(jst.JSONNumber()), jst.JSONArray(jst.JSONInstance(_localname('DateTime')))], help='Explicitly set the visible axis tick values.')
    zindex = jst.JSONNumber(help='A non-positive integer indicating z-index of the axis. If zindex [...]', minimum=0)

    def __init__(self, domain=jst.undefined, encoding=jst.undefined, format=jst.undefined, grid=jst.undefined, labelAngle=jst.undefined, labelOverlap=jst.undefined, labelPadding=jst.undefined, labels=jst.undefined, maxExtent=jst.undefined, minExtent=jst.undefined, offset=jst.undefined, orient=jst.undefined, position=jst.undefined, tickCount=jst.undefined, tickExtra=jst.undefined, tickSize=jst.undefined, ticks=jst.undefined, title=jst.undefined, titleAlign=jst.undefined, titleAngle=jst.undefined, titleMaxLength=jst.undefined, titlePadding=jst.undefined, values=jst.undefined, zindex=jst.undefined, **kwargs):
        kwds = dict(domain=domain, encoding=encoding, format=format, grid=grid, labelAngle=labelAngle, labelOverlap=labelOverlap, labelPadding=labelPadding, labels=labels, maxExtent=maxExtent, minExtent=minExtent, offset=offset, orient=orient, position=position, tickCount=tickCount, tickExtra=tickExtra, tickSize=tickSize, ticks=ticks, title=title, titleAlign=titleAlign, titleAngle=titleAngle, titleMaxLength=titleMaxLength, titlePadding=titlePadding, values=values, zindex=zindex)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Axis, self).__init__(**kwargs)


class AxisConfig(jst.JSONHasTraits):
    """AxisConfig class

    

    Attributes
    ----------
    bandPosition : number
        An interpolation fraction indicating where, for `band` scales,
        axis ticks should be positioned. A value of `0` places ticks
        at the left edge of their bands. A value of `0.5` places ticks
        in the middle of their bands.
    domain : boolean
        A boolean flag indicating if the domain (the axis baseline)
        should be included as part of the axis (default true).
    domainColor : string
        Color of axis domain line.
        __Default value:__  (none, using Vega default).
    domainWidth : number
        Stroke width of axis domain line
        __Default value:__  (none, using Vega default).
    grid : boolean
        A boolean flag indicating if grid lines should be included as
        part of the axis
        __Default value:__ `true` for (1) quantitative fields that are
        not binned and (2) time fields;  otherwise, `"false"`.
    gridColor : string
        Color of gridlines.
    gridDash : Array(number)
        The offset (in pixels) into which to begin drawing with the
        grid dash array.
    gridOpacity : number
        The stroke opacity of grid (value between [0,1])
        __Default value:__ (`1` by default)
    gridWidth : number
        The grid width, in pixels.
    labelAngle : number
        The rotation angle of the axis labels.
        __Default value:__ `-45` for time or ordinal axis and `0`
        otherwise.
    labelColor : string
        The color of the tick label, can be in hex color code or
        regular color name.
    labelFont : string
        The font of the tick label.
    labelFontSize : number
        The font size of the label, in pixels.
        __Default value:__ `10`.
    labelLimit : number
        Maximum allowed pixel width of axis tick labels.
    labelOverlap : AnyOf([boolean, string, string])
        The strategy to use for resolving overlap of axis labels. If
        `false` (the default), no overlap reduction is attempted. If
        set to `true` or `"parity"`, a strategy of removing every
        other label is used (this works well for standard linear
        axes). If set to `"greedy"`, a linear scan of the labels is
        performed, removing any labels that overlaps with the last
        visible label (this often works better for log-scaled axes).
        __Default value:__ `true` for x-axes with horizontal labels,
        otherwise `false`.
    labelPadding : number
        Padding in pixels between axis ticks and tick labels.
    labels : boolean
        A boolean flag indicating if labels should be included as part
        of the axis (default true).
        __Default value:__  derived from [axis
        config](config.html#axis-config)'s `labels` (`true` by
        default).
    maxExtent : number
        The maximum extent in pixels that axis ticks and labels should
        use. This determines a maximum offset value for axis titles.
        __Default value:__ `undefined`.
    minExtent : number
        The minimum extent in pixels that axis ticks and labels should
        use. This determines a minimum offset value for axis titles.
        __Default value:__ `30`
    shortTimeLabels : boolean
        Whether month names and weekday names should be abbreviated.
        __Default value:__  `false`
    tickColor : string
        The color of the axis's tick.
    tickExtra : boolean
        Boolean flag indicating if an extra axis tick should be added
        for the initial position of the axis. This flag is useful for
        styling axes for `band` scales such that ticks are placed on
        band boundaries rather in the middle of a band. Use in
        conjunction with `"bandPostion": 1` and an axis `"padding"`
        value of `0`.
    tickRound : boolean
        Boolean flag indicating if pixel position values should be
        rounded to the nearest integer.
    tickSize : number
        The size, in pixels, of major, minor and end ticks.
        __Default value:__  derived from [axis
        config](config.html#axis-config)'s `tickSize` (`6` by
        default).
    tickWidth : number
        The width, in pixels, of ticks.
    ticks : boolean
        Boolean value that determines whether the axis should include
        ticks.
    titleAlign : string
        Horizontal text alignment of axis titles.
    titleAngle : number
        Angle in degrees of axis titles.
    titleBaseline : string
        Vertical text baseline for axis titles.
    titleColor : string
        Color of the title, can be in hex color code or regular color
        name.
    titleFont : string
        Font of the title. (e.g., `"Helvetica Neue"`).
    titleFontSize : number
        Font size of the title.
        __Default value:__ `10`.
    titleFontWeight : ['string', 'number']
        Font weight of the title. (e.g., `"bold"`).
    titleLimit : number
        Maximum allowed pixel width of axis titles.
    titleMaxLength : number
        Max length for axis title if the title is automatically
        generated from the field's description. By default, this is
        automatically based on cell size and characterWidth property.
        __Default value:__  automatically determined based on the cell
        size (`config.cell.width`, `config.cell.height`)
    titlePadding : number
        The padding, in pixels, between title and axis.
    titleX : number
        X-coordinate of the axis title relative to the axis group.
    titleY : number
        Y-coordinate of the axis title relative to the axis group.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    bandPosition = jst.JSONNumber(help='An interpolation fraction indicating where, for `band` scales, [...]')
    domain = jst.JSONBoolean(help='A boolean flag indicating if the domain (the axis baseline) [...]')
    domainColor = jst.JSONString(help='Color of axis domain line. __Default value:__ (none, using Vega [...]')
    domainWidth = jst.JSONNumber(help='Stroke width of axis domain line __Default value:__ (none, using [...]')
    grid = jst.JSONBoolean(help='A boolean flag indicating if grid lines should be included as [...]')
    gridColor = jst.JSONString(help='Color of gridlines.')
    gridDash = jst.JSONArray(jst.JSONNumber(), help='The offset (in pixels) into which to begin drawing with the grid [...]')
    gridOpacity = jst.JSONNumber(help='The stroke opacity of grid (value between [0,1]) __Default [...]', maximum=1, minimum=0)
    gridWidth = jst.JSONNumber(help='The grid width, in pixels.', minimum=0)
    labelAngle = jst.JSONNumber(help='The rotation angle of the axis labels. __Default value:__ `-45` [...]', maximum=360, minimum=-360)
    labelColor = jst.JSONString(help='The color of the tick label, can be in hex color code or regular [...]')
    labelFont = jst.JSONString(help='The font of the tick label.')
    labelFontSize = jst.JSONNumber(help='The font size of the label, in pixels. __Default value:__ `10`.', minimum=0)
    labelLimit = jst.JSONNumber(help='Maximum allowed pixel width of axis tick labels.')
    labelOverlap = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONEnum(['parity']), jst.JSONEnum(['greedy'])], help='The strategy to use for resolving overlap of axis labels. If [...]')
    labelPadding = jst.JSONNumber(help='Padding in pixels between axis ticks and tick labels.')
    labels = jst.JSONBoolean(help='A boolean flag indicating if labels should be included as part [...]')
    maxExtent = jst.JSONNumber(help='The maximum extent in pixels that axis ticks and labels should [...]')
    minExtent = jst.JSONNumber(help='The minimum extent in pixels that axis ticks and labels should [...]')
    shortTimeLabels = jst.JSONBoolean(help='Whether month names and weekday names should be abbreviated. [...]')
    tickColor = jst.JSONString(help="The color of the axis's tick.")
    tickExtra = jst.JSONBoolean(help='Boolean flag indicating if an extra axis tick should be added [...]')
    tickRound = jst.JSONBoolean(help='Boolean flag indicating if pixel position values should be [...]')
    tickSize = jst.JSONNumber(help='The size, in pixels, of major, minor and end ticks. __Default [...]', minimum=0)
    tickWidth = jst.JSONNumber(help='The width, in pixels, of ticks.', minimum=0)
    ticks = jst.JSONBoolean(help='Boolean value that determines whether the axis should include ticks.')
    titleAlign = jst.JSONString(help='Horizontal text alignment of axis titles.')
    titleAngle = jst.JSONNumber(help='Angle in degrees of axis titles.')
    titleBaseline = jst.JSONString(help='Vertical text baseline for axis titles.')
    titleColor = jst.JSONString(help='Color of the title, can be in hex color code or regular color name.')
    titleFont = jst.JSONString(help='Font of the title. (e.g., `"Helvetica Neue"`).')
    titleFontSize = jst.JSONNumber(help='Font size of the title. __Default value:__ `10`.', minimum=0)
    titleFontWeight = jst.JSONUnion([jst.JSONString(), jst.JSONNumber()], help='Font weight of the title. (e.g., `"bold"`).')
    titleLimit = jst.JSONNumber(help='Maximum allowed pixel width of axis titles.')
    titleMaxLength = jst.JSONNumber(help='Max length for axis title if the title is automatically [...]', minimum=0)
    titlePadding = jst.JSONNumber(help='The padding, in pixels, between title and axis.')
    titleX = jst.JSONNumber(help='X-coordinate of the axis title relative to the axis group.')
    titleY = jst.JSONNumber(help='Y-coordinate of the axis title relative to the axis group.')

    def __init__(self, bandPosition=jst.undefined, domain=jst.undefined, domainColor=jst.undefined, domainWidth=jst.undefined, grid=jst.undefined, gridColor=jst.undefined, gridDash=jst.undefined, gridOpacity=jst.undefined, gridWidth=jst.undefined, labelAngle=jst.undefined, labelColor=jst.undefined, labelFont=jst.undefined, labelFontSize=jst.undefined, labelLimit=jst.undefined, labelOverlap=jst.undefined, labelPadding=jst.undefined, labels=jst.undefined, maxExtent=jst.undefined, minExtent=jst.undefined, shortTimeLabels=jst.undefined, tickColor=jst.undefined, tickExtra=jst.undefined, tickRound=jst.undefined, tickSize=jst.undefined, tickWidth=jst.undefined, ticks=jst.undefined, titleAlign=jst.undefined, titleAngle=jst.undefined, titleBaseline=jst.undefined, titleColor=jst.undefined, titleFont=jst.undefined, titleFontSize=jst.undefined, titleFontWeight=jst.undefined, titleLimit=jst.undefined, titleMaxLength=jst.undefined, titlePadding=jst.undefined, titleX=jst.undefined, titleY=jst.undefined, **kwargs):
        kwds = dict(bandPosition=bandPosition, domain=domain, domainColor=domainColor, domainWidth=domainWidth, grid=grid, gridColor=gridColor, gridDash=gridDash, gridOpacity=gridOpacity, gridWidth=gridWidth, labelAngle=labelAngle, labelColor=labelColor, labelFont=labelFont, labelFontSize=labelFontSize, labelLimit=labelLimit, labelOverlap=labelOverlap, labelPadding=labelPadding, labels=labels, maxExtent=maxExtent, minExtent=minExtent, shortTimeLabels=shortTimeLabels, tickColor=tickColor, tickExtra=tickExtra, tickRound=tickRound, tickSize=tickSize, tickWidth=tickWidth, ticks=ticks, titleAlign=titleAlign, titleAngle=titleAngle, titleBaseline=titleBaseline, titleColor=titleColor, titleFont=titleFont, titleFontSize=titleFontSize, titleFontWeight=titleFontWeight, titleLimit=titleLimit, titleMaxLength=titleMaxLength, titlePadding=titlePadding, titleX=titleX, titleY=titleY)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(AxisConfig, self).__init__(**kwargs)


class AxisConfigMixins(jst.JSONHasTraits):
    """AxisConfigMixins class

    

    Attributes
    ----------
    axis : AxisConfig
        Generic axis config.
    axisBand : VgAxisConfig
        Specific axis config for axes with "band" scales.
    axisBottom : VgAxisConfig
        Specific axis config for x-axis along the bottom edge of the
        chart.
    axisLeft : VgAxisConfig
        Specific axis config for y-axis along the left edge of the
        chart.
    axisRight : VgAxisConfig
        Specific axis config for y-axis along the right edge of the
        chart.
    axisTop : VgAxisConfig
        Specific axis config for x-axis along the top edge of the
        chart.
    axisX : VgAxisConfig
        X-axis specific config.
    axisY : VgAxisConfig
        Y-axis specific config.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    axis = jst.JSONInstance(_localname('AxisConfig'), help='Generic axis config.')
    axisBand = jst.JSONInstance(_localname('VgAxisConfig'), help='Specific axis config for axes with "band" scales.')
    axisBottom = jst.JSONInstance(_localname('VgAxisConfig'), help='Specific axis config for x-axis along the bottom edge of the chart.')
    axisLeft = jst.JSONInstance(_localname('VgAxisConfig'), help='Specific axis config for y-axis along the left edge of the chart.')
    axisRight = jst.JSONInstance(_localname('VgAxisConfig'), help='Specific axis config for y-axis along the right edge of the chart.')
    axisTop = jst.JSONInstance(_localname('VgAxisConfig'), help='Specific axis config for x-axis along the top edge of the chart.')
    axisX = jst.JSONInstance(_localname('VgAxisConfig'), help='X-axis specific config.')
    axisY = jst.JSONInstance(_localname('VgAxisConfig'), help='Y-axis specific config.')

    def __init__(self, axis=jst.undefined, axisBand=jst.undefined, axisBottom=jst.undefined, axisLeft=jst.undefined, axisRight=jst.undefined, axisTop=jst.undefined, axisX=jst.undefined, axisY=jst.undefined, **kwargs):
        kwds = dict(axis=axis, axisBand=axisBand, axisBottom=axisBottom, axisLeft=axisLeft, axisRight=axisRight, axisTop=axisTop, axisX=axisX, axisY=axisY)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(AxisConfigMixins, self).__init__(**kwargs)


class AxisEncoding(jst.JSONHasTraits):
    """AxisEncoding class

    

    Attributes
    ----------
    axis : GuideEncodingEntry
        Custom encoding for the axis container.
    domain : GuideEncodingEntry
        Custom encoding for the axis domain rule mark.
    grid : GuideEncodingEntry
        Custom encoding for axis gridline rule marks.
    labels : GuideEncodingEntry
        Custom encoding for axis label text marks.
    ticks : GuideEncodingEntry
        Custom encoding for axis tick rule marks.
    title : GuideEncodingEntry
        Custom encoding for the axis title text mark.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    axis = jst.JSONInstance(_localname('GuideEncodingEntry'), help='Custom encoding for the axis container.')
    domain = jst.JSONInstance(_localname('GuideEncodingEntry'), help='Custom encoding for the axis domain rule mark.')
    grid = jst.JSONInstance(_localname('GuideEncodingEntry'), help='Custom encoding for axis gridline rule marks.')
    labels = jst.JSONInstance(_localname('GuideEncodingEntry'), help='Custom encoding for axis label text marks.')
    ticks = jst.JSONInstance(_localname('GuideEncodingEntry'), help='Custom encoding for axis tick rule marks.')
    title = jst.JSONInstance(_localname('GuideEncodingEntry'), help='Custom encoding for the axis title text mark.')

    def __init__(self, axis=jst.undefined, domain=jst.undefined, grid=jst.undefined, labels=jst.undefined, ticks=jst.undefined, title=jst.undefined, **kwargs):
        kwds = dict(axis=axis, domain=domain, grid=grid, labels=labels, ticks=ticks, title=title)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(AxisEncoding, self).__init__(**kwargs)


class BarConfig(jst.JSONHasTraits):
    """BarConfig class

    

    Attributes
    ----------
    align : string
        The horizontal alignment of the text. One of `"left"`,
        `"right"`, `"center"`.
    angle : number
        The rotation angle of the text, in degrees.
    baseline : string
        The vertical alignment of the text. One of `"top"`,
        `"middle"`, `"bottom"`.
        __Default value:__ `"middle"`
    binSpacing : number
        Offset between bar for binned field.  Ideal value for this is
        either 0 (Preferred by statisticians) or 1 (Vega-Lite Default,
        D3 example style).
        __Default value:__ `1`
    color : string
        Default color.
        __Default value:__ <span style="color:
        #4682b4;">&#9632;</span> `"#4682b4"`
    continuousBandSize : number
        The default size of the bars on continuous scales.
        __Default value:__ `2`
    discreteBandSize : number
        The size of the bars.  If unspecified, the default size is
        `bandSize-1`,
        which provides 1 pixel offset between bars.
    dx : number
        The horizontal offset, in pixels, between the text label and
        its anchor point. The offset is applied after rotation by the
        _angle_ property.
    dy : number
        The vertical offset, in pixels, between the text label and its
        anchor point. The offset is applied after rotation by the
        _angle_ property.
    fill : string
        Default Fill Color.  This has higher precedence than
        config.color
        __Default value:__ (None)
    fillOpacity : number
        The fill opacity (value between [0,1]).
        __Default value:__ `1`
    filled : boolean
        Whether the mark's color should be used as fill color instead
        of stroke color.
        __Default value:__ `true` for all marks except `point` and
        `false` for `point`.
        __Applicable for:__ `bar`, `point`, `circle`, `square`, and
        `area` marks.
    font : string
        The typeface to set the text in (e.g., `"Helvetica Neue"`).
    fontSize : number
        The font size, in pixels.
    fontStyle : string
        The font style (e.g., `"italic"`).
    fontWeight : AnyOf([string, number])
        The font weight (e.g., `"bold"`).
    interpolate : string
        The line interpolation method to use for line and area marks.
        One of the following:
        - `"linear"`: piecewise linear segments, as in a polyline.
        - `"linear-closed"`: close the linear segments to form a
          polygon.
        - `"step"`: alternate between horizontal and vertical
          segments, as in a step function.
        - `"step-before"`: alternate between vertical and horizontal
          segments, as in a step function.
        - `"step-after"`: alternate between horizontal and vertical
          segments, as in a step function.
        - `"basis"`: a B-spline, with control point duplication on
          the ends.
        - `"basis-open"`: an open B-spline; may not intersect the
          start or end.
        - `"basis-closed"`: a closed B-spline, as in a loop.
        - `"cardinal"`: a Cardinal spline, with control point
          duplication on the ends.
        - `"cardinal-open"`: an open Cardinal spline; may not
          intersect the start or end, but will intersect other control
          points.
        - `"cardinal-closed"`: a closed Cardinal spline, as in a
          loop.
        - `"bundle"`: equivalent to basis, except the tension
          parameter is used to straighten the spline.
        - `"monotone"`: cubic interpolation that preserves
          monotonicity in y.
    opacity : number
        The overall opacity (value between [0,1]).
        __Default value:__ `0.7` for non-aggregate plots with `point`,
        `tick`, `circle`, or `square` marks or layered `bar` charts
        and `1` otherwise.
    orient : string
        The orientation of a non-stacked bar, tick, area, and line
        charts.
        The value is either horizontal (default) or vertical.
        - For bar, rule and tick, this determines whether the size
          of the bar and tick
        should be applied to x or y dimension.
        - For area, this property determines the orient property of
          the Vega output.
        - For line, this property determines the sort order of the
          points in the line
        if `config.sortLineBy` is not specified.
        For stacked charts, this is always determined by the
        orientation of the stack;
        therefore explicitly specified value will be ignored.
    radius : number
        Polar coordinate radial offset, in pixels, of the text label
        from the origin determined by the `x` and `y` properties.
    shape : string
        The default symbol shape to use. One of: `"circle"` (default),
        `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, or
        `"triangle-down"`, or a custom SVG path.
        __Default value:__ `"circle"`
    size : number
        The pixel area each the point/circle/square.
        For example: in the case of circles, the radius is determined
        in part by the square root of the size value.
        __Default value:__ `30`
    stroke : string
        Default Stroke Color.  This has higher precedence than
        config.color
        __Default value:__ (None)
    strokeDash : Array(number)
        An array of alternating stroke, space lengths for creating
        dashed or dotted lines.
    strokeDashOffset : number
        The offset (in pixels) into which to begin drawing with the
        stroke dash array.
    strokeOpacity : number
        The stroke opacity (value between [0,1]).
        __Default value:__ `1`
    strokeWidth : number
        The stroke width, in pixels.
    tension : number
        Depending on the interpolation type, sets the tension
        parameter (for line and area marks).
    text : string
        Placeholder text if the `text` channel is not specified
    theta : number
        Polar coordinate angle, in radians, of the text label from the
        origin determined by the `x` and `y` properties. Values for
        `theta` follow the same convention of `arc` mark `startAngle`
        and `endAngle` properties: angles are measured in radians,
        with `0` indicating "north".
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    align = HorizontalAlign()
    angle = jst.JSONNumber(help='The rotation angle of the text, in degrees.', maximum=360, minimum=0)
    baseline = VerticalAlign()
    binSpacing = jst.JSONNumber(help='Offset between bar for binned field. Ideal value for this is [...]', minimum=0)
    color = jst.JSONString(help='Default color. __Default value:__ <span style="color: [...]')
    continuousBandSize = jst.JSONNumber(help='The default size of the bars on continuous scales. __Default [...]', minimum=0)
    discreteBandSize = jst.JSONNumber(help='The size of the bars. If unspecified, the default size is [...]', minimum=0)
    dx = jst.JSONNumber(help='The horizontal offset, in pixels, between the text label and its [...]')
    dy = jst.JSONNumber(help='The vertical offset, in pixels, between the text label and its [...]')
    fill = jst.JSONString(help='Default Fill Color. This has higher precedence than config.color [...]')
    fillOpacity = jst.JSONNumber(help='The fill opacity (value between [0,1]). __Default value:__ `1`', maximum=1, minimum=0)
    filled = jst.JSONBoolean(help="Whether the mark's color should be used as fill color instead of [...]")
    font = jst.JSONString(help='The typeface to set the text in (e.g., `"Helvetica Neue"`).')
    fontSize = jst.JSONNumber(help='The font size, in pixels.', minimum=0)
    fontStyle = FontStyle()
    fontWeight = jst.JSONAnyOf([FontWeight(), jst.JSONNumber(maximum=900, minimum=100)], help='The font weight (e.g., `"bold"`).')
    interpolate = Interpolate()
    opacity = jst.JSONNumber(help='The overall opacity (value between [0,1]). __Default value:__ [...]', maximum=1, minimum=0)
    orient = Orient()
    radius = jst.JSONNumber(help='Polar coordinate radial offset, in pixels, of the text label [...]', minimum=0)
    shape = jst.JSONString(help='The default symbol shape to use. One of: `"circle"` (default), [...]')
    size = jst.JSONNumber(help='The pixel area each the point/circle/square. For example: in the [...]', minimum=0)
    stroke = jst.JSONString(help='Default Stroke Color. This has higher precedence than [...]')
    strokeDash = jst.JSONArray(jst.JSONNumber(), help='An array of alternating stroke, space lengths for creating [...]')
    strokeDashOffset = jst.JSONNumber(help='The offset (in pixels) into which to begin drawing with the [...]')
    strokeOpacity = jst.JSONNumber(help='The stroke opacity (value between [0,1]). __Default value:__ `1`', maximum=1, minimum=0)
    strokeWidth = jst.JSONNumber(help='The stroke width, in pixels.', minimum=0)
    tension = jst.JSONNumber(help='Depending on the interpolation type, sets the tension parameter [...]', maximum=1, minimum=0)
    text = jst.JSONString(help='Placeholder text if the `text` channel is not specified')
    theta = jst.JSONNumber(help='Polar coordinate angle, in radians, of the text label from the [...]')

    def __init__(self, align=jst.undefined, angle=jst.undefined, baseline=jst.undefined, binSpacing=jst.undefined, color=jst.undefined, continuousBandSize=jst.undefined, discreteBandSize=jst.undefined, dx=jst.undefined, dy=jst.undefined, fill=jst.undefined, fillOpacity=jst.undefined, filled=jst.undefined, font=jst.undefined, fontSize=jst.undefined, fontStyle=jst.undefined, fontWeight=jst.undefined, interpolate=jst.undefined, opacity=jst.undefined, orient=jst.undefined, radius=jst.undefined, shape=jst.undefined, size=jst.undefined, stroke=jst.undefined, strokeDash=jst.undefined, strokeDashOffset=jst.undefined, strokeOpacity=jst.undefined, strokeWidth=jst.undefined, tension=jst.undefined, text=jst.undefined, theta=jst.undefined, **kwargs):
        kwds = dict(align=align, angle=angle, baseline=baseline, binSpacing=binSpacing, color=color, continuousBandSize=continuousBandSize, discreteBandSize=discreteBandSize, dx=dx, dy=dy, fill=fill, fillOpacity=fillOpacity, filled=filled, font=font, fontSize=fontSize, fontStyle=fontStyle, fontWeight=fontWeight, interpolate=interpolate, opacity=opacity, orient=orient, radius=radius, shape=shape, size=size, stroke=stroke, strokeDash=strokeDash, strokeDashOffset=strokeDashOffset, strokeOpacity=strokeOpacity, strokeWidth=strokeWidth, tension=tension, text=text, theta=theta)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(BarConfig, self).__init__(**kwargs)


class BaseBin(jst.JSONHasTraits):
    """BaseBin class

    

    Attributes
    ----------
    base : number
        The number base to use for automatic bin determination
        (default is base 10).
        __Default value:__ `10`
    divide : Array(number)
        Scale factors indicating allowable subdivisions. The default
        value is [5, 2], which indicates that for base 10 numbers (the
        default base), the method may consider dividing bin sizes by 5
        and/or 2. For example, for an initial step size of 10, the
        method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1
        (= 10/(5*2)) might also satisfy the given constraints.
        __Default value:__ `[5, 2]`
    maxbins : number
        Maximum number of bins.
        __Default value:__ `6` for `row`, `column` and `shape`
        channels; `10` for other channels
    minstep : number
        A minimum allowable step size (particularly useful for integer
        values).
    nice : boolean
        If true (the default), attempts to make the bin boundaries use
        human-friendly boundaries, such as multiples of ten.
    step : number
        An exact step size to use between bins.
        __Note:__ If provided, options such as maxbins will be
        ignored.
    steps : Array(number)
        An array of allowable step sizes to choose from.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    base = jst.JSONNumber(help='The number base to use for automatic bin determination (default [...]')
    divide = jst.JSONArray(jst.JSONNumber(), help='Scale factors indicating allowable subdivisions. The default [...]', minlen=1)
    maxbins = jst.JSONNumber(help='Maximum number of bins. __Default value:__ `6` for `row`, [...]', minimum=2)
    minstep = jst.JSONNumber(help='A minimum allowable step size (particularly useful for integer [...]')
    nice = jst.JSONBoolean(help='If true (the default), attempts to make the bin boundaries use [...]')
    step = jst.JSONNumber(help='An exact step size to use between bins. __Note:__ If provided, [...]')
    steps = jst.JSONArray(jst.JSONNumber(), help='An array of allowable step sizes to choose from.', minlen=1)

    def __init__(self, base=jst.undefined, divide=jst.undefined, maxbins=jst.undefined, minstep=jst.undefined, nice=jst.undefined, step=jst.undefined, steps=jst.undefined, **kwargs):
        kwds = dict(base=base, divide=divide, maxbins=maxbins, minstep=minstep, nice=nice, step=step, steps=steps)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(BaseBin, self).__init__(**kwargs)


class BaseSelectionDef(jst.JSONHasTraits):
    """BaseSelectionDef class

    

    Attributes
    ----------
    encodings : Array(string)
        An array of encoding channels. The corresponding data field
        values
        must match for a data tuple to fall within the selection.
    fields : Array(string)
        An array of field names whose values must match for a data
        tuple to
        fall within the selection.
    on : Mapping
        A Vega event stream (object or selector) that triggers the
        selection.
    resolve : string
        With layered and multi-view displays, a strategy that
        determines how
        selections' data queries are resolved when applied in a filter
        transform,
        conditional encoding rule, or scale domain. One of: "global",
        "union",
        "intersect", "union_others", or "intersect_others".
        __global__: Only one instance of the selection exists across
        all
        views. When a user interacts within a new view, any previous
        selections
        are overridden.
        __union__: Each view contains its own selection, and a data
        value is
        considered to be selected if it falls within _any_ of these
        selection
        instances.
        __intersect__: Each view contains its own selection, and a
        data value is
        considered to be selected if it falls within _all_ of these
        selection
        instances.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    encodings = jst.JSONArray(SingleDefChannel(), help='An array of encoding channels. The corresponding data field [...]')
    fields = jst.JSONArray(jst.JSONString(), help='An array of field names whose values must match for a data tuple [...]')
    on = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': True, '_required_traits': []}), help='A Vega event stream (object or selector) that triggers the selection.')
    resolve = SelectionResolution()

    def __init__(self, encodings=jst.undefined, fields=jst.undefined, on=jst.undefined, resolve=jst.undefined, **kwargs):
        kwds = dict(encodings=encodings, fields=fields, on=on, resolve=resolve)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(BaseSelectionDef, self).__init__(**kwargs)


class BaseSpec(jst.JSONHasTraits):
    """BaseSpec class

    

    Attributes
    ----------
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
    name : string
        Name of the visualization for later reference.
    transform : Array(Transform)
        An array of data transformations such as filter and new field
        calculation.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose.')
    name = jst.JSONString(help='Name of the visualization for later reference.')
    transform = jst.JSONArray(jst.JSONInstance(_localname('Transform')), help='An array of data transformations such as filter and new field [...]')

    def __init__(self, data=jst.undefined, description=jst.undefined, name=jst.undefined, transform=jst.undefined, **kwargs):
        kwds = dict(data=data, description=description, name=name, transform=transform)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(BaseSpec, self).__init__(**kwargs)


class Bin(jst.JSONHasTraits):
    """Bin class

    Binning properties or boolean flag for determining whether to bin
    data or not.

    Attributes
    ----------
    base : number
        The number base to use for automatic bin determination
        (default is base 10).
        __Default value:__ `10`
    divide : Array(number)
        Scale factors indicating allowable subdivisions. The default
        value is [5, 2], which indicates that for base 10 numbers (the
        default base), the method may consider dividing bin sizes by 5
        and/or 2. For example, for an initial step size of 10, the
        method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1
        (= 10/(5*2)) might also satisfy the given constraints.
        __Default value:__ `[5, 2]`
    extent : Array(number)
        A two-element (`[min, max]`) array indicating the range of
        desired bin values.
    maxbins : number
        Maximum number of bins.
        __Default value:__ `6` for `row`, `column` and `shape`
        channels; `10` for other channels
    minstep : number
        A minimum allowable step size (particularly useful for integer
        values).
    nice : boolean
        If true (the default), attempts to make the bin boundaries use
        human-friendly boundaries, such as multiples of ten.
    step : number
        An exact step size to use between bins.
        __Note:__ If provided, options such as maxbins will be
        ignored.
    steps : Array(number)
        An array of allowable step sizes to choose from.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    base = jst.JSONNumber(help='The number base to use for automatic bin determination (default [...]')
    divide = jst.JSONArray(jst.JSONNumber(), help='Scale factors indicating allowable subdivisions. The default [...]', minlen=1)
    extent = jst.JSONArray(jst.JSONNumber(), help='A two-element (`[min, max]`) array indicating the range of [...]', maxlen=2, minlen=2)
    maxbins = jst.JSONNumber(help='Maximum number of bins. __Default value:__ `6` for `row`, [...]', minimum=2)
    minstep = jst.JSONNumber(help='A minimum allowable step size (particularly useful for integer [...]')
    nice = jst.JSONBoolean(help='If true (the default), attempts to make the bin boundaries use [...]')
    step = jst.JSONNumber(help='An exact step size to use between bins. __Note:__ If provided, [...]')
    steps = jst.JSONArray(jst.JSONNumber(), help='An array of allowable step sizes to choose from.', minlen=1)

    def __init__(self, base=jst.undefined, divide=jst.undefined, extent=jst.undefined, maxbins=jst.undefined, minstep=jst.undefined, nice=jst.undefined, step=jst.undefined, steps=jst.undefined, **kwargs):
        kwds = dict(base=base, divide=divide, extent=extent, maxbins=maxbins, minstep=minstep, nice=nice, step=step, steps=steps)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Bin, self).__init__(**kwargs)


class BinTransform(jst.JSONHasTraits):
    """BinTransform class

    

    Attributes
    ----------
    as_ : string
        The output fields at which to write the start and end bin
        values.
    bin : AnyOf([Bin, boolean])
        An object indicating bin properties, or simply `true` for
        using default bin values..
    field : string
        The data field to bin.
    """
    _additional_traits = False
    _required_traits = ['bin', 'field', 'as']
    _trait_name_map = {'as_': 'as'}
    as_ = jst.JSONString(help='The output fields at which to write the start and end bin values.')
    bin = jst.JSONAnyOf([jst.JSONInstance(_localname('Bin')), jst.JSONEnum([True])], help='An object indicating bin properties, or simply `true` for using [...]')
    field = jst.JSONString(help='The data field to bin.')

    def __init__(self, as_=jst.undefined, bin=jst.undefined, field=jst.undefined, **kwargs):
        kwds = dict(as_=as_, bin=bin, field=field)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(BinTransform, self).__init__(**kwargs)


class BoxPlotConfig(jst.JSONHasTraits):
    """BoxPlotConfig class

    

    Attributes
    ----------
    align : string
        The horizontal alignment of the text. One of `"left"`,
        `"right"`, `"center"`.
    angle : number
        The rotation angle of the text, in degrees.
    baseline : string
        The vertical alignment of the text. One of `"top"`,
        `"middle"`, `"bottom"`.
        __Default value:__ `"middle"`
    color : string
        Default color.
        __Default value:__ <span style="color:
        #4682b4;">&#9632;</span> `"#4682b4"`
    dx : number
        The horizontal offset, in pixels, between the text label and
        its anchor point. The offset is applied after rotation by the
        _angle_ property.
    dy : number
        The vertical offset, in pixels, between the text label and its
        anchor point. The offset is applied after rotation by the
        _angle_ property.
    fill : string
        Default Fill Color.  This has higher precedence than
        config.color
        __Default value:__ (None)
    fillOpacity : number
        The fill opacity (value between [0,1]).
        __Default value:__ `1`
    filled : boolean
        Whether the mark's color should be used as fill color instead
        of stroke color.
        __Default value:__ `true` for all marks except `point` and
        `false` for `point`.
        __Applicable for:__ `bar`, `point`, `circle`, `square`, and
        `area` marks.
    font : string
        The typeface to set the text in (e.g., `"Helvetica Neue"`).
    fontSize : number
        The font size, in pixels.
    fontStyle : string
        The font style (e.g., `"italic"`).
    fontWeight : AnyOf([string, number])
        The font weight (e.g., `"bold"`).
    interpolate : string
        The line interpolation method to use for line and area marks.
        One of the following:
        - `"linear"`: piecewise linear segments, as in a polyline.
        - `"linear-closed"`: close the linear segments to form a
          polygon.
        - `"step"`: alternate between horizontal and vertical
          segments, as in a step function.
        - `"step-before"`: alternate between vertical and horizontal
          segments, as in a step function.
        - `"step-after"`: alternate between horizontal and vertical
          segments, as in a step function.
        - `"basis"`: a B-spline, with control point duplication on
          the ends.
        - `"basis-open"`: an open B-spline; may not intersect the
          start or end.
        - `"basis-closed"`: a closed B-spline, as in a loop.
        - `"cardinal"`: a Cardinal spline, with control point
          duplication on the ends.
        - `"cardinal-open"`: an open Cardinal spline; may not
          intersect the start or end, but will intersect other control
          points.
        - `"cardinal-closed"`: a closed Cardinal spline, as in a
          loop.
        - `"bundle"`: equivalent to basis, except the tension
          parameter is used to straighten the spline.
        - `"monotone"`: cubic interpolation that preserves
          monotonicity in y.
    opacity : number
        The overall opacity (value between [0,1]).
        __Default value:__ `0.7` for non-aggregate plots with `point`,
        `tick`, `circle`, or `square` marks or layered `bar` charts
        and `1` otherwise.
    orient : string
        The orientation of a non-stacked bar, tick, area, and line
        charts.
        The value is either horizontal (default) or vertical.
        - For bar, rule and tick, this determines whether the size
          of the bar and tick
        should be applied to x or y dimension.
        - For area, this property determines the orient property of
          the Vega output.
        - For line, this property determines the sort order of the
          points in the line
        if `config.sortLineBy` is not specified.
        For stacked charts, this is always determined by the
        orientation of the stack;
        therefore explicitly specified value will be ignored.
    radius : number
        Polar coordinate radial offset, in pixels, of the text label
        from the origin determined by the `x` and `y` properties.
    shape : string
        The default symbol shape to use. One of: `"circle"` (default),
        `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, or
        `"triangle-down"`, or a custom SVG path.
        __Default value:__ `"circle"`
    size : number
        Size of the box and mid tick of a box plot
    stroke : string
        Default Stroke Color.  This has higher precedence than
        config.color
        __Default value:__ (None)
    strokeDash : Array(number)
        An array of alternating stroke, space lengths for creating
        dashed or dotted lines.
    strokeDashOffset : number
        The offset (in pixels) into which to begin drawing with the
        stroke dash array.
    strokeOpacity : number
        The stroke opacity (value between [0,1]).
        __Default value:__ `1`
    strokeWidth : number
        The stroke width, in pixels.
    tension : number
        Depending on the interpolation type, sets the tension
        parameter (for line and area marks).
    text : string
        Placeholder text if the `text` channel is not specified
    theta : number
        Polar coordinate angle, in radians, of the text label from the
        origin determined by the `x` and `y` properties. Values for
        `theta` follow the same convention of `arc` mark `startAngle`
        and `endAngle` properties: angles are measured in radians,
        with `0` indicating "north".
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    align = HorizontalAlign()
    angle = jst.JSONNumber(help='The rotation angle of the text, in degrees.', maximum=360, minimum=0)
    baseline = VerticalAlign()
    color = jst.JSONString(help='Default color. __Default value:__ <span style="color: [...]')
    dx = jst.JSONNumber(help='The horizontal offset, in pixels, between the text label and its [...]')
    dy = jst.JSONNumber(help='The vertical offset, in pixels, between the text label and its [...]')
    fill = jst.JSONString(help='Default Fill Color. This has higher precedence than config.color [...]')
    fillOpacity = jst.JSONNumber(help='The fill opacity (value between [0,1]). __Default value:__ `1`', maximum=1, minimum=0)
    filled = jst.JSONBoolean(help="Whether the mark's color should be used as fill color instead of [...]")
    font = jst.JSONString(help='The typeface to set the text in (e.g., `"Helvetica Neue"`).')
    fontSize = jst.JSONNumber(help='The font size, in pixels.', minimum=0)
    fontStyle = FontStyle()
    fontWeight = jst.JSONAnyOf([FontWeight(), jst.JSONNumber(maximum=900, minimum=100)], help='The font weight (e.g., `"bold"`).')
    interpolate = Interpolate()
    opacity = jst.JSONNumber(help='The overall opacity (value between [0,1]). __Default value:__ [...]', maximum=1, minimum=0)
    orient = Orient()
    radius = jst.JSONNumber(help='Polar coordinate radial offset, in pixels, of the text label [...]', minimum=0)
    shape = jst.JSONString(help='The default symbol shape to use. One of: `"circle"` (default), [...]')
    size = jst.JSONNumber(help='Size of the box and mid tick of a box plot')
    stroke = jst.JSONString(help='Default Stroke Color. This has higher precedence than [...]')
    strokeDash = jst.JSONArray(jst.JSONNumber(), help='An array of alternating stroke, space lengths for creating [...]')
    strokeDashOffset = jst.JSONNumber(help='The offset (in pixels) into which to begin drawing with the [...]')
    strokeOpacity = jst.JSONNumber(help='The stroke opacity (value between [0,1]). __Default value:__ `1`', maximum=1, minimum=0)
    strokeWidth = jst.JSONNumber(help='The stroke width, in pixels.', minimum=0)
    tension = jst.JSONNumber(help='Depending on the interpolation type, sets the tension parameter [...]', maximum=1, minimum=0)
    text = jst.JSONString(help='Placeholder text if the `text` channel is not specified')
    theta = jst.JSONNumber(help='Polar coordinate angle, in radians, of the text label from the [...]')

    def __init__(self, align=jst.undefined, angle=jst.undefined, baseline=jst.undefined, color=jst.undefined, dx=jst.undefined, dy=jst.undefined, fill=jst.undefined, fillOpacity=jst.undefined, filled=jst.undefined, font=jst.undefined, fontSize=jst.undefined, fontStyle=jst.undefined, fontWeight=jst.undefined, interpolate=jst.undefined, opacity=jst.undefined, orient=jst.undefined, radius=jst.undefined, shape=jst.undefined, size=jst.undefined, stroke=jst.undefined, strokeDash=jst.undefined, strokeDashOffset=jst.undefined, strokeOpacity=jst.undefined, strokeWidth=jst.undefined, tension=jst.undefined, text=jst.undefined, theta=jst.undefined, **kwargs):
        kwds = dict(align=align, angle=angle, baseline=baseline, color=color, dx=dx, dy=dy, fill=fill, fillOpacity=fillOpacity, filled=filled, font=font, fontSize=fontSize, fontStyle=fontStyle, fontWeight=fontWeight, interpolate=interpolate, opacity=opacity, orient=orient, radius=radius, shape=shape, size=size, stroke=stroke, strokeDash=strokeDash, strokeDashOffset=strokeDashOffset, strokeOpacity=strokeOpacity, strokeWidth=strokeWidth, tension=tension, text=text, theta=theta)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(BoxPlotConfig, self).__init__(**kwargs)


class BoxPlotConfigMixins(jst.JSONHasTraits):
    """BoxPlotConfigMixins class

    

    Attributes
    ----------
    box : BoxPlotConfig
        Box Config
    boxMid : MarkConfig
        
    boxWhisker : MarkConfig
        
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    box = jst.JSONInstance(_localname('BoxPlotConfig'), help='Box Config')
    boxMid = jst.JSONInstance(_localname('MarkConfig'))
    boxWhisker = jst.JSONInstance(_localname('MarkConfig'))

    def __init__(self, box=jst.undefined, boxMid=jst.undefined, boxWhisker=jst.undefined, **kwargs):
        kwds = dict(box=box, boxMid=boxMid, boxWhisker=boxWhisker)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(BoxPlotConfigMixins, self).__init__(**kwargs)


class BoxPlotDef(jst.JSONHasTraits):
    """BoxPlotDef class

    

    Attributes
    ----------
    extent : AnyOf([string, number])
        
    orient : string
        
    type : string
        
    """
    _additional_traits = False
    _required_traits = ['type']
    _trait_name_map = {}
    extent = jst.JSONAnyOf([jst.JSONEnum(['min-max']), jst.JSONNumber()])
    orient = Orient()
    type = BOXPLOT()

    def __init__(self, extent=jst.undefined, orient=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(extent=extent, orient=orient, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(BoxPlotDef, self).__init__(**kwargs)


class BrushConfig(jst.JSONHasTraits):
    """BrushConfig class

    

    Attributes
    ----------
    fill : string
        The fill color of the interval mark.
        __Default value:__ `#333333`
    fillOpacity : number
        The fill opacity of the interval mark (a value between 0 and
        1).
        __Default value:__ `0.125`
    stroke : string
        The stroke color of the interval mark.
        __Default value:__ `#ffffff`
    strokeDash : Array(number)
        An array of alternating stroke and space lengths,
        for creating dashed or dotted lines.
    strokeDashOffset : number
        The offset (in pixels) with which to begin drawing the stroke
        dash array.
    strokeOpacity : number
        The stroke opacity of the interval mark (a value between 0 and
        1).
    strokeWidth : number
        The stroke width of the interval mark.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    fill = jst.JSONString(help='The fill color of the interval mark. __Default value:__ `#333333`')
    fillOpacity = jst.JSONNumber(help='The fill opacity of the interval mark (a value between 0 and 1). [...]')
    stroke = jst.JSONString(help='The stroke color of the interval mark. __Default value:__ `#ffffff`')
    strokeDash = jst.JSONArray(jst.JSONNumber(), help='An array of alternating stroke and space lengths, for creating [...]')
    strokeDashOffset = jst.JSONNumber(help='The offset (in pixels) with which to begin drawing the stroke [...]')
    strokeOpacity = jst.JSONNumber(help='The stroke opacity of the interval mark (a value between 0 and 1).')
    strokeWidth = jst.JSONNumber(help='The stroke width of the interval mark.')

    def __init__(self, fill=jst.undefined, fillOpacity=jst.undefined, stroke=jst.undefined, strokeDash=jst.undefined, strokeDashOffset=jst.undefined, strokeOpacity=jst.undefined, strokeWidth=jst.undefined, **kwargs):
        kwds = dict(fill=fill, fillOpacity=fillOpacity, stroke=stroke, strokeDash=strokeDash, strokeDashOffset=strokeDashOffset, strokeOpacity=strokeOpacity, strokeWidth=strokeWidth)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(BrushConfig, self).__init__(**kwargs)


class CalculateTransform(jst.JSONHasTraits):
    """CalculateTransform class

    

    Attributes
    ----------
    as_ : string
        The field for storing the computed formula value.
    calculate : string
        A string containing a Vega Expression. Use the variable
        `datum` to refer to the current data object.
    """
    _additional_traits = False
    _required_traits = ['calculate', 'as']
    _trait_name_map = {'as_': 'as'}
    as_ = jst.JSONString(help='The field for storing the computed formula value.')
    calculate = jst.JSONString(help='A string containing a Vega Expression. Use the variable `datum` [...]')

    def __init__(self, as_=jst.undefined, calculate=jst.undefined, **kwargs):
        kwds = dict(as_=as_, calculate=calculate)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(CalculateTransform, self).__init__(**kwargs)


class CellConfig(jst.JSONHasTraits):
    """CellConfig class

    

    Attributes
    ----------
    clip : boolean
        Whether the view should be clipped.
    fill : string
        The fill color.
        __Default value:__ (none)
    fillOpacity : number
        The fill opacity (value between [0,1]).
        __Default value:__ (none)
    height : number
        The default height of the single plot or each plot in a
        trellis plot when the visualization has a continuous (non-
        ordinal) y-scale with `rangeStep` = `null`.
        __Default value:__ `200`
    stroke : string
        The stroke color.
        __Default value:__ (none)
    strokeDash : Array(number)
        An array of alternating stroke, space lengths for creating
        dashed or dotted lines.
        __Default value:__ (none)
    strokeDashOffset : number
        The offset (in pixels) into which to begin drawing with the
        stroke dash array.
        __Default value:__ (none)
    strokeOpacity : number
        The stroke opacity (value between [0,1]).
        __Default value:__ (none)
    strokeWidth : number
        The stroke width, in pixels.
        __Default value:__ (none)
    width : number
        The default width of the single plot or each plot in a trellis
        plot when the visualization has a continuous (non-ordinal)
        x-scale or ordinal x-scale with `rangeStep` = `null`.
        __Default value:__ `200`
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    clip = jst.JSONBoolean(help='Whether the view should be clipped.')
    fill = jst.JSONString(help='The fill color. __Default value:__ (none)')
    fillOpacity = jst.JSONNumber(help='The fill opacity (value between [0,1]). __Default value:__ (none)')
    height = jst.JSONNumber(help='The default height of the single plot or each plot in a trellis [...]')
    stroke = jst.JSONString(help='The stroke color. __Default value:__ (none)')
    strokeDash = jst.JSONArray(jst.JSONNumber(), help='An array of alternating stroke, space lengths for creating [...]')
    strokeDashOffset = jst.JSONNumber(help='The offset (in pixels) into which to begin drawing with the [...]')
    strokeOpacity = jst.JSONNumber(help='The stroke opacity (value between [0,1]). __Default value:__ (none)')
    strokeWidth = jst.JSONNumber(help='The stroke width, in pixels. __Default value:__ (none)')
    width = jst.JSONNumber(help='The default width of the single plot or each plot in a trellis [...]')

    def __init__(self, clip=jst.undefined, fill=jst.undefined, fillOpacity=jst.undefined, height=jst.undefined, stroke=jst.undefined, strokeDash=jst.undefined, strokeDashOffset=jst.undefined, strokeOpacity=jst.undefined, strokeWidth=jst.undefined, width=jst.undefined, **kwargs):
        kwds = dict(clip=clip, fill=fill, fillOpacity=fillOpacity, height=height, stroke=stroke, strokeDash=strokeDash, strokeDashOffset=strokeDashOffset, strokeOpacity=strokeOpacity, strokeWidth=strokeWidth, width=width)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(CellConfig, self).__init__(**kwargs)


class CompositeUnitSpecAlias(jst.JSONHasTraits):
    """CompositeUnitSpecAlias class

    

    Attributes
    ----------
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
    encoding : Encoding
        A key-value mapping between encoding channels and definition
        of fields.
    height : number
        The height of a visualization.
        __Default value:__
        - For y-axis with a continuous (non-ordinal) scale, the
          height will be the value of
          [`config.cell.height`](config.html#cell-config).
        - For y-axis with an ordinal scale: if
          [`rangeStep`](scale.html#ordinal) is a numeric value
          (default), the height is determined by the value of
          `rangeStep` and the cardinality of the field mapped to
          y-channel.   Otherwise, if the `rangeStep` is `null`, the
          height will be the value of
          [`config.cell.height`](config.html#cell-config).
        - If no field is mapped to `x` channel, the `height` will be
          the value of `rangeStep`.
        __Note__: For plot with `row` and `column` channels, this
        represents the height of a single cell.
    mark : AnyOf([AnyOf([string, string]), CompositeMarkDef, string, MarkDef])
        A string describing the mark type (one of `"bar"`, `"circle"`,
        `"square"`, `"tick"`, `"line"`,
        `"area"`, `"point"`, `"rule"`, and `"text"`) or a [mark
        definition object](mark.html#mark-def).
    name : string
        Name of the visualization for later reference.
    selection : Mapping
        A key-value mapping between selection names and definitions.
    transform : Array(Transform)
        An array of data transformations such as filter and new field
        calculation.
    width : number
        The width of a visualization.
        __Default value:__ This will be determined by the following
        rules:
        - For x-axis with a continuous (non-ordinal) scale, the
          width will be the value of
          [`config.cell.width`](config.html#cell-config).
        - For x-axis with an ordinal scale: if
          [`rangeStep`](scale.html#ordinal) is a numeric value
          (default), the width is determined by the value of
          `rangeStep` and the cardinality of the field mapped to
          x-channel.   Otherwise, if the `rangeStep` is `null`, the
          width will be the value of
          [`config.cell.width`](config.html#cell-config).
        - If no field is mapped to `x` channel, the `width` will be
          the value of
          [`config.scale.textXRangeStep`](size.html#default-width-and-
          height) for `text` mark and the value of `rangeStep` for
          other marks.
        __Note__: For plot with `row` and `column` channels, this
        represents the width of a single cell.
    """
    _additional_traits = False
    _required_traits = ['mark', 'encoding']
    _trait_name_map = {}
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose.')
    encoding = jst.JSONInstance(_localname('Encoding'), help='A key-value mapping between encoding channels and definition of [...]')
    height = jst.JSONNumber(help='The height of a visualization. __Default value:__ - For y-axis [...]')
    mark = jst.JSONAnyOf([jst.JSONAnyOf([BOXPLOT(), ERRORBAR()]), jst.JSONInstance(_localname('CompositeMarkDef')), Mark(help='All types of primitive marks.'), jst.JSONInstance(_localname('MarkDef'))])
    name = jst.JSONString(help='Name of the visualization for later reference.')
    selection = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': [jst.JSONInstance(_localname('SelectionDef'))], '_required_traits': []}), help='A key-value mapping between selection names and definitions.')
    transform = jst.JSONArray(jst.JSONInstance(_localname('Transform')), help='An array of data transformations such as filter and new field [...]')
    width = jst.JSONNumber(help='The width of a visualization. __Default value:__ This will be [...]')

    def __init__(self, data=jst.undefined, description=jst.undefined, encoding=jst.undefined, height=jst.undefined, mark=jst.undefined, name=jst.undefined, selection=jst.undefined, transform=jst.undefined, width=jst.undefined, **kwargs):
        kwds = dict(data=data, description=description, encoding=encoding, height=height, mark=mark, name=name, selection=selection, transform=transform, width=width)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(CompositeUnitSpecAlias, self).__init__(**kwargs)


class ConditionLegendFieldDef(jst.JSONHasTraits):
    """ConditionLegendFieldDef class

    

    Attributes
    ----------
    aggregate : AnyOf([string, string])
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        __Default value:__ `undefined` (None)
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    field : AnyOf([string, RepeatRef])
        __Required.__ Name of the field from which to pull a data
        value.
        __Note:__ `field` is not required if `aggregate` is `count`.
    legend : AnyOf([Legend, null])
        
    scale : Scale
        
    selection : AnyOf([SelectionNot, SelectionAnd, SelectionOr, string])
        
    sort : AnyOf([SortField, AnyOf([string, string, null])])
        Sort order for a field with discrete domain.
        This can be `"ascending"`, `"descending"`, `null`, or a [sort
        field definition object](sort.html#sort-field) for sorting by
        an aggregate calculation of a specified sort field.
        __Note:__ For fields with continuous domain, please use
        `"scale": {"reverse": true}` to flip the scale instead.
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
        __Default value:__ `undefined` (None)
    type : string
        The encoded field's type of measurement. This can be either a
        full type
        name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and
        `"nominal"`)
        or an initial character of the type name (`"Q"`, `"T"`, `"O"`,
        `"N"`).
        This property is case-insensitive.
    """
    _additional_traits = False
    _required_traits = ['selection', 'type']
    _trait_name_map = {}
    aggregate = jst.JSONAnyOf([AggregateOp(), BOXPLOT()], help='Aggregation function for the field (e.g., `mean`, `sum`, [...]')
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    field = jst.JSONAnyOf([jst.JSONString(), jst.JSONInstance(_localname('RepeatRef'))])
    legend = jst.JSONAnyOf([jst.JSONInstance(_localname('Legend')), jst.JSONNull()])
    scale = jst.JSONInstance(_localname('Scale'))
    selection = jst.JSONAnyOf([jst.JSONInstance(_localname('SelectionNot')), jst.JSONInstance(_localname('SelectionAnd')), jst.JSONInstance(_localname('SelectionOr')), jst.JSONString()])
    sort = jst.JSONAnyOf([jst.JSONInstance(_localname('SortField')), jst.JSONAnyOf([jst.JSONEnum(['ascending']), jst.JSONEnum(['descending']), jst.JSONNull()])], help='Sort order for a field with discrete domain. This can be [...]')
    timeUnit = TimeUnit()
    type = Type(help='Constants and utilities for data type Data type based on level [...]')

    def __init__(self, aggregate=jst.undefined, bin=jst.undefined, field=jst.undefined, legend=jst.undefined, scale=jst.undefined, selection=jst.undefined, sort=jst.undefined, timeUnit=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, bin=bin, field=field, legend=legend, scale=scale, selection=selection, sort=sort, timeUnit=timeUnit, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ConditionLegendFieldDef, self).__init__(**kwargs)


class ConditionNumberValueDef(jst.JSONHasTraits):
    """ConditionNumberValueDef class

    

    Attributes
    ----------
    selection : AnyOf([SelectionNot, SelectionAnd, SelectionOr, string])
        
    value : number
        A constant value in visual domain.
    """
    _additional_traits = False
    _required_traits = ['selection', 'value']
    _trait_name_map = {}
    selection = jst.JSONAnyOf([jst.JSONInstance(_localname('SelectionNot')), jst.JSONInstance(_localname('SelectionAnd')), jst.JSONInstance(_localname('SelectionOr')), jst.JSONString()])
    value = jst.JSONNumber(help='A constant value in visual domain.')

    def __init__(self, selection=jst.undefined, value=jst.undefined, **kwargs):
        kwds = dict(selection=selection, value=value)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ConditionNumberValueDef, self).__init__(**kwargs)


class ConditionOnlyNumberLegendDef(jst.JSONHasTraits):
    """ConditionOnlyNumberLegendDef class

    

    Attributes
    ----------
    condition : AnyOf([ConditionLegendFieldDef, ConditionNumberValueDef])
        
    """
    _additional_traits = False
    _required_traits = ['condition']
    _trait_name_map = {}
    condition = jst.JSONAnyOf([jst.JSONInstance(_localname('ConditionLegendFieldDef')), jst.JSONInstance(_localname('ConditionNumberValueDef'))])

    def __init__(self, condition=jst.undefined, **kwargs):
        kwds = dict(condition=condition)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ConditionOnlyNumberLegendDef, self).__init__(**kwargs)


class ConditionOnlyStringLegendDef(jst.JSONHasTraits):
    """ConditionOnlyStringLegendDef class

    

    Attributes
    ----------
    condition : AnyOf([ConditionLegendFieldDef, ConditionStringValueDef])
        
    """
    _additional_traits = False
    _required_traits = ['condition']
    _trait_name_map = {}
    condition = jst.JSONAnyOf([jst.JSONInstance(_localname('ConditionLegendFieldDef')), jst.JSONInstance(_localname('ConditionStringValueDef'))])

    def __init__(self, condition=jst.undefined, **kwargs):
        kwds = dict(condition=condition)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ConditionOnlyStringLegendDef, self).__init__(**kwargs)


class ConditionOnlyTextDef(jst.JSONHasTraits):
    """ConditionOnlyTextDef class

    

    Attributes
    ----------
    condition : AnyOf([ConditionTextFieldDef, ConditionTextValueDef])
        
    """
    _additional_traits = False
    _required_traits = ['condition']
    _trait_name_map = {}
    condition = jst.JSONAnyOf([jst.JSONInstance(_localname('ConditionTextFieldDef')), jst.JSONInstance(_localname('ConditionTextValueDef'))])

    def __init__(self, condition=jst.undefined, **kwargs):
        kwds = dict(condition=condition)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ConditionOnlyTextDef, self).__init__(**kwargs)


class ConditionStringValueDef(jst.JSONHasTraits):
    """ConditionStringValueDef class

    

    Attributes
    ----------
    selection : AnyOf([SelectionNot, SelectionAnd, SelectionOr, string])
        
    value : string
        A constant value in visual domain.
    """
    _additional_traits = False
    _required_traits = ['selection', 'value']
    _trait_name_map = {}
    selection = jst.JSONAnyOf([jst.JSONInstance(_localname('SelectionNot')), jst.JSONInstance(_localname('SelectionAnd')), jst.JSONInstance(_localname('SelectionOr')), jst.JSONString()])
    value = jst.JSONString(help='A constant value in visual domain.')

    def __init__(self, selection=jst.undefined, value=jst.undefined, **kwargs):
        kwds = dict(selection=selection, value=value)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ConditionStringValueDef, self).__init__(**kwargs)


class ConditionTextFieldDef(jst.JSONHasTraits):
    """ConditionTextFieldDef class

    

    Attributes
    ----------
    aggregate : AnyOf([string, string])
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        __Default value:__ `undefined` (None)
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    field : AnyOf([string, RepeatRef])
        __Required.__ Name of the field from which to pull a data
        value.
        __Note:__ `field` is not required if `aggregate` is `count`.
    format : string
        The formatting pattern for text value. If not defined, this
        will be determined automatically.
    selection : AnyOf([SelectionNot, SelectionAnd, SelectionOr, string])
        
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
        __Default value:__ `undefined` (None)
    type : string
        The encoded field's type of measurement. This can be either a
        full type
        name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and
        `"nominal"`)
        or an initial character of the type name (`"Q"`, `"T"`, `"O"`,
        `"N"`).
        This property is case-insensitive.
    """
    _additional_traits = False
    _required_traits = ['selection', 'type']
    _trait_name_map = {}
    aggregate = jst.JSONAnyOf([AggregateOp(), BOXPLOT()], help='Aggregation function for the field (e.g., `mean`, `sum`, [...]')
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    field = jst.JSONAnyOf([jst.JSONString(), jst.JSONInstance(_localname('RepeatRef'))])
    format = jst.JSONString(help='The formatting pattern for text value. If not defined, this will [...]')
    selection = jst.JSONAnyOf([jst.JSONInstance(_localname('SelectionNot')), jst.JSONInstance(_localname('SelectionAnd')), jst.JSONInstance(_localname('SelectionOr')), jst.JSONString()])
    timeUnit = TimeUnit()
    type = Type(help='Constants and utilities for data type Data type based on level [...]')

    def __init__(self, aggregate=jst.undefined, bin=jst.undefined, field=jst.undefined, format=jst.undefined, selection=jst.undefined, timeUnit=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, bin=bin, field=field, format=format, selection=selection, timeUnit=timeUnit, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ConditionTextFieldDef, self).__init__(**kwargs)


class ConditionTextValueDef(jst.JSONHasTraits):
    """ConditionTextValueDef class

    

    Attributes
    ----------
    selection : AnyOf([SelectionNot, SelectionAnd, SelectionOr, string])
        
    value : ['string', 'number', 'boolean']
        A constant value in visual domain.
    """
    _additional_traits = False
    _required_traits = ['selection', 'value']
    _trait_name_map = {}
    selection = jst.JSONAnyOf([jst.JSONInstance(_localname('SelectionNot')), jst.JSONInstance(_localname('SelectionAnd')), jst.JSONInstance(_localname('SelectionOr')), jst.JSONString()])
    value = jst.JSONUnion([jst.JSONString(), jst.JSONNumber(), jst.JSONBoolean()], help='A constant value in visual domain.')

    def __init__(self, selection=jst.undefined, value=jst.undefined, **kwargs):
        kwds = dict(selection=selection, value=value)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ConditionTextValueDef, self).__init__(**kwargs)


class ConditionalNumberLegendFieldDef(jst.JSONHasTraits):
    """ConditionalNumberLegendFieldDef class

    A FieldDef with ConditionValueDef
    {
       condition: {value: ...},
       field: ...,
       ...
    }

    Attributes
    ----------
    aggregate : AnyOf([string, string])
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        __Default value:__ `undefined` (None)
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    condition : ConditionNumberValueDef
        
    field : AnyOf([string, RepeatRef])
        __Required.__ Name of the field from which to pull a data
        value.
        __Note:__ `field` is not required if `aggregate` is `count`.
    legend : AnyOf([Legend, null])
        
    scale : Scale
        
    sort : AnyOf([SortField, AnyOf([string, string, null])])
        Sort order for a field with discrete domain.
        This can be `"ascending"`, `"descending"`, `null`, or a [sort
        field definition object](sort.html#sort-field) for sorting by
        an aggregate calculation of a specified sort field.
        __Note:__ For fields with continuous domain, please use
        `"scale": {"reverse": true}` to flip the scale instead.
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
        __Default value:__ `undefined` (None)
    type : string
        The encoded field's type of measurement. This can be either a
        full type
        name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and
        `"nominal"`)
        or an initial character of the type name (`"Q"`, `"T"`, `"O"`,
        `"N"`).
        This property is case-insensitive.
    """
    _additional_traits = False
    _required_traits = ['type']
    _trait_name_map = {}
    aggregate = jst.JSONAnyOf([AggregateOp(), BOXPLOT()], help='Aggregation function for the field (e.g., `mean`, `sum`, [...]')
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    condition = jst.JSONInstance(_localname('ConditionNumberValueDef'))
    field = jst.JSONAnyOf([jst.JSONString(), jst.JSONInstance(_localname('RepeatRef'))])
    legend = jst.JSONAnyOf([jst.JSONInstance(_localname('Legend')), jst.JSONNull()])
    scale = jst.JSONInstance(_localname('Scale'))
    sort = jst.JSONAnyOf([jst.JSONInstance(_localname('SortField')), jst.JSONAnyOf([jst.JSONEnum(['ascending']), jst.JSONEnum(['descending']), jst.JSONNull()])], help='Sort order for a field with discrete domain. This can be [...]')
    timeUnit = TimeUnit()
    type = Type(help='Constants and utilities for data type Data type based on level [...]')

    def __init__(self, aggregate=jst.undefined, bin=jst.undefined, condition=jst.undefined, field=jst.undefined, legend=jst.undefined, scale=jst.undefined, sort=jst.undefined, timeUnit=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, bin=bin, condition=condition, field=field, legend=legend, scale=scale, sort=sort, timeUnit=timeUnit, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ConditionalNumberLegendFieldDef, self).__init__(**kwargs)


class ConditionalNumberLegendValueDef(jst.JSONHasTraits):
    """ConditionalNumberLegendValueDef class

    A ValueDef with ConditionValueDef | FieldDef
    {
       condition: {field: ...} | {value: ...},
       value: ...,
    }

    Attributes
    ----------
    condition : AnyOf([ConditionLegendFieldDef, ConditionNumberValueDef])
        
    value : number
        A constant value in visual domain.
    """
    _additional_traits = False
    _required_traits = ['value']
    _trait_name_map = {}
    condition = jst.JSONAnyOf([jst.JSONInstance(_localname('ConditionLegendFieldDef')), jst.JSONInstance(_localname('ConditionNumberValueDef'))])
    value = jst.JSONNumber(help='A constant value in visual domain.')

    def __init__(self, condition=jst.undefined, value=jst.undefined, **kwargs):
        kwds = dict(condition=condition, value=value)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ConditionalNumberLegendValueDef, self).__init__(**kwargs)


class ConditionalStringLegendFieldDef(jst.JSONHasTraits):
    """ConditionalStringLegendFieldDef class

    A FieldDef with ConditionValueDef
    {
       condition: {value: ...},
       field: ...,
       ...
    }

    Attributes
    ----------
    aggregate : AnyOf([string, string])
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        __Default value:__ `undefined` (None)
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    condition : ConditionStringValueDef
        
    field : AnyOf([string, RepeatRef])
        __Required.__ Name of the field from which to pull a data
        value.
        __Note:__ `field` is not required if `aggregate` is `count`.
    legend : AnyOf([Legend, null])
        
    scale : Scale
        
    sort : AnyOf([SortField, AnyOf([string, string, null])])
        Sort order for a field with discrete domain.
        This can be `"ascending"`, `"descending"`, `null`, or a [sort
        field definition object](sort.html#sort-field) for sorting by
        an aggregate calculation of a specified sort field.
        __Note:__ For fields with continuous domain, please use
        `"scale": {"reverse": true}` to flip the scale instead.
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
        __Default value:__ `undefined` (None)
    type : string
        The encoded field's type of measurement. This can be either a
        full type
        name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and
        `"nominal"`)
        or an initial character of the type name (`"Q"`, `"T"`, `"O"`,
        `"N"`).
        This property is case-insensitive.
    """
    _additional_traits = False
    _required_traits = ['type']
    _trait_name_map = {}
    aggregate = jst.JSONAnyOf([AggregateOp(), BOXPLOT()], help='Aggregation function for the field (e.g., `mean`, `sum`, [...]')
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    condition = jst.JSONInstance(_localname('ConditionStringValueDef'))
    field = jst.JSONAnyOf([jst.JSONString(), jst.JSONInstance(_localname('RepeatRef'))])
    legend = jst.JSONAnyOf([jst.JSONInstance(_localname('Legend')), jst.JSONNull()])
    scale = jst.JSONInstance(_localname('Scale'))
    sort = jst.JSONAnyOf([jst.JSONInstance(_localname('SortField')), jst.JSONAnyOf([jst.JSONEnum(['ascending']), jst.JSONEnum(['descending']), jst.JSONNull()])], help='Sort order for a field with discrete domain. This can be [...]')
    timeUnit = TimeUnit()
    type = Type(help='Constants and utilities for data type Data type based on level [...]')

    def __init__(self, aggregate=jst.undefined, bin=jst.undefined, condition=jst.undefined, field=jst.undefined, legend=jst.undefined, scale=jst.undefined, sort=jst.undefined, timeUnit=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, bin=bin, condition=condition, field=field, legend=legend, scale=scale, sort=sort, timeUnit=timeUnit, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ConditionalStringLegendFieldDef, self).__init__(**kwargs)


class ConditionalStringLegendValueDef(jst.JSONHasTraits):
    """ConditionalStringLegendValueDef class

    A ValueDef with ConditionValueDef | FieldDef
    {
       condition: {field: ...} | {value: ...},
       value: ...,
    }

    Attributes
    ----------
    condition : AnyOf([ConditionLegendFieldDef, ConditionStringValueDef])
        
    value : string
        A constant value in visual domain.
    """
    _additional_traits = False
    _required_traits = ['value']
    _trait_name_map = {}
    condition = jst.JSONAnyOf([jst.JSONInstance(_localname('ConditionLegendFieldDef')), jst.JSONInstance(_localname('ConditionStringValueDef'))])
    value = jst.JSONString(help='A constant value in visual domain.')

    def __init__(self, condition=jst.undefined, value=jst.undefined, **kwargs):
        kwds = dict(condition=condition, value=value)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ConditionalStringLegendValueDef, self).__init__(**kwargs)


class ConditionalTextFieldDef(jst.JSONHasTraits):
    """ConditionalTextFieldDef class

    A FieldDef with ConditionValueDef
    {
       condition: {value: ...},
       field: ...,
       ...
    }

    Attributes
    ----------
    aggregate : AnyOf([string, string])
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        __Default value:__ `undefined` (None)
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    condition : ConditionTextValueDef
        
    field : AnyOf([string, RepeatRef])
        __Required.__ Name of the field from which to pull a data
        value.
        __Note:__ `field` is not required if `aggregate` is `count`.
    format : string
        The formatting pattern for text value. If not defined, this
        will be determined automatically.
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
        __Default value:__ `undefined` (None)
    type : string
        The encoded field's type of measurement. This can be either a
        full type
        name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and
        `"nominal"`)
        or an initial character of the type name (`"Q"`, `"T"`, `"O"`,
        `"N"`).
        This property is case-insensitive.
    """
    _additional_traits = False
    _required_traits = ['type']
    _trait_name_map = {}
    aggregate = jst.JSONAnyOf([AggregateOp(), BOXPLOT()], help='Aggregation function for the field (e.g., `mean`, `sum`, [...]')
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    condition = jst.JSONInstance(_localname('ConditionTextValueDef'))
    field = jst.JSONAnyOf([jst.JSONString(), jst.JSONInstance(_localname('RepeatRef'))])
    format = jst.JSONString(help='The formatting pattern for text value. If not defined, this will [...]')
    timeUnit = TimeUnit()
    type = Type(help='Constants and utilities for data type Data type based on level [...]')

    def __init__(self, aggregate=jst.undefined, bin=jst.undefined, condition=jst.undefined, field=jst.undefined, format=jst.undefined, timeUnit=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, bin=bin, condition=condition, field=field, format=format, timeUnit=timeUnit, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ConditionalTextFieldDef, self).__init__(**kwargs)


class ConditionalTextValueDef(jst.JSONHasTraits):
    """ConditionalTextValueDef class

    A ValueDef with ConditionValueDef | FieldDef
    {
       condition: {field: ...} | {value: ...},
       value: ...,
    }

    Attributes
    ----------
    condition : AnyOf([ConditionTextFieldDef, ConditionTextValueDef])
        
    value : ['string', 'number', 'boolean']
        A constant value in visual domain.
    """
    _additional_traits = False
    _required_traits = ['value']
    _trait_name_map = {}
    condition = jst.JSONAnyOf([jst.JSONInstance(_localname('ConditionTextFieldDef')), jst.JSONInstance(_localname('ConditionTextValueDef'))])
    value = jst.JSONUnion([jst.JSONString(), jst.JSONNumber(), jst.JSONBoolean()], help='A constant value in visual domain.')

    def __init__(self, condition=jst.undefined, value=jst.undefined, **kwargs):
        kwds = dict(condition=condition, value=value)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ConditionalTextValueDef, self).__init__(**kwargs)


class Config(jst.JSONHasTraits):
    """Config class

    

    Attributes
    ----------
    area : MarkConfig
        Area-Specific Config
    autoResize : boolean
        Resize is a boolean indicating if autosize layout should be
        re-calculated on every update.
        __Default value__: `false`
    axis : AxisConfig
        Generic axis config.
    axisBand : VgAxisConfig
        Specific axis config for axes with "band" scales.
    axisBottom : VgAxisConfig
        Specific axis config for x-axis along the bottom edge of the
        chart.
    axisLeft : VgAxisConfig
        Specific axis config for y-axis along the left edge of the
        chart.
    axisRight : VgAxisConfig
        Specific axis config for y-axis along the right edge of the
        chart.
    axisTop : VgAxisConfig
        Specific axis config for x-axis along the top edge of the
        chart.
    axisX : VgAxisConfig
        X-axis specific config.
    axisY : VgAxisConfig
        Y-axis specific config.
    background : string
        CSS color property to use as the background of visualization.
        __Default value:__ none (transparent)
    bar : BarConfig
        Bar-Specific Config
    cell : CellConfig
        Cell Config
    circle : MarkConfig
        Circle-Specific Config
    countTitle : string
        Default axis and legend title for count fields.
        __Default value:__ `'Number of Records'`.
    invalidValues : string
        Defines how Vega-Lite should handle invalid values (`null` and
        `NaN`).
        - If set to `"filter"` (default), all data items with null
          values are filtered.
        - If `null`, all data items are included. In this case,
          invalid values will be interpreted as zeroes.
    legend : LegendConfig
        Legend Config
    line : MarkConfig
        Line-Specific Config
    mark : MarkConfig
        Mark Config
    numberFormat : string
        D3 Number format for axis labels and text tables. For example
        "s" for SI units.(in the form of [D3 number format
        pattern](https://github.com/mbostock/d3/wiki/Formatting)).
        __Default value:__ `"s"` (except for text marks that encode a
        count field, the default value is `"d"`).
    padding : AnyOf([number, Mapping])
        The default visualization padding, in pixels, from the edge of
        the visualization canvas to the data rectangle.  If a number,
        specifies padding for all sides.
        If an object, the value should have the format `{"left": 5,
        "top": 5, "right": 5, "bottom": 5}` to specify padding for
        each side of the visualization.
        __Default value__: `5`
    point : MarkConfig
        Point-Specific Config
    range : Mapping
        Scale range config, or properties defining named range arrays
        that can be used within scale range definitions
        (such as `{"type": "ordinal", "range": "category"}`).
        For default range that Vega-Lite adopts from Vega, see
        https://github.com/vega/vega-parser#scale-range-properties.
    rect : MarkConfig
        Rect-Specific Config
    rule : MarkConfig
        Rule-Specific Config
    scale : ScaleConfig
        Scale Config
    selection : SelectionConfig
        Selection Config
    square : MarkConfig
        Square-Specific Config
    stack : string
        Default stack offset for stackable mark.
    text : TextConfig
        Text-Specific Config
    tick : TickConfig
        Tick-Specific Config
    timeFormat : string
        Default datetime format for axis and legend labels. The format
        can be set directly on each axis and legend. [D3 time format
        pattern](https://github.com/mbostock/d3/wiki/Time-
        Formatting)).
        __Default value:__ `'%b %d, %Y'`.
    title : VgTitleConfig
        Title Config
    """
    _additional_traits = True
    _required_traits = []
    _trait_name_map = {}
    area = jst.JSONInstance(_localname('MarkConfig'), help='Area-Specific Config')
    autoResize = jst.JSONBoolean(help='Resize is a boolean indicating if autosize layout should be re- [...]')
    axis = jst.JSONInstance(_localname('AxisConfig'), help='Generic axis config.')
    axisBand = jst.JSONInstance(_localname('VgAxisConfig'), help='Specific axis config for axes with "band" scales.')
    axisBottom = jst.JSONInstance(_localname('VgAxisConfig'), help='Specific axis config for x-axis along the bottom edge of the chart.')
    axisLeft = jst.JSONInstance(_localname('VgAxisConfig'), help='Specific axis config for y-axis along the left edge of the chart.')
    axisRight = jst.JSONInstance(_localname('VgAxisConfig'), help='Specific axis config for y-axis along the right edge of the chart.')
    axisTop = jst.JSONInstance(_localname('VgAxisConfig'), help='Specific axis config for x-axis along the top edge of the chart.')
    axisX = jst.JSONInstance(_localname('VgAxisConfig'), help='X-axis specific config.')
    axisY = jst.JSONInstance(_localname('VgAxisConfig'), help='Y-axis specific config.')
    background = jst.JSONString(help='CSS color property to use as the background of visualization. [...]')
    bar = jst.JSONInstance(_localname('BarConfig'), help='Bar-Specific Config')
    cell = jst.JSONInstance(_localname('CellConfig'), help='Cell Config')
    circle = jst.JSONInstance(_localname('MarkConfig'), help='Circle-Specific Config')
    countTitle = jst.JSONString(help='Default axis and legend title for count fields. __Default [...]')
    invalidValues = jst.JSONEnum(['filter'], help='Defines how Vega-Lite should handle invalid values (`null` and [...]')
    legend = jst.JSONInstance(_localname('LegendConfig'), help='Legend Config')
    line = jst.JSONInstance(_localname('MarkConfig'), help='Line-Specific Config')
    mark = jst.JSONInstance(_localname('MarkConfig'), help='Mark Config')
    numberFormat = jst.JSONString(help='D3 Number format for axis labels and text tables. For example [...]')
    padding = jst.JSONAnyOf([jst.JSONNumber(), jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'right': jst.JSONNumber(), 'bottom': jst.JSONNumber(), '_required_traits': [], 'top': jst.JSONNumber(), '_additional_traits': False, 'left': jst.JSONNumber()}))])
    point = jst.JSONInstance(_localname('MarkConfig'), help='Point-Specific Config')
    range = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': [jst.JSONAnyOf([jst.JSONArray(jst.JSONUnion([jst.JSONNumber(), jst.JSONString()])), jst.JSONInstance(_localname('VgRangeScheme')), jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'step': jst.JSONNumber(), '_additional_traits': False, '_required_traits': ['step']}))])], '_required_traits': []}), help='Scale range config, or properties defining named range arrays [...]')
    rect = jst.JSONInstance(_localname('MarkConfig'), help='Rect-Specific Config')
    rule = jst.JSONInstance(_localname('MarkConfig'), help='Rule-Specific Config')
    scale = jst.JSONInstance(_localname('ScaleConfig'), help='Scale Config')
    selection = jst.JSONInstance(_localname('SelectionConfig'), help='Selection Config')
    square = jst.JSONInstance(_localname('MarkConfig'), help='Square-Specific Config')
    stack = StackOffset()
    text = jst.JSONInstance(_localname('TextConfig'), help='Text-Specific Config')
    tick = jst.JSONInstance(_localname('TickConfig'), help='Tick-Specific Config')
    timeFormat = jst.JSONString(help='Default datetime format for axis and legend labels. The format [...]')
    title = jst.JSONInstance(_localname('VgTitleConfig'), help='Title Config')

    def __init__(self, area=jst.undefined, autoResize=jst.undefined, axis=jst.undefined, axisBand=jst.undefined, axisBottom=jst.undefined, axisLeft=jst.undefined, axisRight=jst.undefined, axisTop=jst.undefined, axisX=jst.undefined, axisY=jst.undefined, background=jst.undefined, bar=jst.undefined, cell=jst.undefined, circle=jst.undefined, countTitle=jst.undefined, invalidValues=jst.undefined, legend=jst.undefined, line=jst.undefined, mark=jst.undefined, numberFormat=jst.undefined, padding=jst.undefined, point=jst.undefined, range=jst.undefined, rect=jst.undefined, rule=jst.undefined, scale=jst.undefined, selection=jst.undefined, square=jst.undefined, stack=jst.undefined, text=jst.undefined, tick=jst.undefined, timeFormat=jst.undefined, title=jst.undefined, **kwargs):
        kwds = dict(area=area, autoResize=autoResize, axis=axis, axisBand=axisBand, axisBottom=axisBottom, axisLeft=axisLeft, axisRight=axisRight, axisTop=axisTop, axisX=axisX, axisY=axisY, background=background, bar=bar, cell=cell, circle=circle, countTitle=countTitle, invalidValues=invalidValues, legend=legend, line=line, mark=mark, numberFormat=numberFormat, padding=padding, point=point, range=range, rect=rect, rule=rule, scale=scale, selection=selection, square=square, stack=stack, text=text, tick=tick, timeFormat=timeFormat, title=title)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Config, self).__init__(**kwargs)


class DataFormat(jst.JSONHasTraits):
    """DataFormat class

    

    Attributes
    ----------
    feature : string
        The name of the TopoJSON object set to convert to a GeoJSON
        feature collection.
        For example, in a map of the world, there may be an object set
        named `"countries"`.
        Using the feature property, we can extract this set and
        generate a GeoJSON feature object for each country.
    mesh : string
        The name of the TopoJSON object set to convert to mesh.
        Similar to the `feature` option, `mesh` extracts a named
        TopoJSON object set.
          Unlike the `feature` option, the corresponding geo data is
        returned as a single, unified mesh instance, not as individual
        GeoJSON features.
        Extracting a mesh is useful for more efficiently drawing
        borders or other geographic elements that you do not need to
        associate with specific regions such as individual countries,
        states or counties.
    parse : AnyOf([string, Mapping])
        If set to auto (the default), perform automatic type inference
        to determine the desired data types.
        Alternatively, a parsing directive object can be provided for
        explicit data types. Each property of the object corresponds
        to a field name, and the value to the desired data type (one
        of `"number"`, `"boolean"` or `"date"`).
        For example, `"parse": {"modified_on": "date"}` parses the
        `modified_on` field in each input record a Date value.
        For `"date"`, we parse data based using Javascript's
        [`Date.parse()`](https://developer.mozilla.org/en-
        US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).
        For Specific date formats can be provided (e.g., `{foo:
        'date:"%m%d%Y"'}`), using the [d3-time-format
        syntax](https://github.com/d3/d3-time-format#locale_format).
        UTC date format parsing is supported similarly (e.g., `{foo:
        'utc:"%m%d%Y"'}`). See more about [UTC
        time](timeunit.html#utc)
    property : string
        The JSON property containing the desired data.
        This parameter can be used when the loaded JSON file may have
        surrounding structure or meta-data.
        For example `"property": "values.features"` is equivalent to
        retrieving `json.values.features`
        from the loaded JSON object.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    feature = jst.JSONString(help='The name of the TopoJSON object set to convert to a GeoJSON [...]')
    mesh = jst.JSONString(help='The name of the TopoJSON object set to convert to mesh. Similar [...]')
    parse = jst.JSONAnyOf([jst.JSONEnum(['auto']), jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': True, '_required_traits': []}))], help='If set to auto (the default), perform automatic type inference [...]')
    property = jst.JSONString(help='The JSON property containing the desired data. This parameter [...]')

    def __init__(self, feature=jst.undefined, mesh=jst.undefined, parse=jst.undefined, property=jst.undefined, **kwargs):
        kwds = dict(feature=feature, mesh=mesh, parse=parse, property=property)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(DataFormat, self).__init__(**kwargs)


class DataUrlFormat(jst.JSONHasTraits):
    """DataUrlFormat class

    

    Attributes
    ----------
    feature : string
        The name of the TopoJSON object set to convert to a GeoJSON
        feature collection.
        For example, in a map of the world, there may be an object set
        named `"countries"`.
        Using the feature property, we can extract this set and
        generate a GeoJSON feature object for each country.
    mesh : string
        The name of the TopoJSON object set to convert to mesh.
        Similar to the `feature` option, `mesh` extracts a named
        TopoJSON object set.
          Unlike the `feature` option, the corresponding geo data is
        returned as a single, unified mesh instance, not as individual
        GeoJSON features.
        Extracting a mesh is useful for more efficiently drawing
        borders or other geographic elements that you do not need to
        associate with specific regions such as individual countries,
        states or counties.
    parse : AnyOf([string, Mapping])
        If set to auto (the default), perform automatic type inference
        to determine the desired data types.
        Alternatively, a parsing directive object can be provided for
        explicit data types. Each property of the object corresponds
        to a field name, and the value to the desired data type (one
        of `"number"`, `"boolean"` or `"date"`).
        For example, `"parse": {"modified_on": "date"}` parses the
        `modified_on` field in each input record a Date value.
        For `"date"`, we parse data based using Javascript's
        [`Date.parse()`](https://developer.mozilla.org/en-
        US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).
        For Specific date formats can be provided (e.g., `{foo:
        'date:"%m%d%Y"'}`), using the [d3-time-format
        syntax](https://github.com/d3/d3-time-format#locale_format).
        UTC date format parsing is supported similarly (e.g., `{foo:
        'utc:"%m%d%Y"'}`). See more about [UTC
        time](timeunit.html#utc)
    property : string
        The JSON property containing the desired data.
        This parameter can be used when the loaded JSON file may have
        surrounding structure or meta-data.
        For example `"property": "values.features"` is equivalent to
        retrieving `json.values.features`
        from the loaded JSON object.
    type : string
        Type of input data: `"json"`, `"csv"`, `"tsv"`.
        The default format type is determined by the extension of the
        file URL.
        If no extension is detected, `"json"` will be used by default.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    feature = jst.JSONString(help='The name of the TopoJSON object set to convert to a GeoJSON [...]')
    mesh = jst.JSONString(help='The name of the TopoJSON object set to convert to mesh. Similar [...]')
    parse = jst.JSONAnyOf([jst.JSONEnum(['auto']), jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': True, '_required_traits': []}))], help='If set to auto (the default), perform automatic type inference [...]')
    property = jst.JSONString(help='The JSON property containing the desired data. This parameter [...]')
    type = DataFormatType()

    def __init__(self, feature=jst.undefined, mesh=jst.undefined, parse=jst.undefined, property=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(feature=feature, mesh=mesh, parse=parse, property=property, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(DataUrlFormat, self).__init__(**kwargs)


class DateTime(jst.JSONHasTraits):
    """DateTime class

    Object for defining datetime in Vega-Lite Filter.
    If both month and quarter are provided, month has higher
    precedence.
    `day` cannot be combined with other date.
    We accept string for month and day names.

    Attributes
    ----------
    date : number
        Integer value representing the date from 1-31.
    day : AnyOf([number, string])
        Value representing the day of a week.  This can be one of: (1)
        integer value -- `1` represents Monday; (2) case-insensitive
        day name (e.g., `"Monday"`);  (3) case-insensitive,
        3-character short day name (e.g., `"Mon"`).   <br/>
        **Warning:** A DateTime definition object with `day`** should
        not be combined with `year`, `quarter`, `month`, or `date`.
    hours : number
        Integer value representing the hour of a day from 0-23.
    milliseconds : number
        Integer value representing the millisecond segment of time.
    minutes : number
        Integer value representing the minute segment of time from
        0-59.
    month : AnyOf([number, string])
        One of: (1) integer value representing the month from
        `1`-`12`. `1` represents January;  (2) case-insensitive month
        name (e.g., `"January"`);  (3) case-insensitive, 3-character
        short month name (e.g., `"Jan"`).
    quarter : number
        Integer value representing the quarter of the year (from 1-4).
    seconds : number
        Integer value representing the second segment (0-59) of a time
        value
    utc : boolean
        A boolean flag indicating if date time is in utc time. If
        false, the date time is in local time
    year : number
        Integer value representing the year.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    date = jst.JSONNumber(help='Integer value representing the date from 1-31.', maximum=31, minimum=1)
    day = jst.JSONAnyOf([jst.JSONNumber(maximum=7, minimum=1), jst.JSONString()], help='Value representing the day of a week. This can be one of: (1) [...]')
    hours = jst.JSONNumber(help='Integer value representing the hour of a day from 0-23.', maximum=23, minimum=0)
    milliseconds = jst.JSONNumber(help='Integer value representing the millisecond segment of time.', maximum=999, minimum=0)
    minutes = jst.JSONNumber(help='Integer value representing the minute segment of time from 0-59.', maximum=59, minimum=0)
    month = jst.JSONAnyOf([jst.JSONNumber(maximum=12, minimum=1), jst.JSONString()], help='One of: (1) integer value representing the month from `1`-`12`. [...]')
    quarter = jst.JSONNumber(help='Integer value representing the quarter of the year (from 1-4).', maximum=4, minimum=1)
    seconds = jst.JSONNumber(help='Integer value representing the second segment (0-59) of a time value', maximum=59, minimum=0)
    utc = jst.JSONBoolean(help='A boolean flag indicating if date time is in utc time. If false, [...]')
    year = jst.JSONNumber(help='Integer value representing the year.')

    def __init__(self, date=jst.undefined, day=jst.undefined, hours=jst.undefined, milliseconds=jst.undefined, minutes=jst.undefined, month=jst.undefined, quarter=jst.undefined, seconds=jst.undefined, utc=jst.undefined, year=jst.undefined, **kwargs):
        kwds = dict(date=date, day=day, hours=hours, milliseconds=milliseconds, minutes=minutes, month=month, quarter=quarter, seconds=seconds, utc=utc, year=year)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(DateTime, self).__init__(**kwargs)


class Encoding(jst.JSONHasTraits):
    """Encoding class

    

    Attributes
    ----------
    color : ConditionalStringLegendDef
        Color of the marks – either fill or stroke color based on mark
        type.
        (By default, fill color for `area`, `bar`, `tick`, `text`,
        `circle`, and `square` /
        stroke color for `line` and `point`.)
    detail : AnyOf([FieldDef, Array(FieldDef)])
        Additional levels of detail for grouping data in aggregate
        views and
        in line and area marks without mapping data to a specific
        visual channel.
    opacity : ConditionalNumberLegendDef
        Opacity of the marks – either can be a value or a range.
    order : AnyOf([OrderFieldDef, Array(OrderFieldDef)])
        stack order for stacked marks or order of data points in line
        marks.
    shape : ConditionalStringLegendDef
        The symbol's shape (only for `point` marks). The supported
        values are
        `"circle"` (default), `"square"`, `"cross"`, `"diamond"`,
        `"triangle-up"`,
        or `"triangle-down"`, or else a custom SVG path string.
    size : ConditionalNumberLegendDef
        Size of the mark.
        - For `point`, `square` and `circle`
        – the symbol size, or pixel area of the mark.
        - For `bar` and `tick` – the bar and tick's size.
        - For `text` – the text's font size.
        - Size is currently unsupported for `line` and `area`.
    text : ConditionalTextDef
        Text of the `text` mark.
    tooltip : ConditionalTextDef
        The tooltip text to show upon mouse hover.
    x : AnyOf([PositionFieldDef, NumberValueDef])
        X coordinates for `point`, `circle`, `square`,
        `line`, `rule`, `text`, and `tick`
        (or to width and height for `bar` and `area` marks).
    x2 : AnyOf([FieldDef, NumberValueDef])
        X2 coordinates for ranged `bar`, `rule`, `area`.
    y : AnyOf([PositionFieldDef, NumberValueDef])
        Y coordinates for `point`, `circle`, `square`,
        `line`, `rule`, `text`, and `tick`
        (or to width and height for `bar` and `area` marks).
    y2 : AnyOf([FieldDef, NumberValueDef])
        Y2 coordinates for ranged `bar`, `rule`, `area`.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    color = jst.JSONInstance(_localname('ConditionalStringLegendDef'), help='Color of the marks – either fill or stroke color based on mark [...]')
    detail = jst.JSONAnyOf([jst.JSONInstance(_localname('FieldDef')), jst.JSONArray(jst.JSONInstance(_localname('FieldDef')))], help='Additional levels of detail for grouping data in aggregate views [...]')
    opacity = jst.JSONInstance(_localname('ConditionalNumberLegendDef'), help='Opacity of the marks – either can be a value or a range.')
    order = jst.JSONAnyOf([jst.JSONInstance(_localname('OrderFieldDef')), jst.JSONArray(jst.JSONInstance(_localname('OrderFieldDef')))], help='stack order for stacked marks or order of data points in line marks.')
    shape = jst.JSONInstance(_localname('ConditionalStringLegendDef'), help="The symbol's shape (only for `point` marks). The supported [...]")
    size = jst.JSONInstance(_localname('ConditionalNumberLegendDef'), help='Size of the mark. - For `point`, `square` and `circle` – the [...]')
    text = jst.JSONInstance(_localname('ConditionalTextDef'), help='Text of the `text` mark.')
    tooltip = jst.JSONInstance(_localname('ConditionalTextDef'), help='The tooltip text to show upon mouse hover.')
    x = jst.JSONAnyOf([jst.JSONInstance(_localname('PositionFieldDef')), jst.JSONInstance(_localname('NumberValueDef'))], help='X coordinates for `point`, `circle`, `square`, `line`, `rule`, [...]')
    x2 = jst.JSONAnyOf([jst.JSONInstance(_localname('FieldDef')), jst.JSONInstance(_localname('NumberValueDef'))], help='X2 coordinates for ranged `bar`, `rule`, `area`.')
    y = jst.JSONAnyOf([jst.JSONInstance(_localname('PositionFieldDef')), jst.JSONInstance(_localname('NumberValueDef'))], help='Y coordinates for `point`, `circle`, `square`, `line`, `rule`, [...]')
    y2 = jst.JSONAnyOf([jst.JSONInstance(_localname('FieldDef')), jst.JSONInstance(_localname('NumberValueDef'))], help='Y2 coordinates for ranged `bar`, `rule`, `area`.')

    def __init__(self, color=jst.undefined, detail=jst.undefined, opacity=jst.undefined, order=jst.undefined, shape=jst.undefined, size=jst.undefined, text=jst.undefined, tooltip=jst.undefined, x=jst.undefined, x2=jst.undefined, y=jst.undefined, y2=jst.undefined, **kwargs):
        kwds = dict(color=color, detail=detail, opacity=opacity, order=order, shape=shape, size=size, text=text, tooltip=tooltip, x=x, x2=x2, y=y, y2=y2)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Encoding, self).__init__(**kwargs)


class EncodingWithFacet(jst.JSONHasTraits):
    """EncodingWithFacet class

    

    Attributes
    ----------
    color : ConditionalStringLegendDef
        Color of the marks – either fill or stroke color based on mark
        type.
        (By default, fill color for `area`, `bar`, `tick`, `text`,
        `circle`, and `square` /
        stroke color for `line` and `point`.)
    column : FacetFieldDef
        Horizontal facets for trellis plots.
    detail : AnyOf([FieldDef, Array(FieldDef)])
        Additional levels of detail for grouping data in aggregate
        views and
        in line and area marks without mapping data to a specific
        visual channel.
    opacity : ConditionalNumberLegendDef
        Opacity of the marks – either can be a value or a range.
    order : AnyOf([OrderFieldDef, Array(OrderFieldDef)])
        stack order for stacked marks or order of data points in line
        marks.
    row : FacetFieldDef
        Vertical facets for trellis plots.
    shape : ConditionalStringLegendDef
        The symbol's shape (only for `point` marks). The supported
        values are
        `"circle"` (default), `"square"`, `"cross"`, `"diamond"`,
        `"triangle-up"`,
        or `"triangle-down"`, or else a custom SVG path string.
    size : ConditionalNumberLegendDef
        Size of the mark.
        - For `point`, `square` and `circle`
        – the symbol size, or pixel area of the mark.
        - For `bar` and `tick` – the bar and tick's size.
        - For `text` – the text's font size.
        - Size is currently unsupported for `line` and `area`.
    text : ConditionalTextDef
        Text of the `text` mark.
    tooltip : ConditionalTextDef
        The tooltip text to show upon mouse hover.
    x : AnyOf([PositionFieldDef, NumberValueDef])
        X coordinates for `point`, `circle`, `square`,
        `line`, `rule`, `text`, and `tick`
        (or to width and height for `bar` and `area` marks).
    x2 : AnyOf([FieldDef, NumberValueDef])
        X2 coordinates for ranged `bar`, `rule`, `area`.
    y : AnyOf([PositionFieldDef, NumberValueDef])
        Y coordinates for `point`, `circle`, `square`,
        `line`, `rule`, `text`, and `tick`
        (or to width and height for `bar` and `area` marks).
    y2 : AnyOf([FieldDef, NumberValueDef])
        Y2 coordinates for ranged `bar`, `rule`, `area`.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    color = jst.JSONInstance(_localname('ConditionalStringLegendDef'), help='Color of the marks – either fill or stroke color based on mark [...]')
    column = jst.JSONInstance(_localname('FacetFieldDef'), help='Horizontal facets for trellis plots.')
    detail = jst.JSONAnyOf([jst.JSONInstance(_localname('FieldDef')), jst.JSONArray(jst.JSONInstance(_localname('FieldDef')))], help='Additional levels of detail for grouping data in aggregate views [...]')
    opacity = jst.JSONInstance(_localname('ConditionalNumberLegendDef'), help='Opacity of the marks – either can be a value or a range.')
    order = jst.JSONAnyOf([jst.JSONInstance(_localname('OrderFieldDef')), jst.JSONArray(jst.JSONInstance(_localname('OrderFieldDef')))], help='stack order for stacked marks or order of data points in line marks.')
    row = jst.JSONInstance(_localname('FacetFieldDef'), help='Vertical facets for trellis plots.')
    shape = jst.JSONInstance(_localname('ConditionalStringLegendDef'), help="The symbol's shape (only for `point` marks). The supported [...]")
    size = jst.JSONInstance(_localname('ConditionalNumberLegendDef'), help='Size of the mark. - For `point`, `square` and `circle` – the [...]')
    text = jst.JSONInstance(_localname('ConditionalTextDef'), help='Text of the `text` mark.')
    tooltip = jst.JSONInstance(_localname('ConditionalTextDef'), help='The tooltip text to show upon mouse hover.')
    x = jst.JSONAnyOf([jst.JSONInstance(_localname('PositionFieldDef')), jst.JSONInstance(_localname('NumberValueDef'))], help='X coordinates for `point`, `circle`, `square`, `line`, `rule`, [...]')
    x2 = jst.JSONAnyOf([jst.JSONInstance(_localname('FieldDef')), jst.JSONInstance(_localname('NumberValueDef'))], help='X2 coordinates for ranged `bar`, `rule`, `area`.')
    y = jst.JSONAnyOf([jst.JSONInstance(_localname('PositionFieldDef')), jst.JSONInstance(_localname('NumberValueDef'))], help='Y coordinates for `point`, `circle`, `square`, `line`, `rule`, [...]')
    y2 = jst.JSONAnyOf([jst.JSONInstance(_localname('FieldDef')), jst.JSONInstance(_localname('NumberValueDef'))], help='Y2 coordinates for ranged `bar`, `rule`, `area`.')

    def __init__(self, color=jst.undefined, column=jst.undefined, detail=jst.undefined, opacity=jst.undefined, order=jst.undefined, row=jst.undefined, shape=jst.undefined, size=jst.undefined, text=jst.undefined, tooltip=jst.undefined, x=jst.undefined, x2=jst.undefined, y=jst.undefined, y2=jst.undefined, **kwargs):
        kwds = dict(color=color, column=column, detail=detail, opacity=opacity, order=order, row=row, shape=shape, size=size, text=text, tooltip=tooltip, x=x, x2=x2, y=y, y2=y2)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(EncodingWithFacet, self).__init__(**kwargs)


class EqualFilter(jst.JSONHasTraits):
    """EqualFilter class

    

    Attributes
    ----------
    equal : AnyOf([string, number, boolean, DateTime])
        The value that the field should be equal to.
    field : string
        Field to be filtered.
    timeUnit : string
        Time unit for the field to be filtered.
    """
    _additional_traits = False
    _required_traits = ['field', 'equal']
    _trait_name_map = {}
    equal = jst.JSONAnyOf([jst.JSONString(), jst.JSONNumber(), jst.JSONBoolean(), jst.JSONInstance(_localname('DateTime'))], help='The value that the field should be equal to.')
    field = jst.JSONString(help='Field to be filtered.')
    timeUnit = TimeUnit()

    def __init__(self, equal=jst.undefined, field=jst.undefined, timeUnit=jst.undefined, **kwargs):
        kwds = dict(equal=equal, field=field, timeUnit=timeUnit)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(EqualFilter, self).__init__(**kwargs)


class ExtendedScheme(jst.JSONHasTraits):
    """ExtendedScheme class

    

    Attributes
    ----------
    count : number
        
    extent : Array(number)
        
    name : string
        Color scheme that determines output color of an
        ordinal/sequential color scale.
    """
    _additional_traits = False
    _required_traits = ['name']
    _trait_name_map = {}
    count = jst.JSONNumber()
    extent = jst.JSONArray(jst.JSONNumber())
    name = jst.JSONString(help='Color scheme that determines output color of an [...]')

    def __init__(self, count=jst.undefined, extent=jst.undefined, name=jst.undefined, **kwargs):
        kwds = dict(count=count, extent=extent, name=name)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ExtendedScheme, self).__init__(**kwargs)


class Facet(jst.JSONHasTraits):
    """Facet class

    

    Attributes
    ----------
    column : FacetFieldDef
        Horizontal facets for trellis plots.
    row : FacetFieldDef
        Vertical facets for trellis plots.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    column = jst.JSONInstance(_localname('FacetFieldDef'), help='Horizontal facets for trellis plots.')
    row = jst.JSONInstance(_localname('FacetFieldDef'), help='Vertical facets for trellis plots.')

    def __init__(self, column=jst.undefined, row=jst.undefined, **kwargs):
        kwds = dict(column=column, row=row)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Facet, self).__init__(**kwargs)


class FacetFieldDef(jst.JSONHasTraits):
    """FacetFieldDef class

    

    Attributes
    ----------
    aggregate : AnyOf([string, string])
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        __Default value:__ `undefined` (None)
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    field : AnyOf([string, RepeatRef])
        __Required.__ Name of the field from which to pull a data
        value.
        __Note:__ `field` is not required if `aggregate` is `count`.
    header : Header
        
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
        __Default value:__ `undefined` (None)
    type : string
        The encoded field's type of measurement. This can be either a
        full type
        name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and
        `"nominal"`)
        or an initial character of the type name (`"Q"`, `"T"`, `"O"`,
        `"N"`).
        This property is case-insensitive.
    """
    _additional_traits = False
    _required_traits = ['type']
    _trait_name_map = {}
    aggregate = jst.JSONAnyOf([AggregateOp(), BOXPLOT()], help='Aggregation function for the field (e.g., `mean`, `sum`, [...]')
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    field = jst.JSONAnyOf([jst.JSONString(), jst.JSONInstance(_localname('RepeatRef'))])
    header = jst.JSONInstance(_localname('Header'))
    timeUnit = TimeUnit()
    type = Type(help='Constants and utilities for data type Data type based on level [...]')

    def __init__(self, aggregate=jst.undefined, bin=jst.undefined, field=jst.undefined, header=jst.undefined, timeUnit=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, bin=bin, field=field, header=header, timeUnit=timeUnit, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(FacetFieldDef, self).__init__(**kwargs)


class FacetedCompositeUnitSpecAlias(jst.JSONHasTraits):
    """FacetedCompositeUnitSpecAlias class

    

    Attributes
    ----------
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
    encoding : EncodingWithFacet
        A key-value mapping between encoding channels and definition
        of fields.
    height : number
        The height of a visualization.
        __Default value:__
        - For y-axis with a continuous (non-ordinal) scale, the
          height will be the value of
          [`config.cell.height`](config.html#cell-config).
        - For y-axis with an ordinal scale: if
          [`rangeStep`](scale.html#ordinal) is a numeric value
          (default), the height is determined by the value of
          `rangeStep` and the cardinality of the field mapped to
          y-channel.   Otherwise, if the `rangeStep` is `null`, the
          height will be the value of
          [`config.cell.height`](config.html#cell-config).
        - If no field is mapped to `x` channel, the `height` will be
          the value of `rangeStep`.
        __Note__: For plot with `row` and `column` channels, this
        represents the height of a single cell.
    mark : AnyOf([AnyOf([string, string]), CompositeMarkDef, string, MarkDef])
        A string describing the mark type (one of `"bar"`, `"circle"`,
        `"square"`, `"tick"`, `"line"`,
        `"area"`, `"point"`, `"rule"`, and `"text"`) or a [mark
        definition object](mark.html#mark-def).
    name : string
        Name of the visualization for later reference.
    selection : Mapping
        A key-value mapping between selection names and definitions.
    transform : Array(Transform)
        An array of data transformations such as filter and new field
        calculation.
    width : number
        The width of a visualization.
        __Default value:__ This will be determined by the following
        rules:
        - For x-axis with a continuous (non-ordinal) scale, the
          width will be the value of
          [`config.cell.width`](config.html#cell-config).
        - For x-axis with an ordinal scale: if
          [`rangeStep`](scale.html#ordinal) is a numeric value
          (default), the width is determined by the value of
          `rangeStep` and the cardinality of the field mapped to
          x-channel.   Otherwise, if the `rangeStep` is `null`, the
          width will be the value of
          [`config.cell.width`](config.html#cell-config).
        - If no field is mapped to `x` channel, the `width` will be
          the value of
          [`config.scale.textXRangeStep`](size.html#default-width-and-
          height) for `text` mark and the value of `rangeStep` for
          other marks.
        __Note__: For plot with `row` and `column` channels, this
        represents the width of a single cell.
    """
    _additional_traits = False
    _required_traits = ['mark', 'encoding']
    _trait_name_map = {}
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose.')
    encoding = jst.JSONInstance(_localname('EncodingWithFacet'), help='A key-value mapping between encoding channels and definition of [...]')
    height = jst.JSONNumber(help='The height of a visualization. __Default value:__ - For y-axis [...]')
    mark = jst.JSONAnyOf([jst.JSONAnyOf([BOXPLOT(), ERRORBAR()]), jst.JSONInstance(_localname('CompositeMarkDef')), Mark(help='All types of primitive marks.'), jst.JSONInstance(_localname('MarkDef'))])
    name = jst.JSONString(help='Name of the visualization for later reference.')
    selection = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': [jst.JSONInstance(_localname('SelectionDef'))], '_required_traits': []}), help='A key-value mapping between selection names and definitions.')
    transform = jst.JSONArray(jst.JSONInstance(_localname('Transform')), help='An array of data transformations such as filter and new field [...]')
    width = jst.JSONNumber(help='The width of a visualization. __Default value:__ This will be [...]')

    def __init__(self, data=jst.undefined, description=jst.undefined, encoding=jst.undefined, height=jst.undefined, mark=jst.undefined, name=jst.undefined, selection=jst.undefined, transform=jst.undefined, width=jst.undefined, **kwargs):
        kwds = dict(data=data, description=description, encoding=encoding, height=height, mark=mark, name=name, selection=selection, transform=transform, width=width)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(FacetedCompositeUnitSpecAlias, self).__init__(**kwargs)


class FacetedSpec(jst.JSONHasTraits):
    """FacetedSpec class

    

    Attributes
    ----------
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
    facet : Facet
        
    name : string
        Name of the visualization for later reference.
    resolve : ResolveMapping
        
    spec : Spec
        
    transform : Array(Transform)
        An array of data transformations such as filter and new field
        calculation.
    """
    _additional_traits = False
    _required_traits = ['facet', 'spec']
    _trait_name_map = {}
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose.')
    facet = jst.JSONInstance(_localname('Facet'))
    name = jst.JSONString(help='Name of the visualization for later reference.')
    resolve = jst.JSONInstance(_localname('ResolveMapping'))
    spec = jst.JSONInstance(_localname('Spec'))
    transform = jst.JSONArray(jst.JSONInstance(_localname('Transform')), help='An array of data transformations such as filter and new field [...]')

    def __init__(self, data=jst.undefined, description=jst.undefined, facet=jst.undefined, name=jst.undefined, resolve=jst.undefined, spec=jst.undefined, transform=jst.undefined, **kwargs):
        kwds = dict(data=data, description=description, facet=facet, name=name, resolve=resolve, spec=spec, transform=transform)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(FacetedSpec, self).__init__(**kwargs)


class FieldDef(jst.JSONHasTraits):
    """FieldDef class

    Definition object for a data field, its type and transformation of
    an encoding channel.

    Attributes
    ----------
    aggregate : AnyOf([string, string])
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        __Default value:__ `undefined` (None)
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    field : AnyOf([string, RepeatRef])
        __Required.__ Name of the field from which to pull a data
        value.
        __Note:__ `field` is not required if `aggregate` is `count`.
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
        __Default value:__ `undefined` (None)
    type : string
        The encoded field's type of measurement. This can be either a
        full type
        name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and
        `"nominal"`)
        or an initial character of the type name (`"Q"`, `"T"`, `"O"`,
        `"N"`).
        This property is case-insensitive.
    """
    _additional_traits = False
    _required_traits = ['type']
    _trait_name_map = {}
    aggregate = jst.JSONAnyOf([AggregateOp(), BOXPLOT()], help='Aggregation function for the field (e.g., `mean`, `sum`, [...]')
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    field = jst.JSONAnyOf([jst.JSONString(), jst.JSONInstance(_localname('RepeatRef'))])
    timeUnit = TimeUnit()
    type = Type(help='Constants and utilities for data type Data type based on level [...]')

    def __init__(self, aggregate=jst.undefined, bin=jst.undefined, field=jst.undefined, timeUnit=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, bin=bin, field=field, timeUnit=timeUnit, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(FieldDef, self).__init__(**kwargs)


class FieldDefBase(jst.JSONHasTraits):
    """FieldDefBase class

    

    Attributes
    ----------
    aggregate : AnyOf([string, string])
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        __Default value:__ `undefined` (None)
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    field : AnyOf([string, RepeatRef])
        __Required.__ Name of the field from which to pull a data
        value.
        __Note:__ `field` is not required if `aggregate` is `count`.
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
        __Default value:__ `undefined` (None)
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    aggregate = jst.JSONAnyOf([AggregateOp(), BOXPLOT()], help='Aggregation function for the field (e.g., `mean`, `sum`, [...]')
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    field = jst.JSONAnyOf([jst.JSONString(), jst.JSONInstance(_localname('RepeatRef'))])
    timeUnit = TimeUnit()

    def __init__(self, aggregate=jst.undefined, bin=jst.undefined, field=jst.undefined, timeUnit=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, bin=bin, field=field, timeUnit=timeUnit)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(FieldDefBase, self).__init__(**kwargs)


class FilterTransform(jst.JSONHasTraits):
    """FilterTransform class

    

    Attributes
    ----------
    filter : AnyOf([NotFilter, AndFilter, OrFilter, AnyOf([EqualFilter, RangeFilter, OneOfFilter, SelectionFilter, string])])
        A string containing the filter Vega expression. Use `datum` to
        refer to the current data object.
    """
    _additional_traits = False
    _required_traits = ['filter']
    _trait_name_map = {}
    filter = jst.JSONAnyOf([jst.JSONInstance(_localname('NotFilter')), jst.JSONInstance(_localname('AndFilter')), jst.JSONInstance(_localname('OrFilter')), jst.JSONAnyOf([jst.JSONInstance(_localname('EqualFilter')), jst.JSONInstance(_localname('RangeFilter')), jst.JSONInstance(_localname('OneOfFilter')), jst.JSONInstance(_localname('SelectionFilter')), jst.JSONString()])])

    def __init__(self, filter=jst.undefined, **kwargs):
        kwds = dict(filter=filter)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(FilterTransform, self).__init__(**kwargs)


class Guide(jst.JSONHasTraits):
    """Guide class

    

    Attributes
    ----------
    format : string
        The formatting pattern for labels. This is D3's [number format
        pattern](https://github.com/mbostock/d3/wiki/Formatting) for
        quantitative fields and D3's [time format
        pattern](https://github.com/mbostock/d3/wiki/Time-Formatting)
        for time field.
        __Default value:__  derived from
        [numberFormat](config.html#format) config for quantitative
        fields and from [timeFormat](config.html#format) config for
        temporal fields.
    title : string
        A title for the field.
        __Default value:__  derived from the field's name and
        transformation function applied e.g, "field_name",
        "SUM(field_name)", "BIN(field_name)", "YEAR(field_name)".
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    format = jst.JSONString(help="The formatting pattern for labels. This is D3's [number format [...]")
    title = jst.JSONString(help='A title for the field. __Default value:__ derived from the [...]')

    def __init__(self, format=jst.undefined, title=jst.undefined, **kwargs):
        kwds = dict(format=format, title=title)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Guide, self).__init__(**kwargs)


class GuideEncodingEntry(jst.JSONHasTraits):
    """GuideEncodingEntry class

    

    Attributes
    ----------
    align : ValueDef
        
    angle : ValueDef
        
    baseline : ValueDef
        
    clip : ValueDef
        
    cursor : ValueDef
        
    dir : ValueDef
        
    dx : ValueDef
        
    dy : ValueDef
        
    ellipsis : ValueDef
        
    endAngle : ValueDef
        
    fill : ValueDef
        
    fillOpacity : ValueDef
        
    font : ValueDef
        
    fontSize : ValueDef
        
    fontStyle : ValueDef
        
    fontWeight : ValueDef
        
    height : ValueDef
        
    innerRadius : ValueDef
        
    interpolate : ValueDef
        
    limit : ValueDef
        
    opacity : ValueDef
        
    orient : ValueDef
        
    outerRadius : ValueDef
        
    path : ValueDef
        
    radius : ValueDef
        
    shape : ValueDef
        
    size : ValueDef
        
    startAngle : ValueDef
        
    stroke : ValueDef
        
    strokeDash : ValueDef
        
    strokeDashOffset : ValueDef
        
    strokeOpacity : ValueDef
        
    strokeWidth : ValueDef
        
    tension : ValueDef
        
    text : ValueDef
        
    theta : ValueDef
        
    url : ValueDef
        
    width : ValueDef
        
    x : ValueDef
        
    x2 : ValueDef
        
    xc : ValueDef
        
    y : ValueDef
        
    y2 : ValueDef
        
    yc : ValueDef
        
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    align = jst.JSONInstance(_localname('ValueDef'))
    angle = jst.JSONInstance(_localname('ValueDef'))
    baseline = jst.JSONInstance(_localname('ValueDef'))
    clip = jst.JSONInstance(_localname('ValueDef'))
    cursor = jst.JSONInstance(_localname('ValueDef'))
    dir = jst.JSONInstance(_localname('ValueDef'))
    dx = jst.JSONInstance(_localname('ValueDef'))
    dy = jst.JSONInstance(_localname('ValueDef'))
    ellipsis = jst.JSONInstance(_localname('ValueDef'))
    endAngle = jst.JSONInstance(_localname('ValueDef'))
    fill = jst.JSONInstance(_localname('ValueDef'))
    fillOpacity = jst.JSONInstance(_localname('ValueDef'))
    font = jst.JSONInstance(_localname('ValueDef'))
    fontSize = jst.JSONInstance(_localname('ValueDef'))
    fontStyle = jst.JSONInstance(_localname('ValueDef'))
    fontWeight = jst.JSONInstance(_localname('ValueDef'))
    height = jst.JSONInstance(_localname('ValueDef'))
    innerRadius = jst.JSONInstance(_localname('ValueDef'))
    interpolate = jst.JSONInstance(_localname('ValueDef'))
    limit = jst.JSONInstance(_localname('ValueDef'))
    opacity = jst.JSONInstance(_localname('ValueDef'))
    orient = jst.JSONInstance(_localname('ValueDef'))
    outerRadius = jst.JSONInstance(_localname('ValueDef'))
    path = jst.JSONInstance(_localname('ValueDef'))
    radius = jst.JSONInstance(_localname('ValueDef'))
    shape = jst.JSONInstance(_localname('ValueDef'))
    size = jst.JSONInstance(_localname('ValueDef'))
    startAngle = jst.JSONInstance(_localname('ValueDef'))
    stroke = jst.JSONInstance(_localname('ValueDef'))
    strokeDash = jst.JSONInstance(_localname('ValueDef'))
    strokeDashOffset = jst.JSONInstance(_localname('ValueDef'))
    strokeOpacity = jst.JSONInstance(_localname('ValueDef'))
    strokeWidth = jst.JSONInstance(_localname('ValueDef'))
    tension = jst.JSONInstance(_localname('ValueDef'))
    text = jst.JSONInstance(_localname('ValueDef'))
    theta = jst.JSONInstance(_localname('ValueDef'))
    url = jst.JSONInstance(_localname('ValueDef'))
    width = jst.JSONInstance(_localname('ValueDef'))
    x = jst.JSONInstance(_localname('ValueDef'))
    x2 = jst.JSONInstance(_localname('ValueDef'))
    xc = jst.JSONInstance(_localname('ValueDef'))
    y = jst.JSONInstance(_localname('ValueDef'))
    y2 = jst.JSONInstance(_localname('ValueDef'))
    yc = jst.JSONInstance(_localname('ValueDef'))

    def __init__(self, align=jst.undefined, angle=jst.undefined, baseline=jst.undefined, clip=jst.undefined, cursor=jst.undefined, dir=jst.undefined, dx=jst.undefined, dy=jst.undefined, ellipsis=jst.undefined, endAngle=jst.undefined, fill=jst.undefined, fillOpacity=jst.undefined, font=jst.undefined, fontSize=jst.undefined, fontStyle=jst.undefined, fontWeight=jst.undefined, height=jst.undefined, innerRadius=jst.undefined, interpolate=jst.undefined, limit=jst.undefined, opacity=jst.undefined, orient=jst.undefined, outerRadius=jst.undefined, path=jst.undefined, radius=jst.undefined, shape=jst.undefined, size=jst.undefined, startAngle=jst.undefined, stroke=jst.undefined, strokeDash=jst.undefined, strokeDashOffset=jst.undefined, strokeOpacity=jst.undefined, strokeWidth=jst.undefined, tension=jst.undefined, text=jst.undefined, theta=jst.undefined, url=jst.undefined, width=jst.undefined, x=jst.undefined, x2=jst.undefined, xc=jst.undefined, y=jst.undefined, y2=jst.undefined, yc=jst.undefined, **kwargs):
        kwds = dict(align=align, angle=angle, baseline=baseline, clip=clip, cursor=cursor, dir=dir, dx=dx, dy=dy, ellipsis=ellipsis, endAngle=endAngle, fill=fill, fillOpacity=fillOpacity, font=font, fontSize=fontSize, fontStyle=fontStyle, fontWeight=fontWeight, height=height, innerRadius=innerRadius, interpolate=interpolate, limit=limit, opacity=opacity, orient=orient, outerRadius=outerRadius, path=path, radius=radius, shape=shape, size=size, startAngle=startAngle, stroke=stroke, strokeDash=strokeDash, strokeDashOffset=strokeDashOffset, strokeOpacity=strokeOpacity, strokeWidth=strokeWidth, tension=tension, text=text, theta=theta, url=url, width=width, x=x, x2=x2, xc=xc, y=y, y2=y2, yc=yc)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(GuideEncodingEntry, self).__init__(**kwargs)


class HConcatSpec(jst.JSONHasTraits):
    """HConcatSpec class

    

    Attributes
    ----------
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
    hconcat : Array(Spec)
        
    name : string
        Name of the visualization for later reference.
    resolve : ResolveMapping
        
    transform : Array(Transform)
        An array of data transformations such as filter and new field
        calculation.
    """
    _additional_traits = False
    _required_traits = ['hconcat']
    _trait_name_map = {}
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose.')
    hconcat = jst.JSONArray(jst.JSONInstance(_localname('Spec')))
    name = jst.JSONString(help='Name of the visualization for later reference.')
    resolve = jst.JSONInstance(_localname('ResolveMapping'))
    transform = jst.JSONArray(jst.JSONInstance(_localname('Transform')), help='An array of data transformations such as filter and new field [...]')

    def __init__(self, data=jst.undefined, description=jst.undefined, hconcat=jst.undefined, name=jst.undefined, resolve=jst.undefined, transform=jst.undefined, **kwargs):
        kwds = dict(data=data, description=description, hconcat=hconcat, name=name, resolve=resolve, transform=transform)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(HConcatSpec, self).__init__(**kwargs)


class Header(jst.JSONHasTraits):
    """Header class

    Headers of row / column channels for faceted plots.

    Attributes
    ----------
    format : string
        The formatting pattern for axis labels. This is D3's [number
        format
        pattern](https://github.com/mbostock/d3/wiki/Formatting) for
        quantitative axis and D3's [time format
        pattern](https://github.com/mbostock/d3/wiki/Time-Formatting)
        for time axis.
        __Default value:__  derived from
        [numberFormat](config.html#format) config for quantitative
        axis and from [timeFormat](config.html#format) config for time
        axis.
    sort : AnyOf([string, string, null])
        
    title : string
        A title for the axis. Shows field name and its function by
        default.
        __Default value:__  derived from the field's name and
        transformation function applied e.g, "field_name",
        "SUM(field_name)", "BIN(field_name)", "YEAR(field_name)".
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    format = jst.JSONString(help="The formatting pattern for axis labels. This is D3's [number [...]")
    sort = jst.JSONAnyOf([jst.JSONEnum(['ascending']), jst.JSONEnum(['descending']), jst.JSONNull()])
    title = jst.JSONString(help='A title for the axis. Shows field name and its function by [...]')

    def __init__(self, format=jst.undefined, sort=jst.undefined, title=jst.undefined, **kwargs):
        kwds = dict(format=format, sort=sort, title=title)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Header, self).__init__(**kwargs)


class InlineData(jst.JSONHasTraits):
    """InlineData class

    

    Attributes
    ----------
    format : DataFormat
        Data format properties
    values : Array(any_object)
        Pass array of objects instead of a url to a file.
    """
    _additional_traits = False
    _required_traits = ['values']
    _trait_name_map = {}
    format = jst.JSONInstance(_localname('DataFormat'), help='Data format properties')
    values = jst.JSONArray(jst.JSONAny(), help='Pass array of objects instead of a url to a file.')

    def __init__(self, format=jst.undefined, values=jst.undefined, **kwargs):
        kwds = dict(format=format, values=values)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(InlineData, self).__init__(**kwargs)


class IntervalSelection(jst.JSONHasTraits):
    """IntervalSelection class

    

    Attributes
    ----------
    bind : string
        Establishes a two-way binding between the interval selection
        and the scales
        used within the same view. This allows a user to interactively
        pan and
        zoom the view.
    encodings : Array(string)
        An array of encoding channels. The corresponding data field
        values
        must match for a data tuple to fall within the selection.
    fields : Array(string)
        An array of field names whose values must match for a data
        tuple to
        fall within the selection.
    mark : BrushConfig
        Each (unbound) interval selection also adds a rectangle mark
        to depict the
        extents of the interval. The `mark` property can be used to
        customize the
        appearance of the mark.
    on : Mapping
        A Vega event stream (object or selector) that triggers the
        selection.
    resolve : string
        With layered and multi-view displays, a strategy that
        determines how
        selections' data queries are resolved when applied in a filter
        transform,
        conditional encoding rule, or scale domain. One of: "global",
        "union",
        "intersect", "union_others", or "intersect_others".
        __global__: Only one instance of the selection exists across
        all
        views. When a user interacts within a new view, any previous
        selections
        are overridden.
        __union__: Each view contains its own selection, and a data
        value is
        considered to be selected if it falls within _any_ of these
        selection
        instances.
        __intersect__: Each view contains its own selection, and a
        data value is
        considered to be selected if it falls within _all_ of these
        selection
        instances.
    translate : ['string', 'boolean']
        When truthy, allows a user to interactively move an interval
        selection
        back-and-forth. Can be `true`, `false` (to disable panning),
        or a
        [Vega event stream
        definition](https://vega.github.io/vega/docs/event-streams/)
        which must include a start and end event to trigger continuous
        panning.
        __Default value:__ `true`, which corresponds to
        `[mousedown, window:mouseup] > window:mousemove!` which
        corresponds to
        clicks and dragging within an interval selection to reposition
        it.
    type : string
        
    zoom : ['string', 'boolean']
        When truthy, allows a user to interactively resize an interval
        selection.
        Can be `true`, `false` (to disable zooming), or a [Vega event
        stream
        definition](https://vega.github.io/vega/docs/event-streams/).
        Currently,
        only `wheel` events are supported.
        __Default value:__ `true`, which corresponds to `wheel!`.
    """
    _additional_traits = False
    _required_traits = ['type']
    _trait_name_map = {}
    bind = jst.JSONEnum(['scales'], help='Establishes a two-way binding between the interval selection and [...]')
    encodings = jst.JSONArray(SingleDefChannel(), help='An array of encoding channels. The corresponding data field [...]')
    fields = jst.JSONArray(jst.JSONString(), help='An array of field names whose values must match for a data tuple [...]')
    mark = jst.JSONInstance(_localname('BrushConfig'), help='Each (unbound) interval selection also adds a rectangle mark to [...]')
    on = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': True, '_required_traits': []}), help='A Vega event stream (object or selector) that triggers the selection.')
    resolve = SelectionResolution()
    translate = jst.JSONUnion([jst.JSONString(), jst.JSONBoolean()], help='When truthy, allows a user to interactively move an interval [...]')
    type = jst.JSONEnum(['interval'])
    zoom = jst.JSONUnion([jst.JSONString(), jst.JSONBoolean()], help='When truthy, allows a user to interactively resize an interval [...]')

    def __init__(self, bind=jst.undefined, encodings=jst.undefined, fields=jst.undefined, mark=jst.undefined, on=jst.undefined, resolve=jst.undefined, translate=jst.undefined, type=jst.undefined, zoom=jst.undefined, **kwargs):
        kwds = dict(bind=bind, encodings=encodings, fields=fields, mark=mark, on=on, resolve=resolve, translate=translate, type=type, zoom=zoom)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(IntervalSelection, self).__init__(**kwargs)


class IntervalSelectionConfig(jst.JSONHasTraits):
    """IntervalSelectionConfig class

    

    Attributes
    ----------
    bind : string
        Establishes a two-way binding between the interval selection
        and the scales
        used within the same view. This allows a user to interactively
        pan and
        zoom the view.
    encodings : Array(string)
        An array of encoding channels. The corresponding data field
        values
        must match for a data tuple to fall within the selection.
    fields : Array(string)
        An array of field names whose values must match for a data
        tuple to
        fall within the selection.
    mark : BrushConfig
        Each (unbound) interval selection also adds a rectangle mark
        to depict the
        extents of the interval. The `mark` property can be used to
        customize the
        appearance of the mark.
    on : Mapping
        A Vega event stream (object or selector) that triggers the
        selection.
    resolve : string
        With layered and multi-view displays, a strategy that
        determines how
        selections' data queries are resolved when applied in a filter
        transform,
        conditional encoding rule, or scale domain. One of: "global",
        "union",
        "intersect", "union_others", or "intersect_others".
        __global__: Only one instance of the selection exists across
        all
        views. When a user interacts within a new view, any previous
        selections
        are overridden.
        __union__: Each view contains its own selection, and a data
        value is
        considered to be selected if it falls within _any_ of these
        selection
        instances.
        __intersect__: Each view contains its own selection, and a
        data value is
        considered to be selected if it falls within _all_ of these
        selection
        instances.
    translate : ['string', 'boolean']
        When truthy, allows a user to interactively move an interval
        selection
        back-and-forth. Can be `true`, `false` (to disable panning),
        or a
        [Vega event stream
        definition](https://vega.github.io/vega/docs/event-streams/)
        which must include a start and end event to trigger continuous
        panning.
        __Default value:__ `true`, which corresponds to
        `[mousedown, window:mouseup] > window:mousemove!` which
        corresponds to
        clicks and dragging within an interval selection to reposition
        it.
    zoom : ['string', 'boolean']
        When truthy, allows a user to interactively resize an interval
        selection.
        Can be `true`, `false` (to disable zooming), or a [Vega event
        stream
        definition](https://vega.github.io/vega/docs/event-streams/).
        Currently,
        only `wheel` events are supported.
        __Default value:__ `true`, which corresponds to `wheel!`.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    bind = jst.JSONEnum(['scales'], help='Establishes a two-way binding between the interval selection and [...]')
    encodings = jst.JSONArray(SingleDefChannel(), help='An array of encoding channels. The corresponding data field [...]')
    fields = jst.JSONArray(jst.JSONString(), help='An array of field names whose values must match for a data tuple [...]')
    mark = jst.JSONInstance(_localname('BrushConfig'), help='Each (unbound) interval selection also adds a rectangle mark to [...]')
    on = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': True, '_required_traits': []}), help='A Vega event stream (object or selector) that triggers the selection.')
    resolve = SelectionResolution()
    translate = jst.JSONUnion([jst.JSONString(), jst.JSONBoolean()], help='When truthy, allows a user to interactively move an interval [...]')
    zoom = jst.JSONUnion([jst.JSONString(), jst.JSONBoolean()], help='When truthy, allows a user to interactively resize an interval [...]')

    def __init__(self, bind=jst.undefined, encodings=jst.undefined, fields=jst.undefined, mark=jst.undefined, on=jst.undefined, resolve=jst.undefined, translate=jst.undefined, zoom=jst.undefined, **kwargs):
        kwds = dict(bind=bind, encodings=encodings, fields=fields, mark=mark, on=on, resolve=resolve, translate=translate, zoom=zoom)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(IntervalSelectionConfig, self).__init__(**kwargs)


class LayerSpec(jst.JSONHasTraits):
    """LayerSpec class

    

    Attributes
    ----------
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
    height : number
        The height of a visualization.
        __Default value:__
        - For y-axis with a continuous (non-ordinal) scale, the
          height will be the value of
          [`config.cell.height`](config.html#cell-config).
        - For y-axis with an ordinal scale: if
          [`rangeStep`](scale.html#ordinal) is a numeric value
          (default), the height is determined by the value of
          `rangeStep` and the cardinality of the field mapped to
          y-channel.   Otherwise, if the `rangeStep` is `null`, the
          height will be the value of
          [`config.cell.height`](config.html#cell-config).
        - If no field is mapped to `x` channel, the `height` will be
          the value of `rangeStep`.
        __Note__: For plot with `row` and `column` channels, this
        represents the height of a single cell.
    layer : Array(AnyOf([LayerSpec, CompositeUnitSpec]))
        Unit specs that will be layered.
    name : string
        Name of the visualization for later reference.
    resolve : ResolveMapping
        
    transform : Array(Transform)
        An array of data transformations such as filter and new field
        calculation.
    width : number
        The width of a visualization.
        __Default value:__ This will be determined by the following
        rules:
        - For x-axis with a continuous (non-ordinal) scale, the
          width will be the value of
          [`config.cell.width`](config.html#cell-config).
        - For x-axis with an ordinal scale: if
          [`rangeStep`](scale.html#ordinal) is a numeric value
          (default), the width is determined by the value of
          `rangeStep` and the cardinality of the field mapped to
          x-channel.   Otherwise, if the `rangeStep` is `null`, the
          width will be the value of
          [`config.cell.width`](config.html#cell-config).
        - If no field is mapped to `x` channel, the `width` will be
          the value of
          [`config.scale.textXRangeStep`](size.html#default-width-and-
          height) for `text` mark and the value of `rangeStep` for
          other marks.
        __Note__: For plot with `row` and `column` channels, this
        represents the width of a single cell.
    """
    _additional_traits = False
    _required_traits = ['layer']
    _trait_name_map = {}
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose.')
    height = jst.JSONNumber(help='The height of a visualization. __Default value:__ - For y-axis [...]')
    layer = jst.JSONArray(jst.JSONAnyOf([jst.JSONInstance(_localname('LayerSpec')), jst.JSONInstance(_localname('CompositeUnitSpec'))]), help='Unit specs that will be layered.')
    name = jst.JSONString(help='Name of the visualization for later reference.')
    resolve = jst.JSONInstance(_localname('ResolveMapping'))
    transform = jst.JSONArray(jst.JSONInstance(_localname('Transform')), help='An array of data transformations such as filter and new field [...]')
    width = jst.JSONNumber(help='The width of a visualization. __Default value:__ This will be [...]')

    def __init__(self, data=jst.undefined, description=jst.undefined, height=jst.undefined, layer=jst.undefined, name=jst.undefined, resolve=jst.undefined, transform=jst.undefined, width=jst.undefined, **kwargs):
        kwds = dict(data=data, description=description, height=height, layer=layer, name=name, resolve=resolve, transform=transform, width=width)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(LayerSpec, self).__init__(**kwargs)


class LayoutSizeMixins(jst.JSONHasTraits):
    """LayoutSizeMixins class

    

    Attributes
    ----------
    height : number
        The height of a visualization.
        __Default value:__
        - For y-axis with a continuous (non-ordinal) scale, the
          height will be the value of
          [`config.cell.height`](config.html#cell-config).
        - For y-axis with an ordinal scale: if
          [`rangeStep`](scale.html#ordinal) is a numeric value
          (default), the height is determined by the value of
          `rangeStep` and the cardinality of the field mapped to
          y-channel.   Otherwise, if the `rangeStep` is `null`, the
          height will be the value of
          [`config.cell.height`](config.html#cell-config).
        - If no field is mapped to `x` channel, the `height` will be
          the value of `rangeStep`.
        __Note__: For plot with `row` and `column` channels, this
        represents the height of a single cell.
    width : number
        The width of a visualization.
        __Default value:__ This will be determined by the following
        rules:
        - For x-axis with a continuous (non-ordinal) scale, the
          width will be the value of
          [`config.cell.width`](config.html#cell-config).
        - For x-axis with an ordinal scale: if
          [`rangeStep`](scale.html#ordinal) is a numeric value
          (default), the width is determined by the value of
          `rangeStep` and the cardinality of the field mapped to
          x-channel.   Otherwise, if the `rangeStep` is `null`, the
          width will be the value of
          [`config.cell.width`](config.html#cell-config).
        - If no field is mapped to `x` channel, the `width` will be
          the value of
          [`config.scale.textXRangeStep`](size.html#default-width-and-
          height) for `text` mark and the value of `rangeStep` for
          other marks.
        __Note__: For plot with `row` and `column` channels, this
        represents the width of a single cell.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    height = jst.JSONNumber(help='The height of a visualization. __Default value:__ - For y-axis [...]')
    width = jst.JSONNumber(help='The width of a visualization. __Default value:__ This will be [...]')

    def __init__(self, height=jst.undefined, width=jst.undefined, **kwargs):
        kwds = dict(height=height, width=width)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(LayoutSizeMixins, self).__init__(**kwargs)


class Legend(jst.JSONHasTraits):
    """Legend class

    Properties of a legend or boolean flag for determining whether to
    show it.

    Attributes
    ----------
    encoding : LegendEncoding
        Optional mark definitions for custom legend encoding.
    entryPadding : number
        Padding (in pixels) between legend entries in a symbol legend.
    fillColor : string
        Background fill color for the full legend.
    format : string
        The formatting pattern for labels. This is D3's [number format
        pattern](https://github.com/mbostock/d3/wiki/Formatting) for
        quantitative fields and D3's [time format
        pattern](https://github.com/mbostock/d3/wiki/Time-Formatting)
        for time field.
        __Default value:__  derived from
        [numberFormat](config.html#format) config for quantitative
        fields and from [timeFormat](config.html#format) config for
        temporal fields.
    offset : number
        The offset, in pixels, by which to displace the legend from
        the edge of the enclosing group or data rectangle.
        __Default value:__  `0`
    orient : string
        The orientation of the legend. One of `"left"` or `"right"`.
        This determines how the legend is positioned within the scene.
        The default is `"right"`.
        __Default value:__  `"right"`
    padding : number
        The padding, in pixels, between the legend and axis.
    tickCount : number
        The desired number of tick values for quantitative legends.
    title : string
        A title for the field.
        __Default value:__  derived from the field's name and
        transformation function applied e.g, "field_name",
        "SUM(field_name)", "BIN(field_name)", "YEAR(field_name)".
    titleAlign : string
        Horizontal text alignment for legend titles.
    type : string
        The type of the legend. Use `symbol` to create a discrete
        legend and `gradient` for a continuous color gradient.
    values : AnyOf([Array(number), Array(string), Array(DateTime)])
        Explicitly set the visible legend values.
    zindex : number
        A non-positive integer indicating z-index of the legend.
        If zindex is 0, legend should be drawn behind all chart
        elements.
        To put them in front, use zindex = 1.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    encoding = jst.JSONInstance(_localname('LegendEncoding'), help='Optional mark definitions for custom legend encoding.')
    entryPadding = jst.JSONNumber(help='Padding (in pixels) between legend entries in a symbol legend.')
    fillColor = jst.JSONString(help='Background fill color for the full legend.')
    format = jst.JSONString(help="The formatting pattern for labels. This is D3's [number format [...]")
    offset = jst.JSONNumber(help='The offset, in pixels, by which to displace the legend from the [...]')
    orient = LegendOrient()
    padding = jst.JSONNumber(help='The padding, in pixels, between the legend and axis.')
    tickCount = jst.JSONNumber(help='The desired number of tick values for quantitative legends.')
    title = jst.JSONString(help='A title for the field. __Default value:__ derived from the [...]')
    titleAlign = jst.JSONString(help='Horizontal text alignment for legend titles.')
    type = jst.JSONEnum(['symbol', 'gradient'], help='The type of the legend. Use `symbol` to create a discrete legend [...]')
    values = jst.JSONAnyOf([jst.JSONArray(jst.JSONNumber()), jst.JSONArray(jst.JSONString()), jst.JSONArray(jst.JSONInstance(_localname('DateTime')))], help='Explicitly set the visible legend values.')
    zindex = jst.JSONNumber(help='A non-positive integer indicating z-index of the legend. If [...]', minimum=0)

    def __init__(self, encoding=jst.undefined, entryPadding=jst.undefined, fillColor=jst.undefined, format=jst.undefined, offset=jst.undefined, orient=jst.undefined, padding=jst.undefined, tickCount=jst.undefined, title=jst.undefined, titleAlign=jst.undefined, type=jst.undefined, values=jst.undefined, zindex=jst.undefined, **kwargs):
        kwds = dict(encoding=encoding, entryPadding=entryPadding, fillColor=fillColor, format=format, offset=offset, orient=orient, padding=padding, tickCount=tickCount, title=title, titleAlign=titleAlign, type=type, values=values, zindex=zindex)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Legend, self).__init__(**kwargs)


class LegendConfig(jst.JSONHasTraits):
    """LegendConfig class

    

    Attributes
    ----------
    cornerRadius : number
        Corner radius for the full legend.
    entryPadding : number
        Padding (in pixels) between legend entries in a symbol legend.
    fillColor : string
        Background fill color for the full legend.
    gradientHeight : number
        The height of the gradient, in pixels.
    gradientLabelBaseline : string
        Text baseline for color ramp gradient labels.
    gradientLabelLimit : number
        The maximum allowed length in pixels of color ramp gradient
        labels.
    gradientLabelOffset : number
        Vertical offset in pixels for color ramp gradient labels.
    gradientStrokeColor : string
        The color of the gradient stroke, can be in hex color code or
        regular color name.
    gradientStrokeWidth : number
        The width of the gradient stroke, in pixels.
    gradientWidth : number
        The width of the gradient, in pixels.
    labelAlign : string
        The alignment of the legend label, can be left, middle or
        right.
    labelBaseline : string
        The position of the baseline of legend label, can be top,
        middle or bottom.
    labelColor : string
        The color of the legend label, can be in hex color code or
        regular color name.
    labelFont : string
        The font of the legend label.
    labelFontSize : number
        The font size of legend label.
        __Default value:__ `10`.
    labelLimit : number
        Maximum allowed pixel width of axis tick labels.
    labelOffset : number
        The offset of the legend label.
    offset : number
        The offset, in pixels, by which to displace the legend from
        the edge of the enclosing group or data rectangle.
        __Default value:__  `0`
    orient : string
        The orientation of the legend. One of `"left"` or `"right"`.
        This determines how the legend is positioned within the scene.
        The default is `"right"`.
        __Default value:__  `"right"`
    padding : number
        The padding, in pixels, between the legend and axis.
    shortTimeLabels : boolean
        Whether month names and weekday names should be abbreviated.
        __Default value:__  `false`
    strokeColor : string
        Border stroke color for the full legend.
    strokeDash : Array(number)
        Border stroke dash pattern for the full legend.
    strokeWidth : number
        Border stroke width for the full legend.
    symbolColor : string
        The color of the legend symbol,
    symbolSize : number
        The size of the legend symbol, in pixels.
    symbolStrokeWidth : number
        The width of the symbol's stroke.
    symbolType : string
        Default shape type (such as "circle") for legend symbols.
    titleAlign : string
        Horizontal text alignment for legend titles.
    titleBaseline : string
        Optional mark property definitions for custom legend styling.
         Vertical text baseline for legend titles.
    titleColor : string
        The color of the legend title, can be in hex color code or
        regular color name.
    titleFont : string
        The font of the legend title.
    titleFontSize : number
        The font size of the legend title.
    titleFontWeight : ['string', 'number']
        The font weight of the legend title.
    titleLimit : number
        Maximum allowed pixel width of axis titles.
    titlePadding : number
        The padding, in pixels, between title and legend.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    cornerRadius = jst.JSONNumber(help='Corner radius for the full legend.')
    entryPadding = jst.JSONNumber(help='Padding (in pixels) between legend entries in a symbol legend.')
    fillColor = jst.JSONString(help='Background fill color for the full legend.')
    gradientHeight = jst.JSONNumber(help='The height of the gradient, in pixels.', minimum=0)
    gradientLabelBaseline = jst.JSONString(help='Text baseline for color ramp gradient labels.')
    gradientLabelLimit = jst.JSONNumber(help='The maximum allowed length in pixels of color ramp gradient labels.')
    gradientLabelOffset = jst.JSONNumber(help='Vertical offset in pixels for color ramp gradient labels.')
    gradientStrokeColor = jst.JSONString(help='The color of the gradient stroke, can be in hex color code or [...]')
    gradientStrokeWidth = jst.JSONNumber(help='The width of the gradient stroke, in pixels.', minimum=0)
    gradientWidth = jst.JSONNumber(help='The width of the gradient, in pixels.', minimum=0)
    labelAlign = jst.JSONString(help='The alignment of the legend label, can be left, middle or right.')
    labelBaseline = jst.JSONString(help='The position of the baseline of legend label, can be top, middle [...]')
    labelColor = jst.JSONString(help='The color of the legend label, can be in hex color code or [...]')
    labelFont = jst.JSONString(help='The font of the legend label.')
    labelFontSize = jst.JSONNumber(help='The font size of legend label. __Default value:__ `10`.', minimum=0)
    labelLimit = jst.JSONNumber(help='Maximum allowed pixel width of axis tick labels.')
    labelOffset = jst.JSONNumber(help='The offset of the legend label.', minimum=0)
    offset = jst.JSONNumber(help='The offset, in pixels, by which to displace the legend from the [...]')
    orient = LegendOrient()
    padding = jst.JSONNumber(help='The padding, in pixels, between the legend and axis.')
    shortTimeLabels = jst.JSONBoolean(help='Whether month names and weekday names should be abbreviated. [...]')
    strokeColor = jst.JSONString(help='Border stroke color for the full legend.')
    strokeDash = jst.JSONArray(jst.JSONNumber(), help='Border stroke dash pattern for the full legend.')
    strokeWidth = jst.JSONNumber(help='Border stroke width for the full legend.')
    symbolColor = jst.JSONString(help='The color of the legend symbol,')
    symbolSize = jst.JSONNumber(help='The size of the legend symbol, in pixels.', minimum=0)
    symbolStrokeWidth = jst.JSONNumber(help="The width of the symbol's stroke.", minimum=0)
    symbolType = jst.JSONString(help='Default shape type (such as "circle") for legend symbols.')
    titleAlign = jst.JSONString(help='Horizontal text alignment for legend titles.')
    titleBaseline = jst.JSONString(help='Optional mark property definitions for custom legend styling. [...]')
    titleColor = jst.JSONString(help='The color of the legend title, can be in hex color code or [...]')
    titleFont = jst.JSONString(help='The font of the legend title.')
    titleFontSize = jst.JSONNumber(help='The font size of the legend title.')
    titleFontWeight = jst.JSONUnion([jst.JSONString(), jst.JSONNumber()], help='The font weight of the legend title.')
    titleLimit = jst.JSONNumber(help='Maximum allowed pixel width of axis titles.')
    titlePadding = jst.JSONNumber(help='The padding, in pixels, between title and legend.')

    def __init__(self, cornerRadius=jst.undefined, entryPadding=jst.undefined, fillColor=jst.undefined, gradientHeight=jst.undefined, gradientLabelBaseline=jst.undefined, gradientLabelLimit=jst.undefined, gradientLabelOffset=jst.undefined, gradientStrokeColor=jst.undefined, gradientStrokeWidth=jst.undefined, gradientWidth=jst.undefined, labelAlign=jst.undefined, labelBaseline=jst.undefined, labelColor=jst.undefined, labelFont=jst.undefined, labelFontSize=jst.undefined, labelLimit=jst.undefined, labelOffset=jst.undefined, offset=jst.undefined, orient=jst.undefined, padding=jst.undefined, shortTimeLabels=jst.undefined, strokeColor=jst.undefined, strokeDash=jst.undefined, strokeWidth=jst.undefined, symbolColor=jst.undefined, symbolSize=jst.undefined, symbolStrokeWidth=jst.undefined, symbolType=jst.undefined, titleAlign=jst.undefined, titleBaseline=jst.undefined, titleColor=jst.undefined, titleFont=jst.undefined, titleFontSize=jst.undefined, titleFontWeight=jst.undefined, titleLimit=jst.undefined, titlePadding=jst.undefined, **kwargs):
        kwds = dict(cornerRadius=cornerRadius, entryPadding=entryPadding, fillColor=fillColor, gradientHeight=gradientHeight, gradientLabelBaseline=gradientLabelBaseline, gradientLabelLimit=gradientLabelLimit, gradientLabelOffset=gradientLabelOffset, gradientStrokeColor=gradientStrokeColor, gradientStrokeWidth=gradientStrokeWidth, gradientWidth=gradientWidth, labelAlign=labelAlign, labelBaseline=labelBaseline, labelColor=labelColor, labelFont=labelFont, labelFontSize=labelFontSize, labelLimit=labelLimit, labelOffset=labelOffset, offset=offset, orient=orient, padding=padding, shortTimeLabels=shortTimeLabels, strokeColor=strokeColor, strokeDash=strokeDash, strokeWidth=strokeWidth, symbolColor=symbolColor, symbolSize=symbolSize, symbolStrokeWidth=symbolStrokeWidth, symbolType=symbolType, titleAlign=titleAlign, titleBaseline=titleBaseline, titleColor=titleColor, titleFont=titleFont, titleFontSize=titleFontSize, titleFontWeight=titleFontWeight, titleLimit=titleLimit, titlePadding=titlePadding)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(LegendConfig, self).__init__(**kwargs)


class LegendEncoding(jst.JSONHasTraits):
    """LegendEncoding class

    

    Attributes
    ----------
    gradient : GuideEncodingEntry
        Custom encoding for legend gradient filled rect marks.
    labels : GuideEncodingEntry
        Custom encoding for legend label text marks.
    legend : GuideEncodingEntry
        Custom encoding for the legend container.
        This can be useful for creating legend with custom x, y
        position.
    symbols : GuideEncodingEntry
        Custom encoding for legend symbol marks.
    title : GuideEncodingEntry
        Custom encoding for the legend title text mark.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    gradient = jst.JSONInstance(_localname('GuideEncodingEntry'), help='Custom encoding for legend gradient filled rect marks.')
    labels = jst.JSONInstance(_localname('GuideEncodingEntry'), help='Custom encoding for legend label text marks.')
    legend = jst.JSONInstance(_localname('GuideEncodingEntry'), help='Custom encoding for the legend container. This can be useful for [...]')
    symbols = jst.JSONInstance(_localname('GuideEncodingEntry'), help='Custom encoding for legend symbol marks.')
    title = jst.JSONInstance(_localname('GuideEncodingEntry'), help='Custom encoding for the legend title text mark.')

    def __init__(self, gradient=jst.undefined, labels=jst.undefined, legend=jst.undefined, symbols=jst.undefined, title=jst.undefined, **kwargs):
        kwds = dict(gradient=gradient, labels=labels, legend=legend, symbols=symbols, title=title)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(LegendEncoding, self).__init__(**kwargs)


class LegendFieldDef(jst.JSONHasTraits):
    """LegendFieldDef class

    

    Attributes
    ----------
    aggregate : AnyOf([string, string])
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        __Default value:__ `undefined` (None)
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    field : AnyOf([string, RepeatRef])
        __Required.__ Name of the field from which to pull a data
        value.
        __Note:__ `field` is not required if `aggregate` is `count`.
    legend : AnyOf([Legend, null])
        
    scale : Scale
        
    sort : AnyOf([SortField, AnyOf([string, string, null])])
        Sort order for a field with discrete domain.
        This can be `"ascending"`, `"descending"`, `null`, or a [sort
        field definition object](sort.html#sort-field) for sorting by
        an aggregate calculation of a specified sort field.
        __Note:__ For fields with continuous domain, please use
        `"scale": {"reverse": true}` to flip the scale instead.
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
        __Default value:__ `undefined` (None)
    type : string
        The encoded field's type of measurement. This can be either a
        full type
        name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and
        `"nominal"`)
        or an initial character of the type name (`"Q"`, `"T"`, `"O"`,
        `"N"`).
        This property is case-insensitive.
    """
    _additional_traits = False
    _required_traits = ['type']
    _trait_name_map = {}
    aggregate = jst.JSONAnyOf([AggregateOp(), BOXPLOT()], help='Aggregation function for the field (e.g., `mean`, `sum`, [...]')
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    field = jst.JSONAnyOf([jst.JSONString(), jst.JSONInstance(_localname('RepeatRef'))])
    legend = jst.JSONAnyOf([jst.JSONInstance(_localname('Legend')), jst.JSONNull()])
    scale = jst.JSONInstance(_localname('Scale'))
    sort = jst.JSONAnyOf([jst.JSONInstance(_localname('SortField')), jst.JSONAnyOf([jst.JSONEnum(['ascending']), jst.JSONEnum(['descending']), jst.JSONNull()])], help='Sort order for a field with discrete domain. This can be [...]')
    timeUnit = TimeUnit()
    type = Type(help='Constants and utilities for data type Data type based on level [...]')

    def __init__(self, aggregate=jst.undefined, bin=jst.undefined, field=jst.undefined, legend=jst.undefined, scale=jst.undefined, sort=jst.undefined, timeUnit=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, bin=bin, field=field, legend=legend, scale=scale, sort=sort, timeUnit=timeUnit, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(LegendFieldDef, self).__init__(**kwargs)


class LookupData(jst.JSONHasTraits):
    """LookupData class

    

    Attributes
    ----------
    data : Data
        secondary data source to lookup in
    fields : Array(string)
        (Optional) fields in foreign data to lookup
        if not specificied, the entire object is queried
    key : string
        key in data to lookup
    """
    _additional_traits = False
    _required_traits = ['data', 'key']
    _trait_name_map = {}
    data = jst.JSONInstance(_localname('Data'), help='secondary data source to lookup in')
    fields = jst.JSONArray(jst.JSONString(), help='(Optional) fields in foreign data to lookup if not specificied, [...]')
    key = jst.JSONString(help='key in data to lookup')

    def __init__(self, data=jst.undefined, fields=jst.undefined, key=jst.undefined, **kwargs):
        kwds = dict(data=data, fields=fields, key=key)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(LookupData, self).__init__(**kwargs)


class LookupTransform(jst.JSONHasTraits):
    """LookupTransform class

    

    Attributes
    ----------
    as_ : AnyOf([string, Array(string)])
        (Optional) The field or fields for storing the computed
        formula value.
        If `from.fields` is not specified, `as` has to be a string and
        we put the whole object into the data
    default : string
        (Optional) The default value to use if lookup fails
    from_ : LookupData
        secondary data reference
    lookup : string
        key in primary data source
    """
    _additional_traits = False
    _required_traits = ['lookup', 'from']
    _trait_name_map = {'from_': 'from', 'as_': 'as'}
    as_ = jst.JSONAnyOf([jst.JSONString(), jst.JSONArray(jst.JSONString())], help='(Optional) The field or fields for storing the computed formula [...]')
    default = jst.JSONString(help='(Optional) The default value to use if lookup fails')
    from_ = jst.JSONInstance(_localname('LookupData'), help='secondary data reference')
    lookup = jst.JSONString(help='key in primary data source')

    def __init__(self, as_=jst.undefined, default=jst.undefined, from_=jst.undefined, lookup=jst.undefined, **kwargs):
        kwds = dict(as_=as_, default=default, from_=from_, lookup=lookup)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(LookupTransform, self).__init__(**kwargs)


class MarkConfig(jst.JSONHasTraits):
    """MarkConfig class

    

    Attributes
    ----------
    align : string
        The horizontal alignment of the text. One of `"left"`,
        `"right"`, `"center"`.
    angle : number
        The rotation angle of the text, in degrees.
    baseline : string
        The vertical alignment of the text. One of `"top"`,
        `"middle"`, `"bottom"`.
        __Default value:__ `"middle"`
    color : string
        Default color.
        __Default value:__ <span style="color:
        #4682b4;">&#9632;</span> `"#4682b4"`
    dx : number
        The horizontal offset, in pixels, between the text label and
        its anchor point. The offset is applied after rotation by the
        _angle_ property.
    dy : number
        The vertical offset, in pixels, between the text label and its
        anchor point. The offset is applied after rotation by the
        _angle_ property.
    fill : string
        Default Fill Color.  This has higher precedence than
        config.color
        __Default value:__ (None)
    fillOpacity : number
        The fill opacity (value between [0,1]).
        __Default value:__ `1`
    filled : boolean
        Whether the mark's color should be used as fill color instead
        of stroke color.
        __Default value:__ `true` for all marks except `point` and
        `false` for `point`.
        __Applicable for:__ `bar`, `point`, `circle`, `square`, and
        `area` marks.
    font : string
        The typeface to set the text in (e.g., `"Helvetica Neue"`).
    fontSize : number
        The font size, in pixels.
    fontStyle : string
        The font style (e.g., `"italic"`).
    fontWeight : AnyOf([string, number])
        The font weight (e.g., `"bold"`).
    interpolate : string
        The line interpolation method to use for line and area marks.
        One of the following:
        - `"linear"`: piecewise linear segments, as in a polyline.
        - `"linear-closed"`: close the linear segments to form a
          polygon.
        - `"step"`: alternate between horizontal and vertical
          segments, as in a step function.
        - `"step-before"`: alternate between vertical and horizontal
          segments, as in a step function.
        - `"step-after"`: alternate between horizontal and vertical
          segments, as in a step function.
        - `"basis"`: a B-spline, with control point duplication on
          the ends.
        - `"basis-open"`: an open B-spline; may not intersect the
          start or end.
        - `"basis-closed"`: a closed B-spline, as in a loop.
        - `"cardinal"`: a Cardinal spline, with control point
          duplication on the ends.
        - `"cardinal-open"`: an open Cardinal spline; may not
          intersect the start or end, but will intersect other control
          points.
        - `"cardinal-closed"`: a closed Cardinal spline, as in a
          loop.
        - `"bundle"`: equivalent to basis, except the tension
          parameter is used to straighten the spline.
        - `"monotone"`: cubic interpolation that preserves
          monotonicity in y.
    opacity : number
        The overall opacity (value between [0,1]).
        __Default value:__ `0.7` for non-aggregate plots with `point`,
        `tick`, `circle`, or `square` marks or layered `bar` charts
        and `1` otherwise.
    orient : string
        The orientation of a non-stacked bar, tick, area, and line
        charts.
        The value is either horizontal (default) or vertical.
        - For bar, rule and tick, this determines whether the size
          of the bar and tick
        should be applied to x or y dimension.
        - For area, this property determines the orient property of
          the Vega output.
        - For line, this property determines the sort order of the
          points in the line
        if `config.sortLineBy` is not specified.
        For stacked charts, this is always determined by the
        orientation of the stack;
        therefore explicitly specified value will be ignored.
    radius : number
        Polar coordinate radial offset, in pixels, of the text label
        from the origin determined by the `x` and `y` properties.
    shape : string
        The default symbol shape to use. One of: `"circle"` (default),
        `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, or
        `"triangle-down"`, or a custom SVG path.
        __Default value:__ `"circle"`
    size : number
        The pixel area each the point/circle/square.
        For example: in the case of circles, the radius is determined
        in part by the square root of the size value.
        __Default value:__ `30`
    stroke : string
        Default Stroke Color.  This has higher precedence than
        config.color
        __Default value:__ (None)
    strokeDash : Array(number)
        An array of alternating stroke, space lengths for creating
        dashed or dotted lines.
    strokeDashOffset : number
        The offset (in pixels) into which to begin drawing with the
        stroke dash array.
    strokeOpacity : number
        The stroke opacity (value between [0,1]).
        __Default value:__ `1`
    strokeWidth : number
        The stroke width, in pixels.
    tension : number
        Depending on the interpolation type, sets the tension
        parameter (for line and area marks).
    text : string
        Placeholder text if the `text` channel is not specified
    theta : number
        Polar coordinate angle, in radians, of the text label from the
        origin determined by the `x` and `y` properties. Values for
        `theta` follow the same convention of `arc` mark `startAngle`
        and `endAngle` properties: angles are measured in radians,
        with `0` indicating "north".
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    align = HorizontalAlign()
    angle = jst.JSONNumber(help='The rotation angle of the text, in degrees.', maximum=360, minimum=0)
    baseline = VerticalAlign()
    color = jst.JSONString(help='Default color. __Default value:__ <span style="color: [...]')
    dx = jst.JSONNumber(help='The horizontal offset, in pixels, between the text label and its [...]')
    dy = jst.JSONNumber(help='The vertical offset, in pixels, between the text label and its [...]')
    fill = jst.JSONString(help='Default Fill Color. This has higher precedence than config.color [...]')
    fillOpacity = jst.JSONNumber(help='The fill opacity (value between [0,1]). __Default value:__ `1`', maximum=1, minimum=0)
    filled = jst.JSONBoolean(help="Whether the mark's color should be used as fill color instead of [...]")
    font = jst.JSONString(help='The typeface to set the text in (e.g., `"Helvetica Neue"`).')
    fontSize = jst.JSONNumber(help='The font size, in pixels.', minimum=0)
    fontStyle = FontStyle()
    fontWeight = jst.JSONAnyOf([FontWeight(), jst.JSONNumber(maximum=900, minimum=100)], help='The font weight (e.g., `"bold"`).')
    interpolate = Interpolate()
    opacity = jst.JSONNumber(help='The overall opacity (value between [0,1]). __Default value:__ [...]', maximum=1, minimum=0)
    orient = Orient()
    radius = jst.JSONNumber(help='Polar coordinate radial offset, in pixels, of the text label [...]', minimum=0)
    shape = jst.JSONString(help='The default symbol shape to use. One of: `"circle"` (default), [...]')
    size = jst.JSONNumber(help='The pixel area each the point/circle/square. For example: in the [...]', minimum=0)
    stroke = jst.JSONString(help='Default Stroke Color. This has higher precedence than [...]')
    strokeDash = jst.JSONArray(jst.JSONNumber(), help='An array of alternating stroke, space lengths for creating [...]')
    strokeDashOffset = jst.JSONNumber(help='The offset (in pixels) into which to begin drawing with the [...]')
    strokeOpacity = jst.JSONNumber(help='The stroke opacity (value between [0,1]). __Default value:__ `1`', maximum=1, minimum=0)
    strokeWidth = jst.JSONNumber(help='The stroke width, in pixels.', minimum=0)
    tension = jst.JSONNumber(help='Depending on the interpolation type, sets the tension parameter [...]', maximum=1, minimum=0)
    text = jst.JSONString(help='Placeholder text if the `text` channel is not specified')
    theta = jst.JSONNumber(help='Polar coordinate angle, in radians, of the text label from the [...]')

    def __init__(self, align=jst.undefined, angle=jst.undefined, baseline=jst.undefined, color=jst.undefined, dx=jst.undefined, dy=jst.undefined, fill=jst.undefined, fillOpacity=jst.undefined, filled=jst.undefined, font=jst.undefined, fontSize=jst.undefined, fontStyle=jst.undefined, fontWeight=jst.undefined, interpolate=jst.undefined, opacity=jst.undefined, orient=jst.undefined, radius=jst.undefined, shape=jst.undefined, size=jst.undefined, stroke=jst.undefined, strokeDash=jst.undefined, strokeDashOffset=jst.undefined, strokeOpacity=jst.undefined, strokeWidth=jst.undefined, tension=jst.undefined, text=jst.undefined, theta=jst.undefined, **kwargs):
        kwds = dict(align=align, angle=angle, baseline=baseline, color=color, dx=dx, dy=dy, fill=fill, fillOpacity=fillOpacity, filled=filled, font=font, fontSize=fontSize, fontStyle=fontStyle, fontWeight=fontWeight, interpolate=interpolate, opacity=opacity, orient=orient, radius=radius, shape=shape, size=size, stroke=stroke, strokeDash=strokeDash, strokeDashOffset=strokeDashOffset, strokeOpacity=strokeOpacity, strokeWidth=strokeWidth, tension=tension, text=text, theta=theta)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(MarkConfig, self).__init__(**kwargs)


class MarkConfigMixins(jst.JSONHasTraits):
    """MarkConfigMixins class

    

    Attributes
    ----------
    area : MarkConfig
        Area-Specific Config
    bar : BarConfig
        Bar-Specific Config
    circle : MarkConfig
        Circle-Specific Config
    line : MarkConfig
        Line-Specific Config
    mark : MarkConfig
        Mark Config
    point : MarkConfig
        Point-Specific Config
    rect : MarkConfig
        Rect-Specific Config
    rule : MarkConfig
        Rule-Specific Config
    square : MarkConfig
        Square-Specific Config
    text : TextConfig
        Text-Specific Config
    tick : TickConfig
        Tick-Specific Config
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    area = jst.JSONInstance(_localname('MarkConfig'), help='Area-Specific Config')
    bar = jst.JSONInstance(_localname('BarConfig'), help='Bar-Specific Config')
    circle = jst.JSONInstance(_localname('MarkConfig'), help='Circle-Specific Config')
    line = jst.JSONInstance(_localname('MarkConfig'), help='Line-Specific Config')
    mark = jst.JSONInstance(_localname('MarkConfig'), help='Mark Config')
    point = jst.JSONInstance(_localname('MarkConfig'), help='Point-Specific Config')
    rect = jst.JSONInstance(_localname('MarkConfig'), help='Rect-Specific Config')
    rule = jst.JSONInstance(_localname('MarkConfig'), help='Rule-Specific Config')
    square = jst.JSONInstance(_localname('MarkConfig'), help='Square-Specific Config')
    text = jst.JSONInstance(_localname('TextConfig'), help='Text-Specific Config')
    tick = jst.JSONInstance(_localname('TickConfig'), help='Tick-Specific Config')

    def __init__(self, area=jst.undefined, bar=jst.undefined, circle=jst.undefined, line=jst.undefined, mark=jst.undefined, point=jst.undefined, rect=jst.undefined, rule=jst.undefined, square=jst.undefined, text=jst.undefined, tick=jst.undefined, **kwargs):
        kwds = dict(area=area, bar=bar, circle=circle, line=line, mark=mark, point=point, rect=rect, rule=rule, square=square, text=text, tick=tick)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(MarkConfigMixins, self).__init__(**kwargs)


class MarkDef(jst.JSONHasTraits):
    """MarkDef class

    

    Attributes
    ----------
    clip : boolean
        Should a mark be clipped to the enclosing group’s width and
        height?
    filled : boolean
        Whether the mark's color should be used as fill color instead
        of stroke color.
        __Default value:__ All marks except `"point"`, `"line"`, and
        `"rule"` are filled by default.
    interpolate : string
        The line interpolation method to use for line and area marks.
        One of the following:
        - `"linear"`: piecewise linear segments, as in a polyline.
        - `"linear-closed"`: close the linear segments to form a
          polygon.
        - `"step"`: alternate between horizontal and vertical
          segments, as in a step function.
        - `"step-before"`: alternate between vertical and horizontal
          segments, as in a step function.
        - `"step-after"`: alternate between horizontal and vertical
          segments, as in a step function.
        - `"basis"`: a B-spline, with control point duplication on
          the ends.
        - `"basis-open"`: an open B-spline; may not intersect the
          start or end.
        - `"basis-closed"`: a closed B-spline, as in a loop.
        - `"cardinal"`: a Cardinal spline, with control point
          duplication on the ends.
        - `"cardinal-open"`: an open Cardinal spline; may not
          intersect the start or end, but will intersect other control
          points.
        - `"cardinal-closed"`: a closed Cardinal spline, as in a
          loop.
        - `"bundle"`: equivalent to basis, except the tension
          parameter is used to straighten the spline.
        - `"monotone"`: cubic interpolation that preserves
          monotonicity in y.
        For more information about each interpolation method, please
        see [D3's line
        interpolation](https://github.com/mbostock/d3/wiki/SVG-
        Shapes#line_interpolate).
    orient : string
        TODO
    role : string
        A metadata string indicating the role of the mark.
        This allows users to use `config.<role-name>.*` (e.g.,
        `config.myrolename.fill`) to customize properties of marks
        with specific roles.
        In addition, SVG renderers will add this role value (prepended
        with the prefix role-) as a CSS class name on the enclosing
        SVG group (`<g>`) element containing the mark instances.
        __Default value:__ For `bar`, `circle`, `point`, `rule`,
        `square` and `tick` marks, the role is the mark type (e.g.,
        `role: "bar"` for `bar` mark).
        For other marks (which use the same marks in the lower-level
        Vega), the role is `undefined` by default.
        __Note:__ Switching from a default to custom role may alter
        the plot's appearance
        as default [mark-specific configs](config.html#mark-config)
        will no longer be applied.
    tension : number
        Depending on the interpolation type, sets the tension
        parameter (for line and area marks).
        TODO: provide the link to D3 docs.
    type : string
        The mark type.
        One of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`,
        `"area"`, `"point"`, `"rule"`, and `"text"`.
    """
    _additional_traits = False
    _required_traits = ['type']
    _trait_name_map = {}
    clip = jst.JSONBoolean(help='Should a mark be clipped to the enclosing group’s width and height?')
    filled = jst.JSONBoolean(help="Whether the mark's color should be used as fill color instead of [...]")
    interpolate = Interpolate()
    orient = Orient()
    role = jst.JSONString(help='A metadata string indicating the role of the mark. This allows [...]')
    tension = jst.JSONNumber(help='Depending on the interpolation type, sets the tension parameter [...]', maximum=1, minimum=0)
    type = Mark(help='All types of primitive marks.')

    def __init__(self, clip=jst.undefined, filled=jst.undefined, interpolate=jst.undefined, orient=jst.undefined, role=jst.undefined, tension=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(clip=clip, filled=filled, interpolate=interpolate, orient=orient, role=role, tension=tension, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(MarkDef, self).__init__(**kwargs)


class MultiSelection(jst.JSONHasTraits):
    """MultiSelection class

    

    Attributes
    ----------
    encodings : Array(string)
        An array of encoding channels. The corresponding data field
        values
        must match for a data tuple to fall within the selection.
    fields : Array(string)
        An array of field names whose values must match for a data
        tuple to
        fall within the selection.
    nearest : boolean
        When true, an invisible voronoi diagram is computed to
        accelerate discrete
        selection. The data value _nearest_ the mouse cursor is added
        to the selection.
    on : Mapping
        A Vega event stream (object or selector) that triggers the
        selection.
    resolve : string
        With layered and multi-view displays, a strategy that
        determines how
        selections' data queries are resolved when applied in a filter
        transform,
        conditional encoding rule, or scale domain. One of: "global",
        "union",
        "intersect", "union_others", or "intersect_others".
        __global__: Only one instance of the selection exists across
        all
        views. When a user interacts within a new view, any previous
        selections
        are overridden.
        __union__: Each view contains its own selection, and a data
        value is
        considered to be selected if it falls within _any_ of these
        selection
        instances.
        __intersect__: Each view contains its own selection, and a
        data value is
        considered to be selected if it falls within _all_ of these
        selection
        instances.
    toggle : ['string', 'boolean']
        Controls whether data values should be toggled or only ever
        inserted into
        multi selections. Can be `true`, `false` (for insertion only),
        or a
        [Vega
        expression](https://vega.github.io/vega/docs/expressions/).
        __Default value:__ `true`, which corresponds to
        `event.shiftKey` (i.e.,
        data values are toggled when a user interacts with the shift-
        key pressed).
    type : string
        
    """
    _additional_traits = False
    _required_traits = ['type']
    _trait_name_map = {}
    encodings = jst.JSONArray(SingleDefChannel(), help='An array of encoding channels. The corresponding data field [...]')
    fields = jst.JSONArray(jst.JSONString(), help='An array of field names whose values must match for a data tuple [...]')
    nearest = jst.JSONBoolean(help='When true, an invisible voronoi diagram is computed to [...]')
    on = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': True, '_required_traits': []}), help='A Vega event stream (object or selector) that triggers the selection.')
    resolve = SelectionResolution()
    toggle = jst.JSONUnion([jst.JSONString(), jst.JSONBoolean()], help='Controls whether data values should be toggled or only ever [...]')
    type = jst.JSONEnum(['multi'])

    def __init__(self, encodings=jst.undefined, fields=jst.undefined, nearest=jst.undefined, on=jst.undefined, resolve=jst.undefined, toggle=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(encodings=encodings, fields=fields, nearest=nearest, on=on, resolve=resolve, toggle=toggle, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(MultiSelection, self).__init__(**kwargs)


class MultiSelectionConfig(jst.JSONHasTraits):
    """MultiSelectionConfig class

    

    Attributes
    ----------
    encodings : Array(string)
        An array of encoding channels. The corresponding data field
        values
        must match for a data tuple to fall within the selection.
    fields : Array(string)
        An array of field names whose values must match for a data
        tuple to
        fall within the selection.
    nearest : boolean
        When true, an invisible voronoi diagram is computed to
        accelerate discrete
        selection. The data value _nearest_ the mouse cursor is added
        to the selection.
    on : Mapping
        A Vega event stream (object or selector) that triggers the
        selection.
    resolve : string
        With layered and multi-view displays, a strategy that
        determines how
        selections' data queries are resolved when applied in a filter
        transform,
        conditional encoding rule, or scale domain. One of: "global",
        "union",
        "intersect", "union_others", or "intersect_others".
        __global__: Only one instance of the selection exists across
        all
        views. When a user interacts within a new view, any previous
        selections
        are overridden.
        __union__: Each view contains its own selection, and a data
        value is
        considered to be selected if it falls within _any_ of these
        selection
        instances.
        __intersect__: Each view contains its own selection, and a
        data value is
        considered to be selected if it falls within _all_ of these
        selection
        instances.
    toggle : ['string', 'boolean']
        Controls whether data values should be toggled or only ever
        inserted into
        multi selections. Can be `true`, `false` (for insertion only),
        or a
        [Vega
        expression](https://vega.github.io/vega/docs/expressions/).
        __Default value:__ `true`, which corresponds to
        `event.shiftKey` (i.e.,
        data values are toggled when a user interacts with the shift-
        key pressed).
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    encodings = jst.JSONArray(SingleDefChannel(), help='An array of encoding channels. The corresponding data field [...]')
    fields = jst.JSONArray(jst.JSONString(), help='An array of field names whose values must match for a data tuple [...]')
    nearest = jst.JSONBoolean(help='When true, an invisible voronoi diagram is computed to [...]')
    on = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': True, '_required_traits': []}), help='A Vega event stream (object or selector) that triggers the selection.')
    resolve = SelectionResolution()
    toggle = jst.JSONUnion([jst.JSONString(), jst.JSONBoolean()], help='Controls whether data values should be toggled or only ever [...]')

    def __init__(self, encodings=jst.undefined, fields=jst.undefined, nearest=jst.undefined, on=jst.undefined, resolve=jst.undefined, toggle=jst.undefined, **kwargs):
        kwds = dict(encodings=encodings, fields=fields, nearest=nearest, on=on, resolve=resolve, toggle=toggle)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(MultiSelectionConfig, self).__init__(**kwargs)


class NamedData(jst.JSONHasTraits):
    """NamedData class

    

    Attributes
    ----------
    format : DataFormat
        Data format properties
    name : string
        Provide a placeholder name and bind data at runtime.
    """
    _additional_traits = False
    _required_traits = ['name']
    _trait_name_map = {}
    format = jst.JSONInstance(_localname('DataFormat'), help='Data format properties')
    name = jst.JSONString(help='Provide a placeholder name and bind data at runtime.')

    def __init__(self, format=jst.undefined, name=jst.undefined, **kwargs):
        kwds = dict(format=format, name=name)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(NamedData, self).__init__(**kwargs)


class NonspatialResolve(jst.JSONHasTraits):
    """NonspatialResolve class

    

    Attributes
    ----------
    legend : string
        
    scale : string
        
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    legend = ResolveMode()
    scale = ResolveMode()

    def __init__(self, legend=jst.undefined, scale=jst.undefined, **kwargs):
        kwds = dict(legend=legend, scale=scale)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(NonspatialResolve, self).__init__(**kwargs)


class NotFilter(jst.JSONHasTraits):
    """NotFilter class

    

    Attributes
    ----------
    not_ : AnyOf([NotFilter, AndFilter, OrFilter, AnyOf([EqualFilter, RangeFilter, OneOfFilter, SelectionFilter, string])])
        
    """
    _additional_traits = False
    _required_traits = ['not']
    _trait_name_map = {'not_': 'not'}
    not_ = jst.JSONAnyOf([jst.JSONInstance(_localname('NotFilter')), jst.JSONInstance(_localname('AndFilter')), jst.JSONInstance(_localname('OrFilter')), jst.JSONAnyOf([jst.JSONInstance(_localname('EqualFilter')), jst.JSONInstance(_localname('RangeFilter')), jst.JSONInstance(_localname('OneOfFilter')), jst.JSONInstance(_localname('SelectionFilter')), jst.JSONString()])])

    def __init__(self, not_=jst.undefined, **kwargs):
        kwds = dict(not_=not_)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(NotFilter, self).__init__(**kwargs)


class NumberValueDef(jst.JSONHasTraits):
    """NumberValueDef class

    Definition object for a constant value of an encoding channel.

    Attributes
    ----------
    value : number
        A constant value in visual domain.
    """
    _additional_traits = False
    _required_traits = ['value']
    _trait_name_map = {}
    value = jst.JSONNumber(help='A constant value in visual domain.')

    def __init__(self, value=jst.undefined, **kwargs):
        kwds = dict(value=value)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(NumberValueDef, self).__init__(**kwargs)


class OneOfFilter(jst.JSONHasTraits):
    """OneOfFilter class

    

    Attributes
    ----------
    field : string
        Field to be filtered
    oneOf : AnyOf([Array(string), Array(number), Array(boolean), Array(DateTime)])
        A set of values that the `field`'s value should be a member
        of,
        for a data item included in the filtered data.
    timeUnit : string
        time unit for the field to be filtered.
    """
    _additional_traits = False
    _required_traits = ['field', 'oneOf']
    _trait_name_map = {}
    field = jst.JSONString(help='Field to be filtered')
    oneOf = jst.JSONAnyOf([jst.JSONArray(jst.JSONString()), jst.JSONArray(jst.JSONNumber()), jst.JSONArray(jst.JSONBoolean()), jst.JSONArray(jst.JSONInstance(_localname('DateTime')))], help="A set of values that the `field`'s value should be a member of, [...]")
    timeUnit = TimeUnit()

    def __init__(self, field=jst.undefined, oneOf=jst.undefined, timeUnit=jst.undefined, **kwargs):
        kwds = dict(field=field, oneOf=oneOf, timeUnit=timeUnit)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(OneOfFilter, self).__init__(**kwargs)


class OrFilter(jst.JSONHasTraits):
    """OrFilter class

    

    Attributes
    ----------
    or_ : Array(AnyOf([NotFilter, AndFilter, OrFilter, AnyOf([EqualFilter, RangeFilter, OneOfFilter, SelectionFilter, string])]))
        
    """
    _additional_traits = False
    _required_traits = ['or']
    _trait_name_map = {'or_': 'or'}
    or_ = jst.JSONArray(jst.JSONAnyOf([jst.JSONInstance(_localname('NotFilter')), jst.JSONInstance(_localname('AndFilter')), jst.JSONInstance(_localname('OrFilter')), jst.JSONAnyOf([jst.JSONInstance(_localname('EqualFilter')), jst.JSONInstance(_localname('RangeFilter')), jst.JSONInstance(_localname('OneOfFilter')), jst.JSONInstance(_localname('SelectionFilter')), jst.JSONString()])]))

    def __init__(self, or_=jst.undefined, **kwargs):
        kwds = dict(or_=or_)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(OrFilter, self).__init__(**kwargs)


class OrderFieldDef(jst.JSONHasTraits):
    """OrderFieldDef class

    

    Attributes
    ----------
    aggregate : AnyOf([string, string])
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        __Default value:__ `undefined` (None)
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    field : AnyOf([string, RepeatRef])
        __Required.__ Name of the field from which to pull a data
        value.
        __Note:__ `field` is not required if `aggregate` is `count`.
    sort : AnyOf([string, string, null])
        
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
        __Default value:__ `undefined` (None)
    type : string
        The encoded field's type of measurement. This can be either a
        full type
        name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and
        `"nominal"`)
        or an initial character of the type name (`"Q"`, `"T"`, `"O"`,
        `"N"`).
        This property is case-insensitive.
    """
    _additional_traits = False
    _required_traits = ['type']
    _trait_name_map = {}
    aggregate = jst.JSONAnyOf([AggregateOp(), BOXPLOT()], help='Aggregation function for the field (e.g., `mean`, `sum`, [...]')
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    field = jst.JSONAnyOf([jst.JSONString(), jst.JSONInstance(_localname('RepeatRef'))])
    sort = jst.JSONAnyOf([jst.JSONEnum(['ascending']), jst.JSONEnum(['descending']), jst.JSONNull()])
    timeUnit = TimeUnit()
    type = Type(help='Constants and utilities for data type Data type based on level [...]')

    def __init__(self, aggregate=jst.undefined, bin=jst.undefined, field=jst.undefined, sort=jst.undefined, timeUnit=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, bin=bin, field=field, sort=sort, timeUnit=timeUnit, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(OrderFieldDef, self).__init__(**kwargs)


class PositionFieldDef(jst.JSONHasTraits):
    """PositionFieldDef class

    

    Attributes
    ----------
    aggregate : AnyOf([string, string])
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        __Default value:__ `undefined` (None)
    axis : AnyOf([Axis, null])
        By default, Vega-Lite automatically creates axes for `x` and
        `y` channels when they are encoded.
        If `axis` is not defined, default axis properties are applied.
        User can provide set `axis` to an object to customize [axis
        properties](axis.html#axis-properties)
        or set `axis` to `null` to remove the axis.
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    field : AnyOf([string, RepeatRef])
        __Required.__ Name of the field from which to pull a data
        value.
        __Note:__ `field` is not required if `aggregate` is `count`.
    scale : Scale
        
    sort : AnyOf([SortField, AnyOf([string, string, null])])
        Sort order for a field with discrete domain.
        This can be `"ascending"`, `"descending"`, `null`, or a [sort
        field definition object](sort.html#sort-field) for sorting by
        an aggregate calculation of a specified sort field.
        __Note:__ For fields with continuous domain, please use
        `"scale": {"reverse": true}` to flip the scale instead.
    stack : string
        Type of stacking offset if the field should be stacked.
        "none" or null, if the field should not be stacked.
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
        __Default value:__ `undefined` (None)
    type : string
        The encoded field's type of measurement. This can be either a
        full type
        name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and
        `"nominal"`)
        or an initial character of the type name (`"Q"`, `"T"`, `"O"`,
        `"N"`).
        This property is case-insensitive.
    """
    _additional_traits = False
    _required_traits = ['type']
    _trait_name_map = {}
    aggregate = jst.JSONAnyOf([AggregateOp(), BOXPLOT()], help='Aggregation function for the field (e.g., `mean`, `sum`, [...]')
    axis = jst.JSONAnyOf([jst.JSONInstance(_localname('Axis')), jst.JSONNull()], help='By default, Vega-Lite automatically creates axes for `x` and `y` [...]')
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    field = jst.JSONAnyOf([jst.JSONString(), jst.JSONInstance(_localname('RepeatRef'))])
    scale = jst.JSONInstance(_localname('Scale'))
    sort = jst.JSONAnyOf([jst.JSONInstance(_localname('SortField')), jst.JSONAnyOf([jst.JSONEnum(['ascending']), jst.JSONEnum(['descending']), jst.JSONNull()])], help='Sort order for a field with discrete domain. This can be [...]')
    stack = StackOffset()
    timeUnit = TimeUnit()
    type = Type(help='Constants and utilities for data type Data type based on level [...]')

    def __init__(self, aggregate=jst.undefined, axis=jst.undefined, bin=jst.undefined, field=jst.undefined, scale=jst.undefined, sort=jst.undefined, stack=jst.undefined, timeUnit=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, axis=axis, bin=bin, field=field, scale=scale, sort=sort, stack=stack, timeUnit=timeUnit, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(PositionFieldDef, self).__init__(**kwargs)


class RangeFilter(jst.JSONHasTraits):
    """RangeFilter class

    

    Attributes
    ----------
    field : string
        Field to be filtered
    range : Array(AnyOf([number, DateTime]))
        An array of inclusive minimum and maximum values
        for a field value of a data item to be included in the
        filtered data.
    timeUnit : string
        time unit for the field to be filtered.
    """
    _additional_traits = False
    _required_traits = ['field', 'range']
    _trait_name_map = {}
    field = jst.JSONString(help='Field to be filtered')
    range = jst.JSONArray(jst.JSONAnyOf([jst.JSONNumber(), jst.JSONInstance(_localname('DateTime'))]), help='An array of inclusive minimum and maximum values for a field [...]', maxlen=2, minlen=2)
    timeUnit = TimeUnit()

    def __init__(self, field=jst.undefined, range=jst.undefined, timeUnit=jst.undefined, **kwargs):
        kwds = dict(field=field, range=range, timeUnit=timeUnit)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(RangeFilter, self).__init__(**kwargs)


class Repeat(jst.JSONHasTraits):
    """Repeat class

    

    Attributes
    ----------
    column : Array(string)
        Horizontal repeated views.
    row : Array(string)
        Vertical repeated views.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    column = jst.JSONArray(jst.JSONString(), help='Horizontal repeated views.')
    row = jst.JSONArray(jst.JSONString(), help='Vertical repeated views.')

    def __init__(self, column=jst.undefined, row=jst.undefined, **kwargs):
        kwds = dict(column=column, row=row)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Repeat, self).__init__(**kwargs)


class RepeatRef(jst.JSONHasTraits):
    """RepeatRef class

    Reference to a repeated value.

    Attributes
    ----------
    repeat : string
        
    """
    _additional_traits = False
    _required_traits = ['repeat']
    _trait_name_map = {}
    repeat = jst.JSONEnum(['row', 'column'])

    def __init__(self, repeat=jst.undefined, **kwargs):
        kwds = dict(repeat=repeat)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(RepeatRef, self).__init__(**kwargs)


class RepeatSpec(jst.JSONHasTraits):
    """RepeatSpec class

    

    Attributes
    ----------
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
    name : string
        Name of the visualization for later reference.
    repeat : Repeat
        
    resolve : ResolveMapping
        
    spec : Spec
        
    transform : Array(Transform)
        An array of data transformations such as filter and new field
        calculation.
    """
    _additional_traits = False
    _required_traits = ['repeat', 'spec']
    _trait_name_map = {}
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose.')
    name = jst.JSONString(help='Name of the visualization for later reference.')
    repeat = jst.JSONInstance(_localname('Repeat'))
    resolve = jst.JSONInstance(_localname('ResolveMapping'))
    spec = jst.JSONInstance(_localname('Spec'))
    transform = jst.JSONArray(jst.JSONInstance(_localname('Transform')), help='An array of data transformations such as filter and new field [...]')

    def __init__(self, data=jst.undefined, description=jst.undefined, name=jst.undefined, repeat=jst.undefined, resolve=jst.undefined, spec=jst.undefined, transform=jst.undefined, **kwargs):
        kwds = dict(data=data, description=description, name=name, repeat=repeat, resolve=resolve, spec=spec, transform=transform)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(RepeatSpec, self).__init__(**kwargs)


class ResolveMapping(jst.JSONHasTraits):
    """ResolveMapping class

    

    Attributes
    ----------
    color : NonspatialResolve
        
    opacity : NonspatialResolve
        
    shape : NonspatialResolve
        
    size : NonspatialResolve
        
    x : SpatialResolve
        
    y : SpatialResolve
        
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    color = jst.JSONInstance(_localname('NonspatialResolve'))
    opacity = jst.JSONInstance(_localname('NonspatialResolve'))
    shape = jst.JSONInstance(_localname('NonspatialResolve'))
    size = jst.JSONInstance(_localname('NonspatialResolve'))
    x = jst.JSONInstance(_localname('SpatialResolve'))
    y = jst.JSONInstance(_localname('SpatialResolve'))

    def __init__(self, color=jst.undefined, opacity=jst.undefined, shape=jst.undefined, size=jst.undefined, x=jst.undefined, y=jst.undefined, **kwargs):
        kwds = dict(color=color, opacity=opacity, shape=shape, size=size, x=x, y=y)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ResolveMapping, self).__init__(**kwargs)


class Scale(jst.JSONHasTraits):
    """Scale class

    

    Attributes
    ----------
    clamp : boolean
        If `true`, values that exceed the data domain are clamped to
        either the minimum or maximum range value
        __Default value:__ derived from [scale
        config](config.html#scale-config) (`true` by default)
        __Supported types:__ only `linear`, `pow`, `sqrt`, and `log`
        (Not applicable for `quantile`, `quantize`, and `threshold`
        scales as they output discrete ranges.)
    domain : AnyOf([Array(number), Array(string), Array(DateTime), string, SelectionDomain])
        The domain of the scale, representing the set of data values.
        For quantitative data, this can take the form of a two-element
        array with minimum and maximum values. For ordinal/categorical
        data, this may be an array of valid input values.
        If the domain is `"unaggregated"`, we use the source data
        range before aggregation as scale domain instead of aggregated
        data for an aggregate axis.
        This property only works with aggregate functions that produce
        values within the raw data domain (`"mean"`, `"average"`,
        `"median"`, `"q1"`, `"q3"`, `"min"`, `"max"`). For other
        aggregations that produce values outside of the raw data
        domain (e.g. `"count"`, `"sum"`), this property is ignored.
    exponent : number
        Sets the exponent of the scale transformation. For `pow` scale
        types only, otherwise ignored.
    interpolate : string
        
    nice : ['boolean', 'string']
        As quantitative scale property, if specified, modifies the
        scale domain to use a more human-friendly value range. If
        specified as a `true` boolean, modifies the scale domain to
        use a more human-friendly number range (e.g., 7 instead of
        6.96). If specified as a string, modifies the scale domain to
        use a more human-friendly value range. For time and utc scale
        types only, the nice value should be a string indicating the
        desired time interval.
        As time scale properties, if `true`, values that exceed the
        data domain are clamped to either the minimum or maximum range
        value. (Not applicable for `quantile`, `quantize`, and
        `threshold` scales as they output discrete ranges.)
        __Default value:__ `true` only for quantitative x and y scales
        and `false` otherwise.
    padding : number
        Applies spacing among ordinal elements in the scale range. The
        actual effect depends on how the scale is configured. If the
        __points__ parameter is `true`, the padding value is
        interpreted as a multiple of the spacing between points. A
        reasonable value is 1.0, such that the first and last point
        will be offset from the minimum and maximum value by half the
        distance between points. Otherwise, padding is typically in
        the range [0, 1] and corresponds to the fraction of space in
        the range interval to allocate to padding. A value of 0.5
        means that the band size will be equal to the padding width.
        For more, see the [D3 ordinal scale
        documentation](https://github.com/mbostock/d3/wiki/Ordinal-
        Scales).
        A convenience property for setting the inner and outer padding
        to the same value.
        __Default value:__ `x` and `y` channels are derived from
        [scale config](config.html#scale-config)'s `pointPadding` for
        `point` scale and `bandPadding` for `band` scale.  Other
        channels have `0` padding by default.
    paddingInner : number
        The inner padding of a band scale determines the ratio of the
        range that is reserved for blank space between bands. (For
        point scale, this property is ignored.)
    paddingOuter : number
        The outer padding determines the ratio of the range that is
        reserved for blank space before the first and after the last
        bands/points.
    range : AnyOf([Array(number), Array(string), string])
        The range of the scale, representing the set of visual values.
        For numeric values, the range can take the form of a two-
        element array with minimum and maximum values. For ordinal or
        quantized data, the range may by an array of desired output
        values, which are mapped to elements in the specified domain.
    rangeStep : ['number', 'null']
        The distance between the starts of adjacent bands or points in
        band or point scales.
        If this value is `null`, this will be determined to fit width
        (for x) or height (for y) of the plot.
        If both width and x-scale's rangeStep is provided, rangeStep
        will be dropped.  (The same rule is applied for height and
        y-scale's rangeStep.)
        __Default Rule:__ for `x` ordinal scale of a `text` mark,
        derived from [scale config](config.html#scale-config)'s
        `textXRangeStep`. Otherwise, derived from [scale
        config](config.html#scale-config)'s `rangeStep`.
        __Warning:__ If the cardinality of the scale domain is too
        high, the rangeStep might become less than one pixel and the
        mark might not appear correctly.
    reverse : boolean
        If true, reverses the order of the scale range.
        __Default value:__ `false`.
    round : boolean
        If `true`, rounds numeric output values to integers. This can
        be helpful for snapping to the pixel grid.
        __Default Rule:__ `true` for `"x"`, `"y"`, `"row"`, `"column"`
        channels if scale config's `round` is `true`; `false`
        otherwise.
    scheme : AnyOf([string, ExtendedScheme])
        Range scheme (e.g., color schemes such as `"category10"` or
        `"viridis"`).
        __Default value:__ [scale config](config.html#scale-config)'s
        `"nominalColorScheme"` for nominal field and
        `"sequentialColorScheme"` for other types of fields.
    type : string
        The type of scale.
        - For a _quantitative_ field, supported quantitative scale
          types  are `"linear"` (default), `"log"`, `"pow"`, `"sqrt"`,
          `"quantile"`, `"quantize"`, and `"threshold"`.
        - For a _temporal_ field without `timeUnit`, the scale type
          should be `"time"` (default), `"utc"` or `"ordinal"`. See
          more about [UTC time](timeunit.html#utc)
        - For _ordinal_ and _nominal_ fields, the type is always
          `"ordinal"`.
        Unsupported values will be ignored.
    zero : boolean
        If `true`, ensures that a zero baseline value is included in
        the scale domain.
        Default value: `true` for `x` and `y` channel if the
        quantitative field is not binned
        and no custom `domain` is provided; `false` otherwise.
        __Default value:__ `true` for `x` and `y` channel if the
        quantitative field is not binned and no custom `domain` is
        provided; `false` otherwise.
        __Note:__  This property is always `false` for log scale.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    clamp = jst.JSONBoolean(help='If `true`, values that exceed the data domain are clamped to [...]')
    domain = jst.JSONAnyOf([jst.JSONArray(jst.JSONNumber()), jst.JSONArray(jst.JSONString()), jst.JSONArray(jst.JSONInstance(_localname('DateTime'))), jst.JSONEnum(['unaggregated']), jst.JSONInstance(_localname('SelectionDomain'))])
    exponent = jst.JSONNumber(help='Sets the exponent of the scale transformation. For `pow` scale [...]')
    interpolate = jst.JSONEnum(['rgb', 'lab', 'hcl', 'hsl', 'hsl-long', 'hcl-long', 'cubehelix', 'cubehelix-long'])
    nice = jst.JSONUnion([jst.JSONBoolean(), jst.JSONString()], help='As quantitative scale property, if specified, modifies the scale [...]')
    padding = jst.JSONNumber(help='Applies spacing among ordinal elements in the scale range. The [...]', maximum=1, minimum=0)
    paddingInner = jst.JSONNumber(help='The inner padding of a band scale determines the ratio of the [...]', maximum=1, minimum=0)
    paddingOuter = jst.JSONNumber(help='The outer padding determines the ratio of the range that is [...]', maximum=1, minimum=0)
    range = jst.JSONAnyOf([jst.JSONArray(jst.JSONNumber()), jst.JSONArray(jst.JSONString()), jst.JSONString()])
    rangeStep = jst.JSONNumber(allow_none=True, help='The distance between the starts of adjacent bands or points in [...]', minimum=0)
    reverse = jst.JSONBoolean(help='If true, reverses the order of the scale range. __Default [...]')
    round = jst.JSONBoolean(help='If `true`, rounds numeric output values to integers. This can be [...]')
    scheme = jst.JSONAnyOf([jst.JSONString(), jst.JSONInstance(_localname('ExtendedScheme'))])
    type = ScaleType()
    zero = jst.JSONBoolean(help='If `true`, ensures that a zero baseline value is included in the [...]')

    def __init__(self, clamp=jst.undefined, domain=jst.undefined, exponent=jst.undefined, interpolate=jst.undefined, nice=jst.undefined, padding=jst.undefined, paddingInner=jst.undefined, paddingOuter=jst.undefined, range=jst.undefined, rangeStep=jst.undefined, reverse=jst.undefined, round=jst.undefined, scheme=jst.undefined, type=jst.undefined, zero=jst.undefined, **kwargs):
        kwds = dict(clamp=clamp, domain=domain, exponent=exponent, interpolate=interpolate, nice=nice, padding=padding, paddingInner=paddingInner, paddingOuter=paddingOuter, range=range, rangeStep=rangeStep, reverse=reverse, round=round, scheme=scheme, type=type, zero=zero)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Scale, self).__init__(**kwargs)


class ScaleConfig(jst.JSONHasTraits):
    """ScaleConfig class

    

    Attributes
    ----------
    bandPaddingInner : number
        Default inner padding for `x` and `y` band-ordinal scales.
        __Default value:__ `0.1`
    bandPaddingOuter : number
        Default outer padding for `x` and `y` band-ordinal scales.
        If not specified, by default, band scale's paddingOuter is
        paddingInner/2.
    clamp : boolean
        If true, values that exceed the data domain are clamped to
        either the minimum or maximum range value
    maxBandSize : number
        The default max value for mapping quantitative fields to bar's
        size/bandSize.
        If undefined (default), we will use bandSize - 1.
    maxFontSize : number
        The default max value for mapping quantitative fields to
        text's size/fontSize.
        If undefined (default), we will use bandSize - 1.
        __Default value:__ `40`
    maxOpacity : number
        Default max opacity for mapping a field to opacity.
        __Default value:__ `0.8`
    maxSize : number
        Default max value for point size scale.
    maxStrokeWidth : number
        Default max strokeWidth for strokeWidth  (or rule/line's size)
        scale.
        __Default value:__ `4`
    minBandSize : number
        The default min value for mapping quantitative fields to bar
        and tick's size/bandSize scale with zero=false
        If undefined (default), we will use the `continuousBandSize`
        value for bar and 3 for ticks.
    minFontSize : number
        The default min value for mapping quantitative fields to
        tick's size/fontSize scale with zero=false
        __Default value:__ `8`
    minOpacity : number
        Default minimum opacity for mapping a field to opacity.
        __Default value:__ `0.3`
    minSize : number
        Default minimum value for point size scale with zero=false.
        __Default value:__ `9`
    minStrokeWidth : number
        Default minimum strokeWidth for strokeWidth (or rule/line's
        size) scale with zero=false.
        __Default value:__ `1`
    pointPadding : number
        Default outer padding for `x` and `y` point-ordinal scales.
        __Default value:__ `0.5`
    rangeStep : ['number', 'null']
        Default range step for (1) `y` ordinal scale,
        and (2) `x` ordinal scale when the mark is not `text`.
        __Default value:__ `21`
    round : boolean
        If true, rounds numeric output values to integers.
        This can be helpful for snapping to the pixel grid.
        (Only available for `x`, `y`, `size`, `row`, and `column`
        scales.)
    shapes : Array(string)
        The default collection of symbol shapes for mapping nominal
        fields to shapes of point marks (i.e., range of a `shape`
        scale).
        Each value should be one of: `"circle"`, `"square"`,
        `"cross"`, `"diamond"`, `"triangle-up"`, or `"triangle-down"`,
        or a custom SVG path.
        __Default value:__ `["circle", "square", "cross", "diamond",
        "triangle-up", "triangle-down"]`
    textXRangeStep : number
        Default range step for `x` ordinal scale when is mark is
        `text`.
        __Default value:__ `90`
    useUnaggregatedDomain : boolean
        Use the source data range before aggregation as scale domain
        instead of aggregated data for aggregate axis.
        This property only works with aggregate functions that produce
        values within the raw data domain (`"mean"`, `"average"`,
        `"median"`, `"q1"`, `"q3"`, `"min"`, `"max"`). For other
        aggregations that produce values outside of the raw data
        domain (e.g. `"count"`, `"sum"`), this property is ignored.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    bandPaddingInner = jst.JSONNumber(help='Default inner padding for `x` and `y` band-ordinal scales. [...]', maximum=1, minimum=0)
    bandPaddingOuter = jst.JSONNumber(help='Default outer padding for `x` and `y` band-ordinal scales. If [...]', maximum=1, minimum=0)
    clamp = jst.JSONBoolean(help='If true, values that exceed the data domain are clamped to [...]')
    maxBandSize = jst.JSONNumber(help="The default max value for mapping quantitative fields to bar's [...]", minimum=0)
    maxFontSize = jst.JSONNumber(help="The default max value for mapping quantitative fields to text's [...]", minimum=0)
    maxOpacity = jst.JSONNumber(help='Default max opacity for mapping a field to opacity. __Default [...]', maximum=1, minimum=0)
    maxSize = jst.JSONNumber(help='Default max value for point size scale.', minimum=0)
    maxStrokeWidth = jst.JSONNumber(help="Default max strokeWidth for strokeWidth (or rule/line's size) [...]", minimum=0)
    minBandSize = jst.JSONNumber(help='The default min value for mapping quantitative fields to bar and [...]', minimum=0)
    minFontSize = jst.JSONNumber(help="The default min value for mapping quantitative fields to tick's [...]", minimum=0)
    minOpacity = jst.JSONNumber(help='Default minimum opacity for mapping a field to opacity. [...]', maximum=1, minimum=0)
    minSize = jst.JSONNumber(help='Default minimum value for point size scale with zero=false. [...]', minimum=0)
    minStrokeWidth = jst.JSONNumber(help="Default minimum strokeWidth for strokeWidth (or rule/line's [...]", minimum=0)
    pointPadding = jst.JSONNumber(help='Default outer padding for `x` and `y` point-ordinal scales. [...]', maximum=1, minimum=0)
    rangeStep = jst.JSONNumber(allow_none=True, help='Default range step for (1) `y` ordinal scale, and (2) `x` [...]', minimum=0)
    round = jst.JSONBoolean(help='If true, rounds numeric output values to integers. This can be [...]')
    shapes = jst.JSONArray(jst.JSONString(), help='The default collection of symbol shapes for mapping nominal [...]')
    textXRangeStep = jst.JSONNumber(help='Default range step for `x` ordinal scale when is mark is `text`. [...]', minimum=0)
    useUnaggregatedDomain = jst.JSONBoolean(help='Use the source data range before aggregation as scale domain [...]')

    def __init__(self, bandPaddingInner=jst.undefined, bandPaddingOuter=jst.undefined, clamp=jst.undefined, maxBandSize=jst.undefined, maxFontSize=jst.undefined, maxOpacity=jst.undefined, maxSize=jst.undefined, maxStrokeWidth=jst.undefined, minBandSize=jst.undefined, minFontSize=jst.undefined, minOpacity=jst.undefined, minSize=jst.undefined, minStrokeWidth=jst.undefined, pointPadding=jst.undefined, rangeStep=jst.undefined, round=jst.undefined, shapes=jst.undefined, textXRangeStep=jst.undefined, useUnaggregatedDomain=jst.undefined, **kwargs):
        kwds = dict(bandPaddingInner=bandPaddingInner, bandPaddingOuter=bandPaddingOuter, clamp=clamp, maxBandSize=maxBandSize, maxFontSize=maxFontSize, maxOpacity=maxOpacity, maxSize=maxSize, maxStrokeWidth=maxStrokeWidth, minBandSize=minBandSize, minFontSize=minFontSize, minOpacity=minOpacity, minSize=minSize, minStrokeWidth=minStrokeWidth, pointPadding=pointPadding, rangeStep=rangeStep, round=round, shapes=shapes, textXRangeStep=textXRangeStep, useUnaggregatedDomain=useUnaggregatedDomain)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ScaleConfig, self).__init__(**kwargs)


class ScaleFieldDef(jst.JSONHasTraits):
    """ScaleFieldDef class

    

    Attributes
    ----------
    aggregate : AnyOf([string, string])
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        __Default value:__ `undefined` (None)
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    field : AnyOf([string, RepeatRef])
        __Required.__ Name of the field from which to pull a data
        value.
        __Note:__ `field` is not required if `aggregate` is `count`.
    scale : Scale
        
    sort : AnyOf([SortField, AnyOf([string, string, null])])
        Sort order for a field with discrete domain.
        This can be `"ascending"`, `"descending"`, `null`, or a [sort
        field definition object](sort.html#sort-field) for sorting by
        an aggregate calculation of a specified sort field.
        __Note:__ For fields with continuous domain, please use
        `"scale": {"reverse": true}` to flip the scale instead.
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
        __Default value:__ `undefined` (None)
    type : string
        The encoded field's type of measurement. This can be either a
        full type
        name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and
        `"nominal"`)
        or an initial character of the type name (`"Q"`, `"T"`, `"O"`,
        `"N"`).
        This property is case-insensitive.
    """
    _additional_traits = False
    _required_traits = ['type']
    _trait_name_map = {}
    aggregate = jst.JSONAnyOf([AggregateOp(), BOXPLOT()], help='Aggregation function for the field (e.g., `mean`, `sum`, [...]')
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    field = jst.JSONAnyOf([jst.JSONString(), jst.JSONInstance(_localname('RepeatRef'))])
    scale = jst.JSONInstance(_localname('Scale'))
    sort = jst.JSONAnyOf([jst.JSONInstance(_localname('SortField')), jst.JSONAnyOf([jst.JSONEnum(['ascending']), jst.JSONEnum(['descending']), jst.JSONNull()])], help='Sort order for a field with discrete domain. This can be [...]')
    timeUnit = TimeUnit()
    type = Type(help='Constants and utilities for data type Data type based on level [...]')

    def __init__(self, aggregate=jst.undefined, bin=jst.undefined, field=jst.undefined, scale=jst.undefined, sort=jst.undefined, timeUnit=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, bin=bin, field=field, scale=scale, sort=sort, timeUnit=timeUnit, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ScaleFieldDef, self).__init__(**kwargs)


class SelectionAnd(jst.JSONHasTraits):
    """SelectionAnd class

    

    Attributes
    ----------
    and_ : Array(AnyOf([SelectionNot, SelectionAnd, SelectionOr, string]))
        
    """
    _additional_traits = False
    _required_traits = ['and']
    _trait_name_map = {'and_': 'and'}
    and_ = jst.JSONArray(jst.JSONAnyOf([jst.JSONInstance(_localname('SelectionNot')), jst.JSONInstance(_localname('SelectionAnd')), jst.JSONInstance(_localname('SelectionOr')), jst.JSONString()]))

    def __init__(self, and_=jst.undefined, **kwargs):
        kwds = dict(and_=and_)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(SelectionAnd, self).__init__(**kwargs)


class SelectionConfig(jst.JSONHasTraits):
    """SelectionConfig class

    

    Attributes
    ----------
    interval : IntervalSelectionConfig
        
    multi : MultiSelectionConfig
        
    single : SingleSelectionConfig
        
    """
    _additional_traits = False
    _required_traits = ['single', 'multi', 'interval']
    _trait_name_map = {}
    interval = jst.JSONInstance(_localname('IntervalSelectionConfig'))
    multi = jst.JSONInstance(_localname('MultiSelectionConfig'))
    single = jst.JSONInstance(_localname('SingleSelectionConfig'))

    def __init__(self, interval=jst.undefined, multi=jst.undefined, single=jst.undefined, **kwargs):
        kwds = dict(interval=interval, multi=multi, single=single)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(SelectionConfig, self).__init__(**kwargs)


class SelectionFilter(jst.JSONHasTraits):
    """SelectionFilter class

    

    Attributes
    ----------
    selection : AnyOf([SelectionNot, SelectionAnd, SelectionOr, string])
        Filter using a selection name.
    """
    _additional_traits = False
    _required_traits = ['selection']
    _trait_name_map = {}
    selection = jst.JSONAnyOf([jst.JSONInstance(_localname('SelectionNot')), jst.JSONInstance(_localname('SelectionAnd')), jst.JSONInstance(_localname('SelectionOr')), jst.JSONString()])

    def __init__(self, selection=jst.undefined, **kwargs):
        kwds = dict(selection=selection)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(SelectionFilter, self).__init__(**kwargs)


class SelectionNot(jst.JSONHasTraits):
    """SelectionNot class

    

    Attributes
    ----------
    not_ : AnyOf([SelectionNot, SelectionAnd, SelectionOr, string])
        
    """
    _additional_traits = False
    _required_traits = ['not']
    _trait_name_map = {'not_': 'not'}
    not_ = jst.JSONAnyOf([jst.JSONInstance(_localname('SelectionNot')), jst.JSONInstance(_localname('SelectionAnd')), jst.JSONInstance(_localname('SelectionOr')), jst.JSONString()])

    def __init__(self, not_=jst.undefined, **kwargs):
        kwds = dict(not_=not_)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(SelectionNot, self).__init__(**kwargs)


class SelectionOr(jst.JSONHasTraits):
    """SelectionOr class

    

    Attributes
    ----------
    or_ : Array(AnyOf([SelectionNot, SelectionAnd, SelectionOr, string]))
        
    """
    _additional_traits = False
    _required_traits = ['or']
    _trait_name_map = {'or_': 'or'}
    or_ = jst.JSONArray(jst.JSONAnyOf([jst.JSONInstance(_localname('SelectionNot')), jst.JSONInstance(_localname('SelectionAnd')), jst.JSONInstance(_localname('SelectionOr')), jst.JSONString()]))

    def __init__(self, or_=jst.undefined, **kwargs):
        kwds = dict(or_=or_)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(SelectionOr, self).__init__(**kwargs)


class SingleSelection(jst.JSONHasTraits):
    """SingleSelection class

    

    Attributes
    ----------
    bind : AnyOf([VgBinding, Mapping])
        Establish a two-way binding between a single selection and
        input elements
        (also known as dynamic query widgets). A binding takes the
        form of
        Vega's [input element binding
        definition](https://vega.github.io/vega/docs/signals/#bind)
        or can be a mapping between projected field/encodings and
        binding definitions.
    encodings : Array(string)
        An array of encoding channels. The corresponding data field
        values
        must match for a data tuple to fall within the selection.
    fields : Array(string)
        An array of field names whose values must match for a data
        tuple to
        fall within the selection.
    nearest : boolean
        When true, an invisible voronoi diagram is computed to
        accelerate discrete
        selection. The data value _nearest_ the mouse cursor is added
        to the selection.
    on : Mapping
        A Vega event stream (object or selector) that triggers the
        selection.
    resolve : string
        With layered and multi-view displays, a strategy that
        determines how
        selections' data queries are resolved when applied in a filter
        transform,
        conditional encoding rule, or scale domain. One of: "global",
        "union",
        "intersect", "union_others", or "intersect_others".
        __global__: Only one instance of the selection exists across
        all
        views. When a user interacts within a new view, any previous
        selections
        are overridden.
        __union__: Each view contains its own selection, and a data
        value is
        considered to be selected if it falls within _any_ of these
        selection
        instances.
        __intersect__: Each view contains its own selection, and a
        data value is
        considered to be selected if it falls within _all_ of these
        selection
        instances.
    type : string
        
    """
    _additional_traits = False
    _required_traits = ['type']
    _trait_name_map = {}
    bind = jst.JSONAnyOf([jst.JSONInstance(_localname('VgBinding')), jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': [jst.JSONInstance(_localname('VgBinding'))], '_required_traits': []}))], help='Establish a two-way binding between a single selection and input [...]')
    encodings = jst.JSONArray(SingleDefChannel(), help='An array of encoding channels. The corresponding data field [...]')
    fields = jst.JSONArray(jst.JSONString(), help='An array of field names whose values must match for a data tuple [...]')
    nearest = jst.JSONBoolean(help='When true, an invisible voronoi diagram is computed to [...]')
    on = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': True, '_required_traits': []}), help='A Vega event stream (object or selector) that triggers the selection.')
    resolve = SelectionResolution()
    type = jst.JSONEnum(['single'])

    def __init__(self, bind=jst.undefined, encodings=jst.undefined, fields=jst.undefined, nearest=jst.undefined, on=jst.undefined, resolve=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(bind=bind, encodings=encodings, fields=fields, nearest=nearest, on=on, resolve=resolve, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(SingleSelection, self).__init__(**kwargs)


class SingleSelectionConfig(jst.JSONHasTraits):
    """SingleSelectionConfig class

    

    Attributes
    ----------
    bind : AnyOf([VgBinding, Mapping])
        Establish a two-way binding between a single selection and
        input elements
        (also known as dynamic query widgets). A binding takes the
        form of
        Vega's [input element binding
        definition](https://vega.github.io/vega/docs/signals/#bind)
        or can be a mapping between projected field/encodings and
        binding definitions.
    encodings : Array(string)
        An array of encoding channels. The corresponding data field
        values
        must match for a data tuple to fall within the selection.
    fields : Array(string)
        An array of field names whose values must match for a data
        tuple to
        fall within the selection.
    nearest : boolean
        When true, an invisible voronoi diagram is computed to
        accelerate discrete
        selection. The data value _nearest_ the mouse cursor is added
        to the selection.
    on : Mapping
        A Vega event stream (object or selector) that triggers the
        selection.
    resolve : string
        With layered and multi-view displays, a strategy that
        determines how
        selections' data queries are resolved when applied in a filter
        transform,
        conditional encoding rule, or scale domain. One of: "global",
        "union",
        "intersect", "union_others", or "intersect_others".
        __global__: Only one instance of the selection exists across
        all
        views. When a user interacts within a new view, any previous
        selections
        are overridden.
        __union__: Each view contains its own selection, and a data
        value is
        considered to be selected if it falls within _any_ of these
        selection
        instances.
        __intersect__: Each view contains its own selection, and a
        data value is
        considered to be selected if it falls within _all_ of these
        selection
        instances.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    bind = jst.JSONAnyOf([jst.JSONInstance(_localname('VgBinding')), jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': [jst.JSONInstance(_localname('VgBinding'))], '_required_traits': []}))], help='Establish a two-way binding between a single selection and input [...]')
    encodings = jst.JSONArray(SingleDefChannel(), help='An array of encoding channels. The corresponding data field [...]')
    fields = jst.JSONArray(jst.JSONString(), help='An array of field names whose values must match for a data tuple [...]')
    nearest = jst.JSONBoolean(help='When true, an invisible voronoi diagram is computed to [...]')
    on = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': True, '_required_traits': []}), help='A Vega event stream (object or selector) that triggers the selection.')
    resolve = SelectionResolution()

    def __init__(self, bind=jst.undefined, encodings=jst.undefined, fields=jst.undefined, nearest=jst.undefined, on=jst.undefined, resolve=jst.undefined, **kwargs):
        kwds = dict(bind=bind, encodings=encodings, fields=fields, nearest=nearest, on=on, resolve=resolve)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(SingleSelectionConfig, self).__init__(**kwargs)


class SortField(jst.JSONHasTraits):
    """SortField class

    

    Attributes
    ----------
    field : string
        The field name to aggregate over.
    op : string
        The sort aggregation operator
    order : AnyOf([string, string, null])
        
    """
    _additional_traits = False
    _required_traits = ['op']
    _trait_name_map = {}
    field = jst.JSONString(help='The field name to aggregate over.')
    op = AggregateOp()
    order = jst.JSONAnyOf([jst.JSONEnum(['ascending']), jst.JSONEnum(['descending']), jst.JSONNull()])

    def __init__(self, field=jst.undefined, op=jst.undefined, order=jst.undefined, **kwargs):
        kwds = dict(field=field, op=op, order=order)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(SortField, self).__init__(**kwargs)


class SpatialResolve(jst.JSONHasTraits):
    """SpatialResolve class

    

    Attributes
    ----------
    axis : string
        
    scale : string
        
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    axis = ResolveMode()
    scale = ResolveMode()

    def __init__(self, axis=jst.undefined, scale=jst.undefined, **kwargs):
        kwds = dict(axis=axis, scale=scale)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(SpatialResolve, self).__init__(**kwargs)


class StringValueDef(jst.JSONHasTraits):
    """StringValueDef class

    Definition object for a constant value of an encoding channel.

    Attributes
    ----------
    value : string
        A constant value in visual domain.
    """
    _additional_traits = False
    _required_traits = ['value']
    _trait_name_map = {}
    value = jst.JSONString(help='A constant value in visual domain.')

    def __init__(self, value=jst.undefined, **kwargs):
        kwds = dict(value=value)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(StringValueDef, self).__init__(**kwargs)


class Summarize(jst.JSONHasTraits):
    """Summarize class

    

    Attributes
    ----------
    aggregate : string
        The aggregation operations to apply to the fields, such as
        sum, average or count.
        See the [full list of supported aggregation
        operations](https://vega.github.io/vega-
        lite/docs/aggregate.html#supported-aggregation-operations)
        for more information.
    as_ : string
        The output field names to use for each aggregated field.
    field : string
        The data field for which to compute aggregate function.
    """
    _additional_traits = False
    _required_traits = ['aggregate', 'field', 'as']
    _trait_name_map = {'as_': 'as'}
    aggregate = AggregateOp()
    as_ = jst.JSONString(help='The output field names to use for each aggregated field.')
    field = jst.JSONString(help='The data field for which to compute aggregate function.')

    def __init__(self, aggregate=jst.undefined, as_=jst.undefined, field=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, as_=as_, field=field)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(Summarize, self).__init__(**kwargs)


class SummarizeTransform(jst.JSONHasTraits):
    """SummarizeTransform class

    

    Attributes
    ----------
    groupby : Array(string)
        The data fields to group by. If not specified, a single group
        containing all data objects will be used.
    summarize : Array(Summarize)
        Array of objects that define aggregate fields.
    """
    _additional_traits = False
    _required_traits = ['summarize']
    _trait_name_map = {}
    groupby = jst.JSONArray(jst.JSONString(), help='The data fields to group by. If not specified, a single group [...]')
    summarize = jst.JSONArray(jst.JSONInstance(_localname('Summarize')), help='Array of objects that define aggregate fields.')

    def __init__(self, groupby=jst.undefined, summarize=jst.undefined, **kwargs):
        kwds = dict(groupby=groupby, summarize=summarize)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(SummarizeTransform, self).__init__(**kwargs)


class TextConfig(jst.JSONHasTraits):
    """TextConfig class

    

    Attributes
    ----------
    align : string
        The horizontal text alignment.
    angle : number
        The rotation angle of the text, in degrees.
    baseline : string
        The vertical alignment of the text. One of `"top"`,
        `"middle"`, `"bottom"`.
        __Default value:__ `"middle"`
    color : string
        Default color.
        __Default value:__ <span style="color:
        #4682b4;">&#9632;</span> `"#4682b4"`
    dx : number
        The horizontal offset in pixels (before rotation), between the
        text and anchor point.
    dy : number
        The vertical offset in pixels (before rotation), between the
        text and anchor point.
    fill : string
        Default Fill Color.  This has higher precedence than
        config.color
        __Default value:__ (None)
    fillOpacity : number
        The fill opacity (value between [0,1]).
        __Default value:__ `1`
    filled : boolean
        Whether the mark's color should be used as fill color instead
        of stroke color.
        __Default value:__ `true` for all marks except `point` and
        `false` for `point`.
        __Applicable for:__ `bar`, `point`, `circle`, `square`, and
        `area` marks.
    font : string
        The typeface to set the text in (e.g., `"Helvetica Neue"`).
    fontSize : number
        The font size, in pixels.
    fontStyle : string
        The font style (e.g., `"italic"`).
    fontWeight : AnyOf([string, number])
        The font weight (e.g., `"bold"`).
    interpolate : string
        The line interpolation method to use for line and area marks.
        One of the following:
        - `"linear"`: piecewise linear segments, as in a polyline.
        - `"linear-closed"`: close the linear segments to form a
          polygon.
        - `"step"`: alternate between horizontal and vertical
          segments, as in a step function.
        - `"step-before"`: alternate between vertical and horizontal
          segments, as in a step function.
        - `"step-after"`: alternate between horizontal and vertical
          segments, as in a step function.
        - `"basis"`: a B-spline, with control point duplication on
          the ends.
        - `"basis-open"`: an open B-spline; may not intersect the
          start or end.
        - `"basis-closed"`: a closed B-spline, as in a loop.
        - `"cardinal"`: a Cardinal spline, with control point
          duplication on the ends.
        - `"cardinal-open"`: an open Cardinal spline; may not
          intersect the start or end, but will intersect other control
          points.
        - `"cardinal-closed"`: a closed Cardinal spline, as in a
          loop.
        - `"bundle"`: equivalent to basis, except the tension
          parameter is used to straighten the spline.
        - `"monotone"`: cubic interpolation that preserves
          monotonicity in y.
    opacity : number
        The overall opacity (value between [0,1]).
        __Default value:__ `0.7` for non-aggregate plots with `point`,
        `tick`, `circle`, or `square` marks or layered `bar` charts
        and `1` otherwise.
    orient : string
        The orientation of a non-stacked bar, tick, area, and line
        charts.
        The value is either horizontal (default) or vertical.
        - For bar, rule and tick, this determines whether the size
          of the bar and tick
        should be applied to x or y dimension.
        - For area, this property determines the orient property of
          the Vega output.
        - For line, this property determines the sort order of the
          points in the line
        if `config.sortLineBy` is not specified.
        For stacked charts, this is always determined by the
        orientation of the stack;
        therefore explicitly specified value will be ignored.
    radius : number
        Polar coordinate radial offset, in pixels, of the text label
        from the origin determined by the `x` and `y` properties.
    shape : string
        The default symbol shape to use. One of: `"circle"` (default),
        `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, or
        `"triangle-down"`, or a custom SVG path.
        __Default value:__ `"circle"`
    shortTimeLabels : boolean
        Whether month names and weekday names should be abbreviated.
    size : number
        The pixel area each the point/circle/square.
        For example: in the case of circles, the radius is determined
        in part by the square root of the size value.
        __Default value:__ `30`
    stroke : string
        Default Stroke Color.  This has higher precedence than
        config.color
        __Default value:__ (None)
    strokeDash : Array(number)
        An array of alternating stroke, space lengths for creating
        dashed or dotted lines.
    strokeDashOffset : number
        The offset (in pixels) into which to begin drawing with the
        stroke dash array.
    strokeOpacity : number
        The stroke opacity (value between [0,1]).
        __Default value:__ `1`
    strokeWidth : number
        The stroke width, in pixels.
    tension : number
        Depending on the interpolation type, sets the tension
        parameter (for line and area marks).
    text : string
        Placeholder text if the `text` channel is not specified
    theta : number
        Polar coordinate angle, in radians, of the text label from the
        origin determined by the `x` and `y` properties. Values for
        `theta` follow the same convention of `arc` mark `startAngle`
        and `endAngle` properties: angles are measured in radians,
        with `0` indicating "north".
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    align = jst.JSONEnum(['left', 'center', 'right'], help='The horizontal text alignment.')
    angle = jst.JSONNumber(help='The rotation angle of the text, in degrees.', maximum=360, minimum=0)
    baseline = VerticalAlign()
    color = jst.JSONString(help='Default color. __Default value:__ <span style="color: [...]')
    dx = jst.JSONNumber(help='The horizontal offset in pixels (before rotation), between the [...]')
    dy = jst.JSONNumber(help='The vertical offset in pixels (before rotation), between the [...]')
    fill = jst.JSONString(help='Default Fill Color. This has higher precedence than config.color [...]')
    fillOpacity = jst.JSONNumber(help='The fill opacity (value between [0,1]). __Default value:__ `1`', maximum=1, minimum=0)
    filled = jst.JSONBoolean(help="Whether the mark's color should be used as fill color instead of [...]")
    font = jst.JSONString(help='The typeface to set the text in (e.g., `"Helvetica Neue"`).')
    fontSize = jst.JSONNumber(help='The font size, in pixels.', minimum=0)
    fontStyle = FontStyle()
    fontWeight = jst.JSONAnyOf([FontWeight(), jst.JSONNumber(maximum=900, minimum=100)], help='The font weight (e.g., `"bold"`).')
    interpolate = Interpolate()
    opacity = jst.JSONNumber(help='The overall opacity (value between [0,1]). __Default value:__ [...]', maximum=1, minimum=0)
    orient = Orient()
    radius = jst.JSONNumber(help='Polar coordinate radial offset, in pixels, of the text label [...]', minimum=0)
    shape = jst.JSONString(help='The default symbol shape to use. One of: `"circle"` (default), [...]')
    shortTimeLabels = jst.JSONBoolean(help='Whether month names and weekday names should be abbreviated.')
    size = jst.JSONNumber(help='The pixel area each the point/circle/square. For example: in the [...]', minimum=0)
    stroke = jst.JSONString(help='Default Stroke Color. This has higher precedence than [...]')
    strokeDash = jst.JSONArray(jst.JSONNumber(), help='An array of alternating stroke, space lengths for creating [...]')
    strokeDashOffset = jst.JSONNumber(help='The offset (in pixels) into which to begin drawing with the [...]')
    strokeOpacity = jst.JSONNumber(help='The stroke opacity (value between [0,1]). __Default value:__ `1`', maximum=1, minimum=0)
    strokeWidth = jst.JSONNumber(help='The stroke width, in pixels.', minimum=0)
    tension = jst.JSONNumber(help='Depending on the interpolation type, sets the tension parameter [...]', maximum=1, minimum=0)
    text = jst.JSONString(help='Placeholder text if the `text` channel is not specified')
    theta = jst.JSONNumber(help='Polar coordinate angle, in radians, of the text label from the [...]')

    def __init__(self, align=jst.undefined, angle=jst.undefined, baseline=jst.undefined, color=jst.undefined, dx=jst.undefined, dy=jst.undefined, fill=jst.undefined, fillOpacity=jst.undefined, filled=jst.undefined, font=jst.undefined, fontSize=jst.undefined, fontStyle=jst.undefined, fontWeight=jst.undefined, interpolate=jst.undefined, opacity=jst.undefined, orient=jst.undefined, radius=jst.undefined, shape=jst.undefined, shortTimeLabels=jst.undefined, size=jst.undefined, stroke=jst.undefined, strokeDash=jst.undefined, strokeDashOffset=jst.undefined, strokeOpacity=jst.undefined, strokeWidth=jst.undefined, tension=jst.undefined, text=jst.undefined, theta=jst.undefined, **kwargs):
        kwds = dict(align=align, angle=angle, baseline=baseline, color=color, dx=dx, dy=dy, fill=fill, fillOpacity=fillOpacity, filled=filled, font=font, fontSize=fontSize, fontStyle=fontStyle, fontWeight=fontWeight, interpolate=interpolate, opacity=opacity, orient=orient, radius=radius, shape=shape, shortTimeLabels=shortTimeLabels, size=size, stroke=stroke, strokeDash=strokeDash, strokeDashOffset=strokeDashOffset, strokeOpacity=strokeOpacity, strokeWidth=strokeWidth, tension=tension, text=text, theta=theta)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(TextConfig, self).__init__(**kwargs)


class TextFieldDef(jst.JSONHasTraits):
    """TextFieldDef class

    

    Attributes
    ----------
    aggregate : AnyOf([string, string])
        Aggregation function for the field
        (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
        __Default value:__ `undefined` (None)
    bin : AnyOf([boolean, Bin])
        Flag for binning a `quantitative` field, or a bin property
        object
        for binning parameters.
    field : AnyOf([string, RepeatRef])
        __Required.__ Name of the field from which to pull a data
        value.
        __Note:__ `field` is not required if `aggregate` is `count`.
    format : string
        The formatting pattern for text value. If not defined, this
        will be determined automatically.
    timeUnit : string
        Time unit for a `temporal` field  (e.g., `year`, `yearmonth`,
        `month`, `hour`).
        __Default value:__ `undefined` (None)
    type : string
        The encoded field's type of measurement. This can be either a
        full type
        name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and
        `"nominal"`)
        or an initial character of the type name (`"Q"`, `"T"`, `"O"`,
        `"N"`).
        This property is case-insensitive.
    """
    _additional_traits = False
    _required_traits = ['type']
    _trait_name_map = {}
    aggregate = jst.JSONAnyOf([AggregateOp(), BOXPLOT()], help='Aggregation function for the field (e.g., `mean`, `sum`, [...]')
    bin = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONInstance(_localname('Bin'))], help='Flag for binning a `quantitative` field, or a bin property [...]')
    field = jst.JSONAnyOf([jst.JSONString(), jst.JSONInstance(_localname('RepeatRef'))])
    format = jst.JSONString(help='The formatting pattern for text value. If not defined, this will [...]')
    timeUnit = TimeUnit()
    type = Type(help='Constants and utilities for data type Data type based on level [...]')

    def __init__(self, aggregate=jst.undefined, bin=jst.undefined, field=jst.undefined, format=jst.undefined, timeUnit=jst.undefined, type=jst.undefined, **kwargs):
        kwds = dict(aggregate=aggregate, bin=bin, field=field, format=format, timeUnit=timeUnit, type=type)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(TextFieldDef, self).__init__(**kwargs)


class TextValueDef(jst.JSONHasTraits):
    """TextValueDef class

    Definition object for a constant value of an encoding channel.

    Attributes
    ----------
    value : ['string', 'number', 'boolean']
        A constant value in visual domain.
    """
    _additional_traits = False
    _required_traits = ['value']
    _trait_name_map = {}
    value = jst.JSONUnion([jst.JSONString(), jst.JSONNumber(), jst.JSONBoolean()], help='A constant value in visual domain.')

    def __init__(self, value=jst.undefined, **kwargs):
        kwds = dict(value=value)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(TextValueDef, self).__init__(**kwargs)


class TickConfig(jst.JSONHasTraits):
    """TickConfig class

    

    Attributes
    ----------
    align : string
        The horizontal alignment of the text. One of `"left"`,
        `"right"`, `"center"`.
    angle : number
        The rotation angle of the text, in degrees.
    bandSize : number
        The width of the ticks.
        If this value is undefined (by default,), we use 2/3 of
        rangeStep by default.
    baseline : string
        The vertical alignment of the text. One of `"top"`,
        `"middle"`, `"bottom"`.
        __Default value:__ `"middle"`
    color : string
        Default color.
        __Default value:__ <span style="color:
        #4682b4;">&#9632;</span> `"#4682b4"`
    dx : number
        The horizontal offset, in pixels, between the text label and
        its anchor point. The offset is applied after rotation by the
        _angle_ property.
    dy : number
        The vertical offset, in pixels, between the text label and its
        anchor point. The offset is applied after rotation by the
        _angle_ property.
    fill : string
        Default Fill Color.  This has higher precedence than
        config.color
        __Default value:__ (None)
    fillOpacity : number
        The fill opacity (value between [0,1]).
        __Default value:__ `1`
    filled : boolean
        Whether the mark's color should be used as fill color instead
        of stroke color.
        __Default value:__ `true` for all marks except `point` and
        `false` for `point`.
        __Applicable for:__ `bar`, `point`, `circle`, `square`, and
        `area` marks.
    font : string
        The typeface to set the text in (e.g., `"Helvetica Neue"`).
    fontSize : number
        The font size, in pixels.
    fontStyle : string
        The font style (e.g., `"italic"`).
    fontWeight : AnyOf([string, number])
        The font weight (e.g., `"bold"`).
    interpolate : string
        The line interpolation method to use for line and area marks.
        One of the following:
        - `"linear"`: piecewise linear segments, as in a polyline.
        - `"linear-closed"`: close the linear segments to form a
          polygon.
        - `"step"`: alternate between horizontal and vertical
          segments, as in a step function.
        - `"step-before"`: alternate between vertical and horizontal
          segments, as in a step function.
        - `"step-after"`: alternate between horizontal and vertical
          segments, as in a step function.
        - `"basis"`: a B-spline, with control point duplication on
          the ends.
        - `"basis-open"`: an open B-spline; may not intersect the
          start or end.
        - `"basis-closed"`: a closed B-spline, as in a loop.
        - `"cardinal"`: a Cardinal spline, with control point
          duplication on the ends.
        - `"cardinal-open"`: an open Cardinal spline; may not
          intersect the start or end, but will intersect other control
          points.
        - `"cardinal-closed"`: a closed Cardinal spline, as in a
          loop.
        - `"bundle"`: equivalent to basis, except the tension
          parameter is used to straighten the spline.
        - `"monotone"`: cubic interpolation that preserves
          monotonicity in y.
    opacity : number
        The overall opacity (value between [0,1]).
        __Default value:__ `0.7` for non-aggregate plots with `point`,
        `tick`, `circle`, or `square` marks or layered `bar` charts
        and `1` otherwise.
    orient : string
        The orientation of a non-stacked bar, tick, area, and line
        charts.
        The value is either horizontal (default) or vertical.
        - For bar, rule and tick, this determines whether the size
          of the bar and tick
        should be applied to x or y dimension.
        - For area, this property determines the orient property of
          the Vega output.
        - For line, this property determines the sort order of the
          points in the line
        if `config.sortLineBy` is not specified.
        For stacked charts, this is always determined by the
        orientation of the stack;
        therefore explicitly specified value will be ignored.
    radius : number
        Polar coordinate radial offset, in pixels, of the text label
        from the origin determined by the `x` and `y` properties.
    shape : string
        The default symbol shape to use. One of: `"circle"` (default),
        `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, or
        `"triangle-down"`, or a custom SVG path.
        __Default value:__ `"circle"`
    size : number
        The pixel area each the point/circle/square.
        For example: in the case of circles, the radius is determined
        in part by the square root of the size value.
        __Default value:__ `30`
    stroke : string
        Default Stroke Color.  This has higher precedence than
        config.color
        __Default value:__ (None)
    strokeDash : Array(number)
        An array of alternating stroke, space lengths for creating
        dashed or dotted lines.
    strokeDashOffset : number
        The offset (in pixels) into which to begin drawing with the
        stroke dash array.
    strokeOpacity : number
        The stroke opacity (value between [0,1]).
        __Default value:__ `1`
    strokeWidth : number
        The stroke width, in pixels.
    tension : number
        Depending on the interpolation type, sets the tension
        parameter (for line and area marks).
    text : string
        Placeholder text if the `text` channel is not specified
    theta : number
        Polar coordinate angle, in radians, of the text label from the
        origin determined by the `x` and `y` properties. Values for
        `theta` follow the same convention of `arc` mark `startAngle`
        and `endAngle` properties: angles are measured in radians,
        with `0` indicating "north".
    thickness : number
        Thickness of the tick mark.
        __Default value:__  `1`
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    align = HorizontalAlign()
    angle = jst.JSONNumber(help='The rotation angle of the text, in degrees.', maximum=360, minimum=0)
    bandSize = jst.JSONNumber(help='The width of the ticks. If this value is undefined (by [...]', minimum=0)
    baseline = VerticalAlign()
    color = jst.JSONString(help='Default color. __Default value:__ <span style="color: [...]')
    dx = jst.JSONNumber(help='The horizontal offset, in pixels, between the text label and its [...]')
    dy = jst.JSONNumber(help='The vertical offset, in pixels, between the text label and its [...]')
    fill = jst.JSONString(help='Default Fill Color. This has higher precedence than config.color [...]')
    fillOpacity = jst.JSONNumber(help='The fill opacity (value between [0,1]). __Default value:__ `1`', maximum=1, minimum=0)
    filled = jst.JSONBoolean(help="Whether the mark's color should be used as fill color instead of [...]")
    font = jst.JSONString(help='The typeface to set the text in (e.g., `"Helvetica Neue"`).')
    fontSize = jst.JSONNumber(help='The font size, in pixels.', minimum=0)
    fontStyle = FontStyle()
    fontWeight = jst.JSONAnyOf([FontWeight(), jst.JSONNumber(maximum=900, minimum=100)], help='The font weight (e.g., `"bold"`).')
    interpolate = Interpolate()
    opacity = jst.JSONNumber(help='The overall opacity (value between [0,1]). __Default value:__ [...]', maximum=1, minimum=0)
    orient = Orient()
    radius = jst.JSONNumber(help='Polar coordinate radial offset, in pixels, of the text label [...]', minimum=0)
    shape = jst.JSONString(help='The default symbol shape to use. One of: `"circle"` (default), [...]')
    size = jst.JSONNumber(help='The pixel area each the point/circle/square. For example: in the [...]', minimum=0)
    stroke = jst.JSONString(help='Default Stroke Color. This has higher precedence than [...]')
    strokeDash = jst.JSONArray(jst.JSONNumber(), help='An array of alternating stroke, space lengths for creating [...]')
    strokeDashOffset = jst.JSONNumber(help='The offset (in pixels) into which to begin drawing with the [...]')
    strokeOpacity = jst.JSONNumber(help='The stroke opacity (value between [0,1]). __Default value:__ `1`', maximum=1, minimum=0)
    strokeWidth = jst.JSONNumber(help='The stroke width, in pixels.', minimum=0)
    tension = jst.JSONNumber(help='Depending on the interpolation type, sets the tension parameter [...]', maximum=1, minimum=0)
    text = jst.JSONString(help='Placeholder text if the `text` channel is not specified')
    theta = jst.JSONNumber(help='Polar coordinate angle, in radians, of the text label from the [...]')
    thickness = jst.JSONNumber(help='Thickness of the tick mark. __Default value:__ `1`', minimum=0)

    def __init__(self, align=jst.undefined, angle=jst.undefined, bandSize=jst.undefined, baseline=jst.undefined, color=jst.undefined, dx=jst.undefined, dy=jst.undefined, fill=jst.undefined, fillOpacity=jst.undefined, filled=jst.undefined, font=jst.undefined, fontSize=jst.undefined, fontStyle=jst.undefined, fontWeight=jst.undefined, interpolate=jst.undefined, opacity=jst.undefined, orient=jst.undefined, radius=jst.undefined, shape=jst.undefined, size=jst.undefined, stroke=jst.undefined, strokeDash=jst.undefined, strokeDashOffset=jst.undefined, strokeOpacity=jst.undefined, strokeWidth=jst.undefined, tension=jst.undefined, text=jst.undefined, theta=jst.undefined, thickness=jst.undefined, **kwargs):
        kwds = dict(align=align, angle=angle, bandSize=bandSize, baseline=baseline, color=color, dx=dx, dy=dy, fill=fill, fillOpacity=fillOpacity, filled=filled, font=font, fontSize=fontSize, fontStyle=fontStyle, fontWeight=fontWeight, interpolate=interpolate, opacity=opacity, orient=orient, radius=radius, shape=shape, size=size, stroke=stroke, strokeDash=strokeDash, strokeDashOffset=strokeDashOffset, strokeOpacity=strokeOpacity, strokeWidth=strokeWidth, tension=tension, text=text, theta=theta, thickness=thickness)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(TickConfig, self).__init__(**kwargs)


class TimeUnitTransform(jst.JSONHasTraits):
    """TimeUnitTransform class

    

    Attributes
    ----------
    as_ : string
        The output field to write the timeUnit value.
    field : string
        The data field to apply time unit.
    timeUnit : string
        The timeUnit.
    """
    _additional_traits = False
    _required_traits = ['timeUnit', 'field', 'as']
    _trait_name_map = {'as_': 'as'}
    as_ = jst.JSONString(help='The output field to write the timeUnit value.')
    field = jst.JSONString(help='The data field to apply time unit.')
    timeUnit = TimeUnit()

    def __init__(self, as_=jst.undefined, field=jst.undefined, timeUnit=jst.undefined, **kwargs):
        kwds = dict(as_=as_, field=field, timeUnit=timeUnit)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(TimeUnitTransform, self).__init__(**kwargs)


class TopLevelFacetedSpec(jst.JSONHasTraits):
    """TopLevelFacetedSpec class

    

    Attributes
    ----------
    schema : string
        URL to JSON schema for this Vega-Lite specification.
    autoResize : boolean
        Resize is a boolean indicating if autosize layout should be
        re-calculated on every update.
        __Default value__: `false`
    background : string
        CSS color property to use as the background of visualization.
        __Default value:__ none (transparent)
    config : Config
        Vega-Lite configuration object.  This property can only be
        defined at the top-level of a specification.
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
    facet : Facet
        
    name : string
        Name of the visualization for later reference.
    padding : AnyOf([number, Mapping])
        The default visualization padding, in pixels, from the edge of
        the visualization canvas to the data rectangle.  If a number,
        specifies padding for all sides.
        If an object, the value should have the format `{"left": 5,
        "top": 5, "right": 5, "bottom": 5}` to specify padding for
        each side of the visualization.
        __Default value__: `5`
    resolve : ResolveMapping
        
    spec : Spec
        
    transform : Array(Transform)
        An array of data transformations such as filter and new field
        calculation.
    """
    _additional_traits = False
    _required_traits = ['facet', 'spec']
    _trait_name_map = {'schema': '$schema'}
    schema = jst.JSONString(help='URL to JSON schema for this Vega-Lite specification.')
    autoResize = jst.JSONBoolean(help='Resize is a boolean indicating if autosize layout should be re- [...]')
    background = jst.JSONString(help='CSS color property to use as the background of visualization. [...]')
    config = jst.JSONInstance(_localname('Config'), help='Vega-Lite configuration object. This property can only be [...]')
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose.')
    facet = jst.JSONInstance(_localname('Facet'))
    name = jst.JSONString(help='Name of the visualization for later reference.')
    padding = jst.JSONAnyOf([jst.JSONNumber(), jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'right': jst.JSONNumber(), 'bottom': jst.JSONNumber(), '_required_traits': [], 'top': jst.JSONNumber(), '_additional_traits': False, 'left': jst.JSONNumber()}))])
    resolve = jst.JSONInstance(_localname('ResolveMapping'))
    spec = jst.JSONInstance(_localname('Spec'))
    transform = jst.JSONArray(jst.JSONInstance(_localname('Transform')), help='An array of data transformations such as filter and new field [...]')

    def __init__(self, schema=jst.undefined, autoResize=jst.undefined, background=jst.undefined, config=jst.undefined, data=jst.undefined, description=jst.undefined, facet=jst.undefined, name=jst.undefined, padding=jst.undefined, resolve=jst.undefined, spec=jst.undefined, transform=jst.undefined, **kwargs):
        kwds = dict(schema=schema, autoResize=autoResize, background=background, config=config, data=data, description=description, facet=facet, name=name, padding=padding, resolve=resolve, spec=spec, transform=transform)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(TopLevelFacetedSpec, self).__init__(**kwargs)


class TopLevelFacetedUnitSpec(jst.JSONHasTraits):
    """TopLevelFacetedUnitSpec class

    

    Attributes
    ----------
    schema : string
        URL to JSON schema for this Vega-Lite specification.
    autoResize : boolean
        Resize is a boolean indicating if autosize layout should be
        re-calculated on every update.
        __Default value__: `false`
    background : string
        CSS color property to use as the background of visualization.
        __Default value:__ none (transparent)
    config : Config
        Vega-Lite configuration object.  This property can only be
        defined at the top-level of a specification.
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
    encoding : EncodingWithFacet
        A key-value mapping between encoding channels and definition
        of fields.
    height : number
        The height of a visualization.
        __Default value:__
        - For y-axis with a continuous (non-ordinal) scale, the
          height will be the value of
          [`config.cell.height`](config.html#cell-config).
        - For y-axis with an ordinal scale: if
          [`rangeStep`](scale.html#ordinal) is a numeric value
          (default), the height is determined by the value of
          `rangeStep` and the cardinality of the field mapped to
          y-channel.   Otherwise, if the `rangeStep` is `null`, the
          height will be the value of
          [`config.cell.height`](config.html#cell-config).
        - If no field is mapped to `x` channel, the `height` will be
          the value of `rangeStep`.
        __Note__: For plot with `row` and `column` channels, this
        represents the height of a single cell.
    mark : AnyOf([AnyOf([string, string]), CompositeMarkDef, string, MarkDef])
        A string describing the mark type (one of `"bar"`, `"circle"`,
        `"square"`, `"tick"`, `"line"`,
        `"area"`, `"point"`, `"rule"`, and `"text"`) or a [mark
        definition object](mark.html#mark-def).
    name : string
        Name of the visualization for later reference.
    padding : AnyOf([number, Mapping])
        The default visualization padding, in pixels, from the edge of
        the visualization canvas to the data rectangle.  If a number,
        specifies padding for all sides.
        If an object, the value should have the format `{"left": 5,
        "top": 5, "right": 5, "bottom": 5}` to specify padding for
        each side of the visualization.
        __Default value__: `5`
    selection : Mapping
        A key-value mapping between selection names and definitions.
    transform : Array(Transform)
        An array of data transformations such as filter and new field
        calculation.
    width : number
        The width of a visualization.
        __Default value:__ This will be determined by the following
        rules:
        - For x-axis with a continuous (non-ordinal) scale, the
          width will be the value of
          [`config.cell.width`](config.html#cell-config).
        - For x-axis with an ordinal scale: if
          [`rangeStep`](scale.html#ordinal) is a numeric value
          (default), the width is determined by the value of
          `rangeStep` and the cardinality of the field mapped to
          x-channel.   Otherwise, if the `rangeStep` is `null`, the
          width will be the value of
          [`config.cell.width`](config.html#cell-config).
        - If no field is mapped to `x` channel, the `width` will be
          the value of
          [`config.scale.textXRangeStep`](size.html#default-width-and-
          height) for `text` mark and the value of `rangeStep` for
          other marks.
        __Note__: For plot with `row` and `column` channels, this
        represents the width of a single cell.
    """
    _additional_traits = False
    _required_traits = ['encoding', 'mark']
    _trait_name_map = {'schema': '$schema'}
    schema = jst.JSONString(help='URL to JSON schema for this Vega-Lite specification.')
    autoResize = jst.JSONBoolean(help='Resize is a boolean indicating if autosize layout should be re- [...]')
    background = jst.JSONString(help='CSS color property to use as the background of visualization. [...]')
    config = jst.JSONInstance(_localname('Config'), help='Vega-Lite configuration object. This property can only be [...]')
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose.')
    encoding = jst.JSONInstance(_localname('EncodingWithFacet'), help='A key-value mapping between encoding channels and definition of [...]')
    height = jst.JSONNumber(help='The height of a visualization. __Default value:__ - For y-axis [...]')
    mark = jst.JSONAnyOf([jst.JSONAnyOf([BOXPLOT(), ERRORBAR()]), jst.JSONInstance(_localname('CompositeMarkDef')), Mark(help='All types of primitive marks.'), jst.JSONInstance(_localname('MarkDef'))])
    name = jst.JSONString(help='Name of the visualization for later reference.')
    padding = jst.JSONAnyOf([jst.JSONNumber(), jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'right': jst.JSONNumber(), 'bottom': jst.JSONNumber(), '_required_traits': [], 'top': jst.JSONNumber(), '_additional_traits': False, 'left': jst.JSONNumber()}))])
    selection = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': [jst.JSONInstance(_localname('SelectionDef'))], '_required_traits': []}), help='A key-value mapping between selection names and definitions.')
    transform = jst.JSONArray(jst.JSONInstance(_localname('Transform')), help='An array of data transformations such as filter and new field [...]')
    width = jst.JSONNumber(help='The width of a visualization. __Default value:__ This will be [...]')

    def __init__(self, schema=jst.undefined, autoResize=jst.undefined, background=jst.undefined, config=jst.undefined, data=jst.undefined, description=jst.undefined, encoding=jst.undefined, height=jst.undefined, mark=jst.undefined, name=jst.undefined, padding=jst.undefined, selection=jst.undefined, transform=jst.undefined, width=jst.undefined, **kwargs):
        kwds = dict(schema=schema, autoResize=autoResize, background=background, config=config, data=data, description=description, encoding=encoding, height=height, mark=mark, name=name, padding=padding, selection=selection, transform=transform, width=width)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(TopLevelFacetedUnitSpec, self).__init__(**kwargs)


class TopLevelHConcatSpec(jst.JSONHasTraits):
    """TopLevelHConcatSpec class

    

    Attributes
    ----------
    schema : string
        URL to JSON schema for this Vega-Lite specification.
    autoResize : boolean
        Resize is a boolean indicating if autosize layout should be
        re-calculated on every update.
        __Default value__: `false`
    background : string
        CSS color property to use as the background of visualization.
        __Default value:__ none (transparent)
    config : Config
        Vega-Lite configuration object.  This property can only be
        defined at the top-level of a specification.
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
    hconcat : Array(Spec)
        
    name : string
        Name of the visualization for later reference.
    padding : AnyOf([number, Mapping])
        The default visualization padding, in pixels, from the edge of
        the visualization canvas to the data rectangle.  If a number,
        specifies padding for all sides.
        If an object, the value should have the format `{"left": 5,
        "top": 5, "right": 5, "bottom": 5}` to specify padding for
        each side of the visualization.
        __Default value__: `5`
    resolve : ResolveMapping
        
    transform : Array(Transform)
        An array of data transformations such as filter and new field
        calculation.
    """
    _additional_traits = False
    _required_traits = ['hconcat']
    _trait_name_map = {'schema': '$schema'}
    schema = jst.JSONString(help='URL to JSON schema for this Vega-Lite specification.')
    autoResize = jst.JSONBoolean(help='Resize is a boolean indicating if autosize layout should be re- [...]')
    background = jst.JSONString(help='CSS color property to use as the background of visualization. [...]')
    config = jst.JSONInstance(_localname('Config'), help='Vega-Lite configuration object. This property can only be [...]')
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose.')
    hconcat = jst.JSONArray(jst.JSONInstance(_localname('Spec')))
    name = jst.JSONString(help='Name of the visualization for later reference.')
    padding = jst.JSONAnyOf([jst.JSONNumber(), jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'right': jst.JSONNumber(), 'bottom': jst.JSONNumber(), '_required_traits': [], 'top': jst.JSONNumber(), '_additional_traits': False, 'left': jst.JSONNumber()}))])
    resolve = jst.JSONInstance(_localname('ResolveMapping'))
    transform = jst.JSONArray(jst.JSONInstance(_localname('Transform')), help='An array of data transformations such as filter and new field [...]')

    def __init__(self, schema=jst.undefined, autoResize=jst.undefined, background=jst.undefined, config=jst.undefined, data=jst.undefined, description=jst.undefined, hconcat=jst.undefined, name=jst.undefined, padding=jst.undefined, resolve=jst.undefined, transform=jst.undefined, **kwargs):
        kwds = dict(schema=schema, autoResize=autoResize, background=background, config=config, data=data, description=description, hconcat=hconcat, name=name, padding=padding, resolve=resolve, transform=transform)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(TopLevelHConcatSpec, self).__init__(**kwargs)


class TopLevelLayerSpec(jst.JSONHasTraits):
    """TopLevelLayerSpec class

    

    Attributes
    ----------
    schema : string
        URL to JSON schema for this Vega-Lite specification.
    autoResize : boolean
        Resize is a boolean indicating if autosize layout should be
        re-calculated on every update.
        __Default value__: `false`
    background : string
        CSS color property to use as the background of visualization.
        __Default value:__ none (transparent)
    config : Config
        Vega-Lite configuration object.  This property can only be
        defined at the top-level of a specification.
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
    height : number
        The height of a visualization.
        __Default value:__
        - For y-axis with a continuous (non-ordinal) scale, the
          height will be the value of
          [`config.cell.height`](config.html#cell-config).
        - For y-axis with an ordinal scale: if
          [`rangeStep`](scale.html#ordinal) is a numeric value
          (default), the height is determined by the value of
          `rangeStep` and the cardinality of the field mapped to
          y-channel.   Otherwise, if the `rangeStep` is `null`, the
          height will be the value of
          [`config.cell.height`](config.html#cell-config).
        - If no field is mapped to `x` channel, the `height` will be
          the value of `rangeStep`.
        __Note__: For plot with `row` and `column` channels, this
        represents the height of a single cell.
    layer : Array(AnyOf([LayerSpec, CompositeUnitSpec]))
        Unit specs that will be layered.
    name : string
        Name of the visualization for later reference.
    padding : AnyOf([number, Mapping])
        The default visualization padding, in pixels, from the edge of
        the visualization canvas to the data rectangle.  If a number,
        specifies padding for all sides.
        If an object, the value should have the format `{"left": 5,
        "top": 5, "right": 5, "bottom": 5}` to specify padding for
        each side of the visualization.
        __Default value__: `5`
    resolve : ResolveMapping
        
    transform : Array(Transform)
        An array of data transformations such as filter and new field
        calculation.
    width : number
        The width of a visualization.
        __Default value:__ This will be determined by the following
        rules:
        - For x-axis with a continuous (non-ordinal) scale, the
          width will be the value of
          [`config.cell.width`](config.html#cell-config).
        - For x-axis with an ordinal scale: if
          [`rangeStep`](scale.html#ordinal) is a numeric value
          (default), the width is determined by the value of
          `rangeStep` and the cardinality of the field mapped to
          x-channel.   Otherwise, if the `rangeStep` is `null`, the
          width will be the value of
          [`config.cell.width`](config.html#cell-config).
        - If no field is mapped to `x` channel, the `width` will be
          the value of
          [`config.scale.textXRangeStep`](size.html#default-width-and-
          height) for `text` mark and the value of `rangeStep` for
          other marks.
        __Note__: For plot with `row` and `column` channels, this
        represents the width of a single cell.
    """
    _additional_traits = False
    _required_traits = ['layer']
    _trait_name_map = {'schema': '$schema'}
    schema = jst.JSONString(help='URL to JSON schema for this Vega-Lite specification.')
    autoResize = jst.JSONBoolean(help='Resize is a boolean indicating if autosize layout should be re- [...]')
    background = jst.JSONString(help='CSS color property to use as the background of visualization. [...]')
    config = jst.JSONInstance(_localname('Config'), help='Vega-Lite configuration object. This property can only be [...]')
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose.')
    height = jst.JSONNumber(help='The height of a visualization. __Default value:__ - For y-axis [...]')
    layer = jst.JSONArray(jst.JSONAnyOf([jst.JSONInstance(_localname('LayerSpec')), jst.JSONInstance(_localname('CompositeUnitSpec'))]), help='Unit specs that will be layered.')
    name = jst.JSONString(help='Name of the visualization for later reference.')
    padding = jst.JSONAnyOf([jst.JSONNumber(), jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'right': jst.JSONNumber(), 'bottom': jst.JSONNumber(), '_required_traits': [], 'top': jst.JSONNumber(), '_additional_traits': False, 'left': jst.JSONNumber()}))])
    resolve = jst.JSONInstance(_localname('ResolveMapping'))
    transform = jst.JSONArray(jst.JSONInstance(_localname('Transform')), help='An array of data transformations such as filter and new field [...]')
    width = jst.JSONNumber(help='The width of a visualization. __Default value:__ This will be [...]')

    def __init__(self, schema=jst.undefined, autoResize=jst.undefined, background=jst.undefined, config=jst.undefined, data=jst.undefined, description=jst.undefined, height=jst.undefined, layer=jst.undefined, name=jst.undefined, padding=jst.undefined, resolve=jst.undefined, transform=jst.undefined, width=jst.undefined, **kwargs):
        kwds = dict(schema=schema, autoResize=autoResize, background=background, config=config, data=data, description=description, height=height, layer=layer, name=name, padding=padding, resolve=resolve, transform=transform, width=width)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(TopLevelLayerSpec, self).__init__(**kwargs)


class TopLevelProperties(jst.JSONHasTraits):
    """TopLevelProperties class

    

    Attributes
    ----------
    autoResize : boolean
        Resize is a boolean indicating if autosize layout should be
        re-calculated on every update.
        __Default value__: `false`
    background : string
        CSS color property to use as the background of visualization.
        __Default value:__ none (transparent)
    padding : AnyOf([number, Mapping])
        The default visualization padding, in pixels, from the edge of
        the visualization canvas to the data rectangle.  If a number,
        specifies padding for all sides.
        If an object, the value should have the format `{"left": 5,
        "top": 5, "right": 5, "bottom": 5}` to specify padding for
        each side of the visualization.
        __Default value__: `5`
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    autoResize = jst.JSONBoolean(help='Resize is a boolean indicating if autosize layout should be re- [...]')
    background = jst.JSONString(help='CSS color property to use as the background of visualization. [...]')
    padding = jst.JSONAnyOf([jst.JSONNumber(), jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'right': jst.JSONNumber(), 'bottom': jst.JSONNumber(), '_required_traits': [], 'top': jst.JSONNumber(), '_additional_traits': False, 'left': jst.JSONNumber()}))])

    def __init__(self, autoResize=jst.undefined, background=jst.undefined, padding=jst.undefined, **kwargs):
        kwds = dict(autoResize=autoResize, background=background, padding=padding)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(TopLevelProperties, self).__init__(**kwargs)


class TopLevelRepeatSpec(jst.JSONHasTraits):
    """TopLevelRepeatSpec class

    

    Attributes
    ----------
    schema : string
        URL to JSON schema for this Vega-Lite specification.
    autoResize : boolean
        Resize is a boolean indicating if autosize layout should be
        re-calculated on every update.
        __Default value__: `false`
    background : string
        CSS color property to use as the background of visualization.
        __Default value:__ none (transparent)
    config : Config
        Vega-Lite configuration object.  This property can only be
        defined at the top-level of a specification.
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
    name : string
        Name of the visualization for later reference.
    padding : AnyOf([number, Mapping])
        The default visualization padding, in pixels, from the edge of
        the visualization canvas to the data rectangle.  If a number,
        specifies padding for all sides.
        If an object, the value should have the format `{"left": 5,
        "top": 5, "right": 5, "bottom": 5}` to specify padding for
        each side of the visualization.
        __Default value__: `5`
    repeat : Repeat
        
    resolve : ResolveMapping
        
    spec : Spec
        
    transform : Array(Transform)
        An array of data transformations such as filter and new field
        calculation.
    """
    _additional_traits = False
    _required_traits = ['repeat', 'spec']
    _trait_name_map = {'schema': '$schema'}
    schema = jst.JSONString(help='URL to JSON schema for this Vega-Lite specification.')
    autoResize = jst.JSONBoolean(help='Resize is a boolean indicating if autosize layout should be re- [...]')
    background = jst.JSONString(help='CSS color property to use as the background of visualization. [...]')
    config = jst.JSONInstance(_localname('Config'), help='Vega-Lite configuration object. This property can only be [...]')
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose.')
    name = jst.JSONString(help='Name of the visualization for later reference.')
    padding = jst.JSONAnyOf([jst.JSONNumber(), jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'right': jst.JSONNumber(), 'bottom': jst.JSONNumber(), '_required_traits': [], 'top': jst.JSONNumber(), '_additional_traits': False, 'left': jst.JSONNumber()}))])
    repeat = jst.JSONInstance(_localname('Repeat'))
    resolve = jst.JSONInstance(_localname('ResolveMapping'))
    spec = jst.JSONInstance(_localname('Spec'))
    transform = jst.JSONArray(jst.JSONInstance(_localname('Transform')), help='An array of data transformations such as filter and new field [...]')

    def __init__(self, schema=jst.undefined, autoResize=jst.undefined, background=jst.undefined, config=jst.undefined, data=jst.undefined, description=jst.undefined, name=jst.undefined, padding=jst.undefined, repeat=jst.undefined, resolve=jst.undefined, spec=jst.undefined, transform=jst.undefined, **kwargs):
        kwds = dict(schema=schema, autoResize=autoResize, background=background, config=config, data=data, description=description, name=name, padding=padding, repeat=repeat, resolve=resolve, spec=spec, transform=transform)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(TopLevelRepeatSpec, self).__init__(**kwargs)


class TopLevelVConcatSpec(jst.JSONHasTraits):
    """TopLevelVConcatSpec class

    

    Attributes
    ----------
    schema : string
        URL to JSON schema for this Vega-Lite specification.
    autoResize : boolean
        Resize is a boolean indicating if autosize layout should be
        re-calculated on every update.
        __Default value__: `false`
    background : string
        CSS color property to use as the background of visualization.
        __Default value:__ none (transparent)
    config : Config
        Vega-Lite configuration object.  This property can only be
        defined at the top-level of a specification.
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
    name : string
        Name of the visualization for later reference.
    padding : AnyOf([number, Mapping])
        The default visualization padding, in pixels, from the edge of
        the visualization canvas to the data rectangle.  If a number,
        specifies padding for all sides.
        If an object, the value should have the format `{"left": 5,
        "top": 5, "right": 5, "bottom": 5}` to specify padding for
        each side of the visualization.
        __Default value__: `5`
    resolve : ResolveMapping
        
    transform : Array(Transform)
        An array of data transformations such as filter and new field
        calculation.
    vconcat : Array(Spec)
        
    """
    _additional_traits = False
    _required_traits = ['vconcat']
    _trait_name_map = {'schema': '$schema'}
    schema = jst.JSONString(help='URL to JSON schema for this Vega-Lite specification.')
    autoResize = jst.JSONBoolean(help='Resize is a boolean indicating if autosize layout should be re- [...]')
    background = jst.JSONString(help='CSS color property to use as the background of visualization. [...]')
    config = jst.JSONInstance(_localname('Config'), help='Vega-Lite configuration object. This property can only be [...]')
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose.')
    name = jst.JSONString(help='Name of the visualization for later reference.')
    padding = jst.JSONAnyOf([jst.JSONNumber(), jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'right': jst.JSONNumber(), 'bottom': jst.JSONNumber(), '_required_traits': [], 'top': jst.JSONNumber(), '_additional_traits': False, 'left': jst.JSONNumber()}))])
    resolve = jst.JSONInstance(_localname('ResolveMapping'))
    transform = jst.JSONArray(jst.JSONInstance(_localname('Transform')), help='An array of data transformations such as filter and new field [...]')
    vconcat = jst.JSONArray(jst.JSONInstance(_localname('Spec')))

    def __init__(self, schema=jst.undefined, autoResize=jst.undefined, background=jst.undefined, config=jst.undefined, data=jst.undefined, description=jst.undefined, name=jst.undefined, padding=jst.undefined, resolve=jst.undefined, transform=jst.undefined, vconcat=jst.undefined, **kwargs):
        kwds = dict(schema=schema, autoResize=autoResize, background=background, config=config, data=data, description=description, name=name, padding=padding, resolve=resolve, transform=transform, vconcat=vconcat)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(TopLevelVConcatSpec, self).__init__(**kwargs)


class UrlData(jst.JSONHasTraits):
    """UrlData class

    

    Attributes
    ----------
    format : DataUrlFormat
        Data format properties
    url : string
        An URL from which to load the data set. Use the `format.type`
        property
        to ensure the loaded data is correctly parsed.
    """
    _additional_traits = False
    _required_traits = ['url']
    _trait_name_map = {}
    format = jst.JSONInstance(_localname('DataUrlFormat'), help='Data format properties')
    url = jst.JSONString(help='An URL from which to load the data set. Use the `format.type` [...]')

    def __init__(self, format=jst.undefined, url=jst.undefined, **kwargs):
        kwds = dict(format=format, url=url)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(UrlData, self).__init__(**kwargs)


class VConcatSpec(jst.JSONHasTraits):
    """VConcatSpec class

    

    Attributes
    ----------
    data : Data
        An object describing the data source
    description : string
        An optional description of this mark for commenting purpose.
    name : string
        Name of the visualization for later reference.
    resolve : ResolveMapping
        
    transform : Array(Transform)
        An array of data transformations such as filter and new field
        calculation.
    vconcat : Array(Spec)
        
    """
    _additional_traits = False
    _required_traits = ['vconcat']
    _trait_name_map = {}
    data = jst.JSONInstance(_localname('Data'), help='An object describing the data source')
    description = jst.JSONString(help='An optional description of this mark for commenting purpose.')
    name = jst.JSONString(help='Name of the visualization for later reference.')
    resolve = jst.JSONInstance(_localname('ResolveMapping'))
    transform = jst.JSONArray(jst.JSONInstance(_localname('Transform')), help='An array of data transformations such as filter and new field [...]')
    vconcat = jst.JSONArray(jst.JSONInstance(_localname('Spec')))

    def __init__(self, data=jst.undefined, description=jst.undefined, name=jst.undefined, resolve=jst.undefined, transform=jst.undefined, vconcat=jst.undefined, **kwargs):
        kwds = dict(data=data, description=description, name=name, resolve=resolve, transform=transform, vconcat=vconcat)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(VConcatSpec, self).__init__(**kwargs)


class VLOnlyConfig(jst.JSONHasTraits):
    """VLOnlyConfig class

    

    Attributes
    ----------
    cell : CellConfig
        Cell Config
    countTitle : string
        Default axis and legend title for count fields.
        __Default value:__ `'Number of Records'`.
    invalidValues : string
        Defines how Vega-Lite should handle invalid values (`null` and
        `NaN`).
        - If set to `"filter"` (default), all data items with null
          values are filtered.
        - If `null`, all data items are included. In this case,
          invalid values will be interpreted as zeroes.
    numberFormat : string
        D3 Number format for axis labels and text tables. For example
        "s" for SI units.(in the form of [D3 number format
        pattern](https://github.com/mbostock/d3/wiki/Formatting)).
        __Default value:__ `"s"` (except for text marks that encode a
        count field, the default value is `"d"`).
    scale : ScaleConfig
        Scale Config
    selection : SelectionConfig
        Selection Config
    stack : string
        Default stack offset for stackable mark.
    timeFormat : string
        Default datetime format for axis and legend labels. The format
        can be set directly on each axis and legend. [D3 time format
        pattern](https://github.com/mbostock/d3/wiki/Time-
        Formatting)).
        __Default value:__ `'%b %d, %Y'`.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    cell = jst.JSONInstance(_localname('CellConfig'), help='Cell Config')
    countTitle = jst.JSONString(help='Default axis and legend title for count fields. __Default [...]')
    invalidValues = jst.JSONEnum(['filter'], help='Defines how Vega-Lite should handle invalid values (`null` and [...]')
    numberFormat = jst.JSONString(help='D3 Number format for axis labels and text tables. For example [...]')
    scale = jst.JSONInstance(_localname('ScaleConfig'), help='Scale Config')
    selection = jst.JSONInstance(_localname('SelectionConfig'), help='Selection Config')
    stack = StackOffset()
    timeFormat = jst.JSONString(help='Default datetime format for axis and legend labels. The format [...]')

    def __init__(self, cell=jst.undefined, countTitle=jst.undefined, invalidValues=jst.undefined, numberFormat=jst.undefined, scale=jst.undefined, selection=jst.undefined, stack=jst.undefined, timeFormat=jst.undefined, **kwargs):
        kwds = dict(cell=cell, countTitle=countTitle, invalidValues=invalidValues, numberFormat=numberFormat, scale=scale, selection=selection, stack=stack, timeFormat=timeFormat)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(VLOnlyConfig, self).__init__(**kwargs)


class ValueDef(jst.JSONHasTraits):
    """ValueDef class

    Definition object for a constant value of an encoding channel.

    Attributes
    ----------
    value : Mapping
        A constant value in visual domain.
    """
    _additional_traits = False
    _required_traits = ['value']
    _trait_name_map = {}
    value = jst.JSONInstance(T.MetaHasTraits('Mapping', (jst.JSONHasTraits,), {'_additional_traits': True, '_required_traits': []}), help='A constant value in visual domain.')

    def __init__(self, value=jst.undefined, **kwargs):
        kwds = dict(value=value)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(ValueDef, self).__init__(**kwargs)


class VgAxisBase(jst.JSONHasTraits):
    """VgAxisBase class

    Base object for Vega's Axis and Axis Config.
    All of these properties are both properties of Vega's Axis and
    Axis Config.

    Attributes
    ----------
    domain : boolean
        A boolean flag indicating if the domain (the axis baseline)
        should be included as part of the axis (default true).
    grid : boolean
        A boolean flag indicating if grid lines should be included as
        part of the axis
        __Default value:__ `true` for (1) quantitative fields that are
        not binned and (2) time fields;  otherwise, `"false"`.
    labelAngle : number
        The rotation angle of the axis labels.
        __Default value:__ `-45` for time or ordinal axis and `0`
        otherwise.
    labelOverlap : AnyOf([boolean, string, string])
        The strategy to use for resolving overlap of axis labels. If
        `false` (the default), no overlap reduction is attempted. If
        set to `true` or `"parity"`, a strategy of removing every
        other label is used (this works well for standard linear
        axes). If set to `"greedy"`, a linear scan of the labels is
        performed, removing any labels that overlaps with the last
        visible label (this often works better for log-scaled axes).
        __Default value:__ `true` for x-axes with horizontal labels,
        otherwise `false`.
    labels : boolean
        A boolean flag indicating if labels should be included as part
        of the axis (default true).
        __Default value:__  derived from [axis
        config](config.html#axis-config)'s `labels` (`true` by
        default).
    maxExtent : number
        The maximum extent in pixels that axis ticks and labels should
        use. This determines a maximum offset value for axis titles.
        __Default value:__ `undefined`.
    minExtent : number
        The minimum extent in pixels that axis ticks and labels should
        use. This determines a minimum offset value for axis titles.
        __Default value:__ `30`
    tickExtra : boolean
        Boolean flag indicating if an extra axis tick should be added
        for the initial position of the axis. This flag is useful for
        styling axes for `band` scales such that ticks are placed on
        band boundaries rather in the middle of a band. Use in
        conjunction with `"bandPostion": 1` and an axis `"padding"`
        value of `0`.
    tickSize : number
        The size, in pixels, of major, minor and end ticks.
        __Default value:__  derived from [axis
        config](config.html#axis-config)'s `tickSize` (`6` by
        default).
    ticks : boolean
        Boolean value that determines whether the axis should include
        ticks.
    titleAlign : string
        Horizontal text alignment of axis titles.
    titleAngle : number
        Angle in degrees of axis titles.
    titleMaxLength : number
        Max length for axis title if the title is automatically
        generated from the field's description. By default, this is
        automatically based on cell size and characterWidth property.
        __Default value:__  automatically determined based on the cell
        size (`config.cell.width`, `config.cell.height`)
    titlePadding : number
        The padding, in pixels, between title and axis.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    domain = jst.JSONBoolean(help='A boolean flag indicating if the domain (the axis baseline) [...]')
    grid = jst.JSONBoolean(help='A boolean flag indicating if grid lines should be included as [...]')
    labelAngle = jst.JSONNumber(help='The rotation angle of the axis labels. __Default value:__ `-45` [...]', maximum=360, minimum=-360)
    labelOverlap = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONEnum(['parity']), jst.JSONEnum(['greedy'])], help='The strategy to use for resolving overlap of axis labels. If [...]')
    labels = jst.JSONBoolean(help='A boolean flag indicating if labels should be included as part [...]')
    maxExtent = jst.JSONNumber(help='The maximum extent in pixels that axis ticks and labels should [...]')
    minExtent = jst.JSONNumber(help='The minimum extent in pixels that axis ticks and labels should [...]')
    tickExtra = jst.JSONBoolean(help='Boolean flag indicating if an extra axis tick should be added [...]')
    tickSize = jst.JSONNumber(help='The size, in pixels, of major, minor and end ticks. __Default [...]', minimum=0)
    ticks = jst.JSONBoolean(help='Boolean value that determines whether the axis should include ticks.')
    titleAlign = jst.JSONString(help='Horizontal text alignment of axis titles.')
    titleAngle = jst.JSONNumber(help='Angle in degrees of axis titles.')
    titleMaxLength = jst.JSONNumber(help='Max length for axis title if the title is automatically [...]', minimum=0)
    titlePadding = jst.JSONNumber(help='The padding, in pixels, between title and axis.')

    def __init__(self, domain=jst.undefined, grid=jst.undefined, labelAngle=jst.undefined, labelOverlap=jst.undefined, labels=jst.undefined, maxExtent=jst.undefined, minExtent=jst.undefined, tickExtra=jst.undefined, tickSize=jst.undefined, ticks=jst.undefined, titleAlign=jst.undefined, titleAngle=jst.undefined, titleMaxLength=jst.undefined, titlePadding=jst.undefined, **kwargs):
        kwds = dict(domain=domain, grid=grid, labelAngle=labelAngle, labelOverlap=labelOverlap, labels=labels, maxExtent=maxExtent, minExtent=minExtent, tickExtra=tickExtra, tickSize=tickSize, ticks=ticks, titleAlign=titleAlign, titleAngle=titleAngle, titleMaxLength=titleMaxLength, titlePadding=titlePadding)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(VgAxisBase, self).__init__(**kwargs)


class VgAxisConfig(jst.JSONHasTraits):
    """VgAxisConfig class

    

    Attributes
    ----------
    bandPosition : number
        An interpolation fraction indicating where, for `band` scales,
        axis ticks should be positioned. A value of `0` places ticks
        at the left edge of their bands. A value of `0.5` places ticks
        in the middle of their bands.
    domain : boolean
        A boolean flag indicating if the domain (the axis baseline)
        should be included as part of the axis (default true).
    domainColor : string
        Color of axis domain line.
        __Default value:__  (none, using Vega default).
    domainWidth : number
        Stroke width of axis domain line
        __Default value:__  (none, using Vega default).
    grid : boolean
        A boolean flag indicating if grid lines should be included as
        part of the axis
        __Default value:__ `true` for (1) quantitative fields that are
        not binned and (2) time fields;  otherwise, `"false"`.
    gridColor : string
        Color of gridlines.
    gridDash : Array(number)
        The offset (in pixels) into which to begin drawing with the
        grid dash array.
    gridOpacity : number
        The stroke opacity of grid (value between [0,1])
        __Default value:__ (`1` by default)
    gridWidth : number
        The grid width, in pixels.
    labelAngle : number
        The rotation angle of the axis labels.
        __Default value:__ `-45` for time or ordinal axis and `0`
        otherwise.
    labelColor : string
        The color of the tick label, can be in hex color code or
        regular color name.
    labelFont : string
        The font of the tick label.
    labelFontSize : number
        The font size of the label, in pixels.
        __Default value:__ `10`.
    labelLimit : number
        Maximum allowed pixel width of axis tick labels.
    labelOverlap : AnyOf([boolean, string, string])
        The strategy to use for resolving overlap of axis labels. If
        `false` (the default), no overlap reduction is attempted. If
        set to `true` or `"parity"`, a strategy of removing every
        other label is used (this works well for standard linear
        axes). If set to `"greedy"`, a linear scan of the labels is
        performed, removing any labels that overlaps with the last
        visible label (this often works better for log-scaled axes).
        __Default value:__ `true` for x-axes with horizontal labels,
        otherwise `false`.
    labelPadding : number
        Padding in pixels between axis ticks and tick labels.
    labels : boolean
        A boolean flag indicating if labels should be included as part
        of the axis (default true).
        __Default value:__  derived from [axis
        config](config.html#axis-config)'s `labels` (`true` by
        default).
    maxExtent : number
        The maximum extent in pixels that axis ticks and labels should
        use. This determines a maximum offset value for axis titles.
        __Default value:__ `undefined`.
    minExtent : number
        The minimum extent in pixels that axis ticks and labels should
        use. This determines a minimum offset value for axis titles.
        __Default value:__ `30`
    tickColor : string
        The color of the axis's tick.
    tickExtra : boolean
        Boolean flag indicating if an extra axis tick should be added
        for the initial position of the axis. This flag is useful for
        styling axes for `band` scales such that ticks are placed on
        band boundaries rather in the middle of a band. Use in
        conjunction with `"bandPostion": 1` and an axis `"padding"`
        value of `0`.
    tickRound : boolean
        Boolean flag indicating if pixel position values should be
        rounded to the nearest integer.
    tickSize : number
        The size, in pixels, of major, minor and end ticks.
        __Default value:__  derived from [axis
        config](config.html#axis-config)'s `tickSize` (`6` by
        default).
    tickWidth : number
        The width, in pixels, of ticks.
    ticks : boolean
        Boolean value that determines whether the axis should include
        ticks.
    titleAlign : string
        Horizontal text alignment of axis titles.
    titleAngle : number
        Angle in degrees of axis titles.
    titleBaseline : string
        Vertical text baseline for axis titles.
    titleColor : string
        Color of the title, can be in hex color code or regular color
        name.
    titleFont : string
        Font of the title. (e.g., `"Helvetica Neue"`).
    titleFontSize : number
        Font size of the title.
        __Default value:__ `10`.
    titleFontWeight : ['string', 'number']
        Font weight of the title. (e.g., `"bold"`).
    titleLimit : number
        Maximum allowed pixel width of axis titles.
    titleMaxLength : number
        Max length for axis title if the title is automatically
        generated from the field's description. By default, this is
        automatically based on cell size and characterWidth property.
        __Default value:__  automatically determined based on the cell
        size (`config.cell.width`, `config.cell.height`)
    titlePadding : number
        The padding, in pixels, between title and axis.
    titleX : number
        X-coordinate of the axis title relative to the axis group.
    titleY : number
        Y-coordinate of the axis title relative to the axis group.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    bandPosition = jst.JSONNumber(help='An interpolation fraction indicating where, for `band` scales, [...]')
    domain = jst.JSONBoolean(help='A boolean flag indicating if the domain (the axis baseline) [...]')
    domainColor = jst.JSONString(help='Color of axis domain line. __Default value:__ (none, using Vega [...]')
    domainWidth = jst.JSONNumber(help='Stroke width of axis domain line __Default value:__ (none, using [...]')
    grid = jst.JSONBoolean(help='A boolean flag indicating if grid lines should be included as [...]')
    gridColor = jst.JSONString(help='Color of gridlines.')
    gridDash = jst.JSONArray(jst.JSONNumber(), help='The offset (in pixels) into which to begin drawing with the grid [...]')
    gridOpacity = jst.JSONNumber(help='The stroke opacity of grid (value between [0,1]) __Default [...]', maximum=1, minimum=0)
    gridWidth = jst.JSONNumber(help='The grid width, in pixels.', minimum=0)
    labelAngle = jst.JSONNumber(help='The rotation angle of the axis labels. __Default value:__ `-45` [...]', maximum=360, minimum=-360)
    labelColor = jst.JSONString(help='The color of the tick label, can be in hex color code or regular [...]')
    labelFont = jst.JSONString(help='The font of the tick label.')
    labelFontSize = jst.JSONNumber(help='The font size of the label, in pixels. __Default value:__ `10`.', minimum=0)
    labelLimit = jst.JSONNumber(help='Maximum allowed pixel width of axis tick labels.')
    labelOverlap = jst.JSONAnyOf([jst.JSONBoolean(), jst.JSONEnum(['parity']), jst.JSONEnum(['greedy'])], help='The strategy to use for resolving overlap of axis labels. If [...]')
    labelPadding = jst.JSONNumber(help='Padding in pixels between axis ticks and tick labels.')
    labels = jst.JSONBoolean(help='A boolean flag indicating if labels should be included as part [...]')
    maxExtent = jst.JSONNumber(help='The maximum extent in pixels that axis ticks and labels should [...]')
    minExtent = jst.JSONNumber(help='The minimum extent in pixels that axis ticks and labels should [...]')
    tickColor = jst.JSONString(help="The color of the axis's tick.")
    tickExtra = jst.JSONBoolean(help='Boolean flag indicating if an extra axis tick should be added [...]')
    tickRound = jst.JSONBoolean(help='Boolean flag indicating if pixel position values should be [...]')
    tickSize = jst.JSONNumber(help='The size, in pixels, of major, minor and end ticks. __Default [...]', minimum=0)
    tickWidth = jst.JSONNumber(help='The width, in pixels, of ticks.', minimum=0)
    ticks = jst.JSONBoolean(help='Boolean value that determines whether the axis should include ticks.')
    titleAlign = jst.JSONString(help='Horizontal text alignment of axis titles.')
    titleAngle = jst.JSONNumber(help='Angle in degrees of axis titles.')
    titleBaseline = jst.JSONString(help='Vertical text baseline for axis titles.')
    titleColor = jst.JSONString(help='Color of the title, can be in hex color code or regular color name.')
    titleFont = jst.JSONString(help='Font of the title. (e.g., `"Helvetica Neue"`).')
    titleFontSize = jst.JSONNumber(help='Font size of the title. __Default value:__ `10`.', minimum=0)
    titleFontWeight = jst.JSONUnion([jst.JSONString(), jst.JSONNumber()], help='Font weight of the title. (e.g., `"bold"`).')
    titleLimit = jst.JSONNumber(help='Maximum allowed pixel width of axis titles.')
    titleMaxLength = jst.JSONNumber(help='Max length for axis title if the title is automatically [...]', minimum=0)
    titlePadding = jst.JSONNumber(help='The padding, in pixels, between title and axis.')
    titleX = jst.JSONNumber(help='X-coordinate of the axis title relative to the axis group.')
    titleY = jst.JSONNumber(help='Y-coordinate of the axis title relative to the axis group.')

    def __init__(self, bandPosition=jst.undefined, domain=jst.undefined, domainColor=jst.undefined, domainWidth=jst.undefined, grid=jst.undefined, gridColor=jst.undefined, gridDash=jst.undefined, gridOpacity=jst.undefined, gridWidth=jst.undefined, labelAngle=jst.undefined, labelColor=jst.undefined, labelFont=jst.undefined, labelFontSize=jst.undefined, labelLimit=jst.undefined, labelOverlap=jst.undefined, labelPadding=jst.undefined, labels=jst.undefined, maxExtent=jst.undefined, minExtent=jst.undefined, tickColor=jst.undefined, tickExtra=jst.undefined, tickRound=jst.undefined, tickSize=jst.undefined, tickWidth=jst.undefined, ticks=jst.undefined, titleAlign=jst.undefined, titleAngle=jst.undefined, titleBaseline=jst.undefined, titleColor=jst.undefined, titleFont=jst.undefined, titleFontSize=jst.undefined, titleFontWeight=jst.undefined, titleLimit=jst.undefined, titleMaxLength=jst.undefined, titlePadding=jst.undefined, titleX=jst.undefined, titleY=jst.undefined, **kwargs):
        kwds = dict(bandPosition=bandPosition, domain=domain, domainColor=domainColor, domainWidth=domainWidth, grid=grid, gridColor=gridColor, gridDash=gridDash, gridOpacity=gridOpacity, gridWidth=gridWidth, labelAngle=labelAngle, labelColor=labelColor, labelFont=labelFont, labelFontSize=labelFontSize, labelLimit=labelLimit, labelOverlap=labelOverlap, labelPadding=labelPadding, labels=labels, maxExtent=maxExtent, minExtent=minExtent, tickColor=tickColor, tickExtra=tickExtra, tickRound=tickRound, tickSize=tickSize, tickWidth=tickWidth, ticks=ticks, titleAlign=titleAlign, titleAngle=titleAngle, titleBaseline=titleBaseline, titleColor=titleColor, titleFont=titleFont, titleFontSize=titleFontSize, titleFontWeight=titleFontWeight, titleLimit=titleLimit, titleMaxLength=titleMaxLength, titlePadding=titlePadding, titleX=titleX, titleY=titleY)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(VgAxisConfig, self).__init__(**kwargs)


class VgCheckboxBinding(jst.JSONHasTraits):
    """VgCheckboxBinding class

    

    Attributes
    ----------
    element : string
        
    input : string
        
    """
    _additional_traits = False
    _required_traits = ['input']
    _trait_name_map = {}
    element = jst.JSONString()
    input = jst.JSONEnum(['checkbox'])

    def __init__(self, element=jst.undefined, input=jst.undefined, **kwargs):
        kwds = dict(element=element, input=input)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(VgCheckboxBinding, self).__init__(**kwargs)


class VgGenericBinding(jst.JSONHasTraits):
    """VgGenericBinding class

    

    Attributes
    ----------
    element : string
        
    input : string
        
    """
    _additional_traits = False
    _required_traits = ['input']
    _trait_name_map = {}
    element = jst.JSONString()
    input = jst.JSONString()

    def __init__(self, element=jst.undefined, input=jst.undefined, **kwargs):
        kwds = dict(element=element, input=input)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(VgGenericBinding, self).__init__(**kwargs)


class VgLegendBase(jst.JSONHasTraits):
    """VgLegendBase class

    

    Attributes
    ----------
    entryPadding : number
        Padding (in pixels) between legend entries in a symbol legend.
    fillColor : string
        Background fill color for the full legend.
    offset : number
        The offset, in pixels, by which to displace the legend from
        the edge of the enclosing group or data rectangle.
        __Default value:__  `0`
    orient : string
        The orientation of the legend. One of `"left"` or `"right"`.
        This determines how the legend is positioned within the scene.
        The default is `"right"`.
        __Default value:__  `"right"`
    padding : number
        The padding, in pixels, between the legend and axis.
    titleAlign : string
        Horizontal text alignment for legend titles.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    entryPadding = jst.JSONNumber(help='Padding (in pixels) between legend entries in a symbol legend.')
    fillColor = jst.JSONString(help='Background fill color for the full legend.')
    offset = jst.JSONNumber(help='The offset, in pixels, by which to displace the legend from the [...]')
    orient = LegendOrient()
    padding = jst.JSONNumber(help='The padding, in pixels, between the legend and axis.')
    titleAlign = jst.JSONString(help='Horizontal text alignment for legend titles.')

    def __init__(self, entryPadding=jst.undefined, fillColor=jst.undefined, offset=jst.undefined, orient=jst.undefined, padding=jst.undefined, titleAlign=jst.undefined, **kwargs):
        kwds = dict(entryPadding=entryPadding, fillColor=fillColor, offset=offset, orient=orient, padding=padding, titleAlign=titleAlign)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(VgLegendBase, self).__init__(**kwargs)


class VgLegendConfig(jst.JSONHasTraits):
    """VgLegendConfig class

    

    Attributes
    ----------
    cornerRadius : number
        Corner radius for the full legend.
    entryPadding : number
        Padding (in pixels) between legend entries in a symbol legend.
    fillColor : string
        Background fill color for the full legend.
    gradientHeight : number
        The height of the gradient, in pixels.
    gradientLabelBaseline : string
        Text baseline for color ramp gradient labels.
    gradientLabelLimit : number
        The maximum allowed length in pixels of color ramp gradient
        labels.
    gradientLabelOffset : number
        Vertical offset in pixels for color ramp gradient labels.
    gradientStrokeColor : string
        The color of the gradient stroke, can be in hex color code or
        regular color name.
    gradientStrokeWidth : number
        The width of the gradient stroke, in pixels.
    gradientWidth : number
        The width of the gradient, in pixels.
    labelAlign : string
        The alignment of the legend label, can be left, middle or
        right.
    labelBaseline : string
        The position of the baseline of legend label, can be top,
        middle or bottom.
    labelColor : string
        The color of the legend label, can be in hex color code or
        regular color name.
    labelFont : string
        The font of the legend label.
    labelFontSize : number
        The font size of legend label.
        __Default value:__ `10`.
    labelLimit : number
        Maximum allowed pixel width of axis tick labels.
    labelOffset : number
        The offset of the legend label.
    offset : number
        The offset, in pixels, by which to displace the legend from
        the edge of the enclosing group or data rectangle.
        __Default value:__  `0`
    orient : string
        The orientation of the legend. One of `"left"` or `"right"`.
        This determines how the legend is positioned within the scene.
        The default is `"right"`.
        __Default value:__  `"right"`
    padding : number
        The padding, in pixels, between the legend and axis.
    strokeColor : string
        Border stroke color for the full legend.
    strokeDash : Array(number)
        Border stroke dash pattern for the full legend.
    strokeWidth : number
        Border stroke width for the full legend.
    symbolColor : string
        The color of the legend symbol,
    symbolSize : number
        The size of the legend symbol, in pixels.
    symbolStrokeWidth : number
        The width of the symbol's stroke.
    symbolType : string
        Default shape type (such as "circle") for legend symbols.
    titleAlign : string
        Horizontal text alignment for legend titles.
    titleBaseline : string
        Optional mark property definitions for custom legend styling.
         Vertical text baseline for legend titles.
    titleColor : string
        The color of the legend title, can be in hex color code or
        regular color name.
    titleFont : string
        The font of the legend title.
    titleFontSize : number
        The font size of the legend title.
    titleFontWeight : ['string', 'number']
        The font weight of the legend title.
    titleLimit : number
        Maximum allowed pixel width of axis titles.
    titlePadding : number
        The padding, in pixels, between title and legend.
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    cornerRadius = jst.JSONNumber(help='Corner radius for the full legend.')
    entryPadding = jst.JSONNumber(help='Padding (in pixels) between legend entries in a symbol legend.')
    fillColor = jst.JSONString(help='Background fill color for the full legend.')
    gradientHeight = jst.JSONNumber(help='The height of the gradient, in pixels.', minimum=0)
    gradientLabelBaseline = jst.JSONString(help='Text baseline for color ramp gradient labels.')
    gradientLabelLimit = jst.JSONNumber(help='The maximum allowed length in pixels of color ramp gradient labels.')
    gradientLabelOffset = jst.JSONNumber(help='Vertical offset in pixels for color ramp gradient labels.')
    gradientStrokeColor = jst.JSONString(help='The color of the gradient stroke, can be in hex color code or [...]')
    gradientStrokeWidth = jst.JSONNumber(help='The width of the gradient stroke, in pixels.', minimum=0)
    gradientWidth = jst.JSONNumber(help='The width of the gradient, in pixels.', minimum=0)
    labelAlign = jst.JSONString(help='The alignment of the legend label, can be left, middle or right.')
    labelBaseline = jst.JSONString(help='The position of the baseline of legend label, can be top, middle [...]')
    labelColor = jst.JSONString(help='The color of the legend label, can be in hex color code or [...]')
    labelFont = jst.JSONString(help='The font of the legend label.')
    labelFontSize = jst.JSONNumber(help='The font size of legend label. __Default value:__ `10`.', minimum=0)
    labelLimit = jst.JSONNumber(help='Maximum allowed pixel width of axis tick labels.')
    labelOffset = jst.JSONNumber(help='The offset of the legend label.', minimum=0)
    offset = jst.JSONNumber(help='The offset, in pixels, by which to displace the legend from the [...]')
    orient = LegendOrient()
    padding = jst.JSONNumber(help='The padding, in pixels, between the legend and axis.')
    strokeColor = jst.JSONString(help='Border stroke color for the full legend.')
    strokeDash = jst.JSONArray(jst.JSONNumber(), help='Border stroke dash pattern for the full legend.')
    strokeWidth = jst.JSONNumber(help='Border stroke width for the full legend.')
    symbolColor = jst.JSONString(help='The color of the legend symbol,')
    symbolSize = jst.JSONNumber(help='The size of the legend symbol, in pixels.', minimum=0)
    symbolStrokeWidth = jst.JSONNumber(help="The width of the symbol's stroke.", minimum=0)
    symbolType = jst.JSONString(help='Default shape type (such as "circle") for legend symbols.')
    titleAlign = jst.JSONString(help='Horizontal text alignment for legend titles.')
    titleBaseline = jst.JSONString(help='Optional mark property definitions for custom legend styling. [...]')
    titleColor = jst.JSONString(help='The color of the legend title, can be in hex color code or [...]')
    titleFont = jst.JSONString(help='The font of the legend title.')
    titleFontSize = jst.JSONNumber(help='The font size of the legend title.')
    titleFontWeight = jst.JSONUnion([jst.JSONString(), jst.JSONNumber()], help='The font weight of the legend title.')
    titleLimit = jst.JSONNumber(help='Maximum allowed pixel width of axis titles.')
    titlePadding = jst.JSONNumber(help='The padding, in pixels, between title and legend.')

    def __init__(self, cornerRadius=jst.undefined, entryPadding=jst.undefined, fillColor=jst.undefined, gradientHeight=jst.undefined, gradientLabelBaseline=jst.undefined, gradientLabelLimit=jst.undefined, gradientLabelOffset=jst.undefined, gradientStrokeColor=jst.undefined, gradientStrokeWidth=jst.undefined, gradientWidth=jst.undefined, labelAlign=jst.undefined, labelBaseline=jst.undefined, labelColor=jst.undefined, labelFont=jst.undefined, labelFontSize=jst.undefined, labelLimit=jst.undefined, labelOffset=jst.undefined, offset=jst.undefined, orient=jst.undefined, padding=jst.undefined, strokeColor=jst.undefined, strokeDash=jst.undefined, strokeWidth=jst.undefined, symbolColor=jst.undefined, symbolSize=jst.undefined, symbolStrokeWidth=jst.undefined, symbolType=jst.undefined, titleAlign=jst.undefined, titleBaseline=jst.undefined, titleColor=jst.undefined, titleFont=jst.undefined, titleFontSize=jst.undefined, titleFontWeight=jst.undefined, titleLimit=jst.undefined, titlePadding=jst.undefined, **kwargs):
        kwds = dict(cornerRadius=cornerRadius, entryPadding=entryPadding, fillColor=fillColor, gradientHeight=gradientHeight, gradientLabelBaseline=gradientLabelBaseline, gradientLabelLimit=gradientLabelLimit, gradientLabelOffset=gradientLabelOffset, gradientStrokeColor=gradientStrokeColor, gradientStrokeWidth=gradientStrokeWidth, gradientWidth=gradientWidth, labelAlign=labelAlign, labelBaseline=labelBaseline, labelColor=labelColor, labelFont=labelFont, labelFontSize=labelFontSize, labelLimit=labelLimit, labelOffset=labelOffset, offset=offset, orient=orient, padding=padding, strokeColor=strokeColor, strokeDash=strokeDash, strokeWidth=strokeWidth, symbolColor=symbolColor, symbolSize=symbolSize, symbolStrokeWidth=symbolStrokeWidth, symbolType=symbolType, titleAlign=titleAlign, titleBaseline=titleBaseline, titleColor=titleColor, titleFont=titleFont, titleFontSize=titleFontSize, titleFontWeight=titleFontWeight, titleLimit=titleLimit, titlePadding=titlePadding)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(VgLegendConfig, self).__init__(**kwargs)


class VgMarkConfig(jst.JSONHasTraits):
    """VgMarkConfig class

    

    Attributes
    ----------
    align : string
        The horizontal alignment of the text. One of `"left"`,
        `"right"`, `"center"`.
    angle : number
        The rotation angle of the text, in degrees.
    baseline : string
        The vertical alignment of the text. One of `"top"`,
        `"middle"`, `"bottom"`.
        __Default value:__ `"middle"`
    dx : number
        The horizontal offset, in pixels, between the text label and
        its anchor point. The offset is applied after rotation by the
        _angle_ property.
    dy : number
        The vertical offset, in pixels, between the text label and its
        anchor point. The offset is applied after rotation by the
        _angle_ property.
    fill : string
        Default Fill Color.  This has higher precedence than
        config.color
        __Default value:__ (None)
    fillOpacity : number
        The fill opacity (value between [0,1]).
        __Default value:__ `1`
    font : string
        The typeface to set the text in (e.g., `"Helvetica Neue"`).
    fontSize : number
        The font size, in pixels.
    fontStyle : string
        The font style (e.g., `"italic"`).
    fontWeight : AnyOf([string, number])
        The font weight (e.g., `"bold"`).
    interpolate : string
        The line interpolation method to use for line and area marks.
        One of the following:
        - `"linear"`: piecewise linear segments, as in a polyline.
        - `"linear-closed"`: close the linear segments to form a
          polygon.
        - `"step"`: alternate between horizontal and vertical
          segments, as in a step function.
        - `"step-before"`: alternate between vertical and horizontal
          segments, as in a step function.
        - `"step-after"`: alternate between horizontal and vertical
          segments, as in a step function.
        - `"basis"`: a B-spline, with control point duplication on
          the ends.
        - `"basis-open"`: an open B-spline; may not intersect the
          start or end.
        - `"basis-closed"`: a closed B-spline, as in a loop.
        - `"cardinal"`: a Cardinal spline, with control point
          duplication on the ends.
        - `"cardinal-open"`: an open Cardinal spline; may not
          intersect the start or end, but will intersect other control
          points.
        - `"cardinal-closed"`: a closed Cardinal spline, as in a
          loop.
        - `"bundle"`: equivalent to basis, except the tension
          parameter is used to straighten the spline.
        - `"monotone"`: cubic interpolation that preserves
          monotonicity in y.
    opacity : number
        The overall opacity (value between [0,1]).
        __Default value:__ `0.7` for non-aggregate plots with `point`,
        `tick`, `circle`, or `square` marks or layered `bar` charts
        and `1` otherwise.
    orient : string
        The orientation of a non-stacked bar, tick, area, and line
        charts.
        The value is either horizontal (default) or vertical.
        - For bar, rule and tick, this determines whether the size
          of the bar and tick
        should be applied to x or y dimension.
        - For area, this property determines the orient property of
          the Vega output.
        - For line, this property determines the sort order of the
          points in the line
        if `config.sortLineBy` is not specified.
        For stacked charts, this is always determined by the
        orientation of the stack;
        therefore explicitly specified value will be ignored.
    radius : number
        Polar coordinate radial offset, in pixels, of the text label
        from the origin determined by the `x` and `y` properties.
    shape : string
        The default symbol shape to use. One of: `"circle"` (default),
        `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, or
        `"triangle-down"`, or a custom SVG path.
        __Default value:__ `"circle"`
    size : number
        The pixel area each the point/circle/square.
        For example: in the case of circles, the radius is determined
        in part by the square root of the size value.
        __Default value:__ `30`
    stroke : string
        Default Stroke Color.  This has higher precedence than
        config.color
        __Default value:__ (None)
    strokeDash : Array(number)
        An array of alternating stroke, space lengths for creating
        dashed or dotted lines.
    strokeDashOffset : number
        The offset (in pixels) into which to begin drawing with the
        stroke dash array.
    strokeOpacity : number
        The stroke opacity (value between [0,1]).
        __Default value:__ `1`
    strokeWidth : number
        The stroke width, in pixels.
    tension : number
        Depending on the interpolation type, sets the tension
        parameter (for line and area marks).
    text : string
        Placeholder text if the `text` channel is not specified
    theta : number
        Polar coordinate angle, in radians, of the text label from the
        origin determined by the `x` and `y` properties. Values for
        `theta` follow the same convention of `arc` mark `startAngle`
        and `endAngle` properties: angles are measured in radians,
        with `0` indicating "north".
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    align = HorizontalAlign()
    angle = jst.JSONNumber(help='The rotation angle of the text, in degrees.', maximum=360, minimum=0)
    baseline = VerticalAlign()
    dx = jst.JSONNumber(help='The horizontal offset, in pixels, between the text label and its [...]')
    dy = jst.JSONNumber(help='The vertical offset, in pixels, between the text label and its [...]')
    fill = jst.JSONString(help='Default Fill Color. This has higher precedence than config.color [...]')
    fillOpacity = jst.JSONNumber(help='The fill opacity (value between [0,1]). __Default value:__ `1`', maximum=1, minimum=0)
    font = jst.JSONString(help='The typeface to set the text in (e.g., `"Helvetica Neue"`).')
    fontSize = jst.JSONNumber(help='The font size, in pixels.', minimum=0)
    fontStyle = FontStyle()
    fontWeight = jst.JSONAnyOf([FontWeight(), jst.JSONNumber(maximum=900, minimum=100)], help='The font weight (e.g., `"bold"`).')
    interpolate = Interpolate()
    opacity = jst.JSONNumber(help='The overall opacity (value between [0,1]). __Default value:__ [...]', maximum=1, minimum=0)
    orient = Orient()
    radius = jst.JSONNumber(help='Polar coordinate radial offset, in pixels, of the text label [...]', minimum=0)
    shape = jst.JSONString(help='The default symbol shape to use. One of: `"circle"` (default), [...]')
    size = jst.JSONNumber(help='The pixel area each the point/circle/square. For example: in the [...]', minimum=0)
    stroke = jst.JSONString(help='Default Stroke Color. This has higher precedence than [...]')
    strokeDash = jst.JSONArray(jst.JSONNumber(), help='An array of alternating stroke, space lengths for creating [...]')
    strokeDashOffset = jst.JSONNumber(help='The offset (in pixels) into which to begin drawing with the [...]')
    strokeOpacity = jst.JSONNumber(help='The stroke opacity (value between [0,1]). __Default value:__ `1`', maximum=1, minimum=0)
    strokeWidth = jst.JSONNumber(help='The stroke width, in pixels.', minimum=0)
    tension = jst.JSONNumber(help='Depending on the interpolation type, sets the tension parameter [...]', maximum=1, minimum=0)
    text = jst.JSONString(help='Placeholder text if the `text` channel is not specified')
    theta = jst.JSONNumber(help='Polar coordinate angle, in radians, of the text label from the [...]')

    def __init__(self, align=jst.undefined, angle=jst.undefined, baseline=jst.undefined, dx=jst.undefined, dy=jst.undefined, fill=jst.undefined, fillOpacity=jst.undefined, font=jst.undefined, fontSize=jst.undefined, fontStyle=jst.undefined, fontWeight=jst.undefined, interpolate=jst.undefined, opacity=jst.undefined, orient=jst.undefined, radius=jst.undefined, shape=jst.undefined, size=jst.undefined, stroke=jst.undefined, strokeDash=jst.undefined, strokeDashOffset=jst.undefined, strokeOpacity=jst.undefined, strokeWidth=jst.undefined, tension=jst.undefined, text=jst.undefined, theta=jst.undefined, **kwargs):
        kwds = dict(align=align, angle=angle, baseline=baseline, dx=dx, dy=dy, fill=fill, fillOpacity=fillOpacity, font=font, fontSize=fontSize, fontStyle=fontStyle, fontWeight=fontWeight, interpolate=interpolate, opacity=opacity, orient=orient, radius=radius, shape=shape, size=size, stroke=stroke, strokeDash=strokeDash, strokeDashOffset=strokeDashOffset, strokeOpacity=strokeOpacity, strokeWidth=strokeWidth, tension=tension, text=text, theta=theta)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(VgMarkConfig, self).__init__(**kwargs)


class VgRadioBinding(jst.JSONHasTraits):
    """VgRadioBinding class

    

    Attributes
    ----------
    element : string
        
    input : string
        
    options : Array(string)
        
    """
    _additional_traits = False
    _required_traits = ['input', 'options']
    _trait_name_map = {}
    element = jst.JSONString()
    input = jst.JSONEnum(['radio'])
    options = jst.JSONArray(jst.JSONString())

    def __init__(self, element=jst.undefined, input=jst.undefined, options=jst.undefined, **kwargs):
        kwds = dict(element=element, input=input, options=options)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(VgRadioBinding, self).__init__(**kwargs)


class VgRangeBinding(jst.JSONHasTraits):
    """VgRangeBinding class

    

    Attributes
    ----------
    element : string
        
    input : string
        
    max : number
        
    min : number
        
    step : number
        
    """
    _additional_traits = False
    _required_traits = ['input']
    _trait_name_map = {}
    element = jst.JSONString()
    input = jst.JSONEnum(['range'])
    max = jst.JSONNumber()
    min = jst.JSONNumber()
    step = jst.JSONNumber()

    def __init__(self, element=jst.undefined, input=jst.undefined, max=jst.undefined, min=jst.undefined, step=jst.undefined, **kwargs):
        kwds = dict(element=element, input=input, max=max, min=min, step=step)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(VgRangeBinding, self).__init__(**kwargs)


class VgRangeScheme(jst.JSONHasTraits):
    """VgRangeScheme class

    

    Attributes
    ----------
    count : number
        
    extent : Array(number)
        
    scheme : string
        
    """
    _additional_traits = False
    _required_traits = ['scheme']
    _trait_name_map = {}
    count = jst.JSONNumber()
    extent = jst.JSONArray(jst.JSONNumber())
    scheme = jst.JSONString()

    def __init__(self, count=jst.undefined, extent=jst.undefined, scheme=jst.undefined, **kwargs):
        kwds = dict(count=count, extent=extent, scheme=scheme)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(VgRangeScheme, self).__init__(**kwargs)


class VgSelectBinding(jst.JSONHasTraits):
    """VgSelectBinding class

    

    Attributes
    ----------
    element : string
        
    input : string
        
    options : Array(string)
        
    """
    _additional_traits = False
    _required_traits = ['input', 'options']
    _trait_name_map = {}
    element = jst.JSONString()
    input = jst.JSONEnum(['select'])
    options = jst.JSONArray(jst.JSONString())

    def __init__(self, element=jst.undefined, input=jst.undefined, options=jst.undefined, **kwargs):
        kwds = dict(element=element, input=input, options=options)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(VgSelectBinding, self).__init__(**kwargs)


class VgTitleConfig(jst.JSONHasTraits):
    """VgTitleConfig class

    

    Attributes
    ----------
    anchor : string
        Title anchor position (`"start"`, `"middle"`, or `"end"`).
    angle : number
        Angle in degrees of title text.
    baseline : string
        Vertical text baseline for title text.
    color : string
        Text color for title text.
    font : string
        Font name for title text.
    fontSize : number
        Font size in pixels for title text.
        __Default value:__ `10`.
    fontWeight : ['string', 'number']
        Font weight for title text.
    limit : number
        The maximum allowed length in pixels of legend labels.
    offset : number
        Offset in pixels of the title from the chart body and axes.
    orient : string
        Default title orientation ("top", "bottom", "left", or
        "right")
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    anchor = jst.JSONString(help='Title anchor position (`"start"`, `"middle"`, or `"end"`).')
    angle = jst.JSONNumber(help='Angle in degrees of title text.')
    baseline = jst.JSONString(help='Vertical text baseline for title text.')
    color = jst.JSONString(help='Text color for title text.')
    font = jst.JSONString(help='Font name for title text.')
    fontSize = jst.JSONNumber(help='Font size in pixels for title text. __Default value:__ `10`.', minimum=0)
    fontWeight = jst.JSONUnion([jst.JSONString(), jst.JSONNumber()], help='Font weight for title text.')
    limit = jst.JSONNumber(help='The maximum allowed length in pixels of legend labels.', minimum=0)
    offset = jst.JSONNumber(help='Offset in pixels of the title from the chart body and axes.')
    orient = jst.JSONString(help='Default title orientation ("top", "bottom", "left", or "right")')

    def __init__(self, anchor=jst.undefined, angle=jst.undefined, baseline=jst.undefined, color=jst.undefined, font=jst.undefined, fontSize=jst.undefined, fontWeight=jst.undefined, limit=jst.undefined, offset=jst.undefined, orient=jst.undefined, **kwargs):
        kwds = dict(anchor=anchor, angle=angle, baseline=baseline, color=color, font=font, fontSize=fontSize, fontWeight=fontWeight, limit=limit, offset=offset, orient=orient)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(VgTitleConfig, self).__init__(**kwargs)


class VlOnlyGuideConfig(jst.JSONHasTraits):
    """VlOnlyGuideConfig class

    

    Attributes
    ----------
    shortTimeLabels : boolean
        Whether month names and weekday names should be abbreviated.
        __Default value:__  `false`
    """
    _additional_traits = False
    _required_traits = []
    _trait_name_map = {}
    shortTimeLabels = jst.JSONBoolean(help='Whether month names and weekday names should be abbreviated. [...]')

    def __init__(self, shortTimeLabels=jst.undefined, **kwargs):
        kwds = dict(shortTimeLabels=shortTimeLabels)
        kwargs.update({k:v for k, v in kwds.items() if v is not jst.undefined})
        super(VlOnlyGuideConfig, self).__init__(**kwargs)
































